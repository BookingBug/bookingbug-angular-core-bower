'use strict';

angular.module('BB', ['ngStorage', 'ngMessages', 'ngSanitize', 'ngFileUpload', 'ngCookies', 'ngAnimate', 'angularMoment', 'angular-carousel', 'angular-hal', 'angular-data.DSCacheFactory', 'angular.filter', 'pascalprecht.translate', 'schemaForm', 'ui.bootstrap', 'ui.map', 'ui.router.util', 'ui.select', 'ui-rangeSlider', 'uiGmapgoogle-maps', 'vcRecaptcha', 'BB.Controllers', 'BB.Filters', 'BB.Models', 'BB.Services', 'BB.Directives', 'BB.analytics', 'BB.i18n', 'BB.uib', 'BB.uiSelect']);

angular.module('BB.Services', ['ngResource', 'ngSanitize', 'pascalprecht.translate']);

angular.module('BB.Controllers', ['ngSanitize']);

angular.module('BB.Directives', []);
angular.module('BB.Filters', []);
angular.module('BB.Models', []);
'use strict';

angular.module('BB.analytics', ['angulartics', 'angulartics.piwik']);
'use strict';

angular.module('BB.i18n', ['tmh.dynamicLocale']);
'use strict';

(function () {
    angular.module('toggle-switch', ['ng']);
})();
'use strict';

angular.module('BB.uiSelect', []);
'use strict';

angular.module('BB.uib', ['ui.bootstrap']);
'use strict';

angular.module('BB').value('AppConfig', {
    appId: 'f6b16c23',
    appKey: 'f0bc4f65f4fbfe7b4b3b7264b655f5eb'
});

angular.module('BB').value('AirbrakeConfig', {
    projectId: '122836',
    projectKey: 'e6d6710b2cf00be965e8452d6a384d37',
    environment: window.location.hostname === 'localhost' ? 'development' : 'production'
});

if (window.use_no_conflict) {
    window.bbjq = $.noConflict();
    angular.module('BB').value('$bbug', jQuery.noConflict(true));
} else {
    angular.module('BB').value('$bbug', jQuery);
}

angular.module('BB').constant('UriTemplate', window.UriTemplate);

angular.module('BB').config(function ($locationProvider, $httpProvider, $provide, uiGmapGoogleMapApiProvider, $analyticsProvider) {
    'ngInject';

    uiGmapGoogleMapApiProvider.configure({
        v: '3.20',
        libraries: 'weather,geometry,visualization'
    });

    $httpProvider.defaults.headers.common = {
        'App-Id': 'f6b16c23',
        'App-Key': 'f0bc4f65f4fbfe7b4b3b7264b655f5eb'
    };
});

window.bookingbug = {
    //TODO remove
    logout: function logout(options) {
        if (!options) {
            options = {};
        }
        if (options.reload !== false) {
            options.reload = true;
        }
        var logout_opts = {
            app_id: 'f6b16c23',
            app_key: 'f0bc4f65f4fbfe7b4b3b7264b655f5eb'
        };
        if (options.root) {
            logout_opts.root = options.root;
        }
        angular.injector(['BB.Services', 'BB.Models', 'ng']).get('LoginService').logout(logout_opts);
        if (options.reload) {
            return window.location.reload();
        }
    }
};

window.getURIparam = function (name) {
    //TODO remove
    name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
    var regexS = "[\\?&]" + name + "=([^&#]*)";
    var regex = new RegExp(regexS);
    var results = regex.exec(window.location.href);
    if (results == null) return "";else return results[1];
};
'use strict';

angular.module('BB').run(function ($bbug, FormDataStoreService, $log, $rootScope, $sessionStorage) {
    'ngInject';

    $rootScope.$setIfUndefined = FormDataStoreService.setIfUndefined;

    if (!$rootScope.bb) {
        $rootScope.bb = {};
    }
    $rootScope.bb.api_url = $sessionStorage.getItem('host');

    if ($bbug.support.opacity === false) {
        document.createElement('header');
        document.createElement('nav');
        document.createElement('section');
        document.createElement('footer');
    }
});
'use strict';

angular.module('schemaForm').config(function (schemaFormProvider, schemaFormDecoratorsProvider, sfPathProvider) {

    var timepicker = function timepicker(name, schema, options) {
        if (schema.type === 'string' && schema.format === 'time') {
            var f = schemaFormProvider.stdFormObj(name, schema, options);
            f.key = options.path;
            f.type = 'timepicker';
            options.lookup[sfPathProvider.stringify(options.path)] = f;
            return f;
        }
    };

    schemaFormProvider.defaults.string.unshift(timepicker);

    var datetimepicker = function datetimepicker(name, schema, options) {
        if (schema.type === 'string' && schema.format === 'datetime') {
            var f = schemaFormProvider.stdFormObj(name, schema, options);
            f.key = options.path;
            f.type = 'datetime';
            options.lookup[sfPathProvider.stringify(options.path)] = f;
            return f;
        }
    };

    schemaFormProvider.defaults.string.unshift(datetimepicker);

    var phonenumber = function phonenumber(name, schema, options) {
        if (schema.type === 'string' && schema.format === 'tel') {
            var f = schemaFormProvider.stdFormObj(name, schema, options);
            f.key = options.path;
            f.type = 'phonenumber';
            options.lookup[sfPathProvider.stringify(options.path)] = f;
            return f;
        }
    };

    schemaFormProvider.defaults.string.unshift(phonenumber);

    schemaFormDecoratorsProvider.addMapping('bootstrapDecorator', 'time', 'bootstrap_ui_time_form.html');

    schemaFormDecoratorsProvider.createDirective('time', 'bootstrap_ui_time_form.html');

    schemaFormDecoratorsProvider.addMapping('bootstrapDecorator', 'datetime', 'bootstrap_ui_datetime_form.html');

    schemaFormDecoratorsProvider.createDirective('datetime', 'bootstrap_ui_datetime_form.html');

    schemaFormDecoratorsProvider.addMapping('bootstrapDecorator', 'phonenumber', 'bootstrap_ui_phonenumber_form.html');

    schemaFormDecoratorsProvider.createDirective('phonenumber', 'bootstrap_ui_phonenumber.html');

    schemaFormDecoratorsProvider.addMapping('bootstrapDecorator', 'price', 'price_form.html');

    schemaFormDecoratorsProvider.createDirective('price', 'price_form.html');

    schemaFormDecoratorsProvider.addMapping('bootstrapDecorator', 'date', 'date_form.html');

    schemaFormDecoratorsProvider.createDirective('date', 'date_form.html');

    schemaFormDecoratorsProvider.addMapping('bootstrapDecorator', 'radios', 'radios.html');

    schemaFormDecoratorsProvider.createDirective('radios', 'radios.html');
    schemaFormDecoratorsProvider.addMapping('bootstrapDecorator', 'radios-inline', 'radios-inline.html');

    schemaFormDecoratorsProvider.createDirective('radios-inline', 'radios-inline.html');
    schemaFormDecoratorsProvider.addMapping('bootstrapDecorator', 'radiobuttons', 'radio-buttons.html');

    return schemaFormDecoratorsProvider.createDirective('radiobuttons', 'radio-buttons.html');
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

window.Collection = function Collection() {
    _classCallCheck(this, Collection);
};

window.Collection.Base = function () {
    function Base(res, items, params) {
        _classCallCheck(this, Base);

        this.res = res;
        this.items = items;
        this.params = params;
        this.callbacks = [];

        var clean_params = {};
        for (var key in params) {
            var val = params[key];
            if (val != null) {
                if (val.id != null) {
                    clean_params[key + "_id"] = val.id;
                } else {
                    clean_params[key] = val;
                }
            }
        }
        this.jparams = JSON.stringify(clean_params);
        if (res) {
            for (var n in res) {
                var m = res[n];
                this[n] = m;
            }
        }
    }

    Base.prototype.checkItem = function checkItem(item) {
        var _this = this;

        var call = void 0;
        if (!this.matchesParams(item)) {
            this.deleteItem(item); //delete if it is in the collection at the moment
            return true;
        } else {
            for (var index = 0; index < this.items.length; index++) {
                var existingItem = this.items[index];
                if (item.self === existingItem.self) {
                    this.items[index] = item;
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = Array.from(this.callbacks)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            call = _step.value;

                            call[1](item, "update");
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }

                    return true;
                }
            }
        }

        this.items.push(item);
        return function () {
            var result = [];
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = Array.from(_this.callbacks)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    call = _step2.value;

                    result.push(call[1](item, "add"));
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            return result;
        }();
    };

    Base.prototype.deleteItem = function deleteItem(item) {
        var len = this.items.length;
        this.items = this.items.filter(function (x) {
            return x.self !== item.self;
        });
        if (this.items.length !== len) {
            return Array.from(this.callbacks).map(function (call) {
                return call[1](item, "delete");
            });
        }
    };

    Base.prototype.getItems = function getItems() {
        return this.items;
    };

    Base.prototype.addCallback = function addCallback(obj, fn) {
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
            for (var _iterator3 = Array.from(this.callbacks)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var call = _step3.value;

                if (call[0] === obj) {
                    return;
                }
            }
        } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                    _iterator3.return();
                }
            } finally {
                if (_didIteratorError3) {
                    throw _iteratorError3;
                }
            }
        }

        return this.callbacks.push([obj, fn]);
    };

    Base.prototype.matchesParams = function matchesParams(item) {
        return true;
    };

    return Base;
}();

window.BaseCollections = function () {
    function BaseCollections() {
        _classCallCheck(this, BaseCollections);

        this.collections = [];
    }

    BaseCollections.prototype.count = function count() {
        return this.collections.length;
    };

    BaseCollections.prototype.add = function add(col) {
        return this.collections.push(col);
    };

    BaseCollections.prototype.checkItems = function checkItems(item) {
        return Array.from(this.collections).map(function (col) {
            return col.checkItem(item);
        });
    };

    BaseCollections.prototype.deleteItems = function deleteItems(item) {
        return Array.from(this.collections).map(function (col) {
            return col.deleteItem(item);
        });
    };

    BaseCollections.prototype.find = function find(prms) {
        var clean_params = {};
        for (var key in prms) {
            var val = prms[key];
            if (val != null) {
                if (val.id != null) {
                    clean_params[key + "_id"] = val.id;
                } else {
                    clean_params[key] = val;
                }
            }
        }
        var jprms = JSON.stringify(clean_params);
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
            for (var _iterator4 = Array.from(this.collections)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var col = _step4.value;

                if (jprms === col.jparams) {
                    return col;
                }
            }
        } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion4 && _iterator4.return) {
                    _iterator4.return();
                }
            } finally {
                if (_didIteratorError4) {
                    throw _iteratorError4;
                }
            }
        }
    };

    BaseCollections.prototype.delete = function _delete(col) {
        return this.collections = _.without(this.collections, col);
    };

    return BaseCollections;
}();
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

window.Collection.Day = function (_window$Collection$Ba) {
    _inherits(Day, _window$Collection$Ba);

    function Day() {
        _classCallCheck(this, Day);

        return _possibleConstructorReturn(this, _window$Collection$Ba.apply(this, arguments));
    }

    Day.prototype.checkItem = function checkItem(item) {
        var _window$Collection$Ba2;

        return (_window$Collection$Ba2 = _window$Collection$Ba.prototype.checkItem).call.apply(_window$Collection$Ba2, [this].concat(Array.prototype.slice.call(arguments)));
    };

    return Day;
}(window.Collection.Base);

angular.module('BB.Services').provider("DayCollections", function () {
    return {
        $get: function $get() {
            return new window.BaseCollections();
        }
    };
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

window.Collection.Space = function (_window$Collection$Ba) {
    _inherits(Space, _window$Collection$Ba);

    function Space() {
        _classCallCheck(this, Space);

        return _possibleConstructorReturn(this, _window$Collection$Ba.apply(this, arguments));
    }

    Space.prototype.checkItem = function checkItem(item) {
        var _window$Collection$Ba2;

        return (_window$Collection$Ba2 = _window$Collection$Ba.prototype.checkItem).call.apply(_window$Collection$Ba2, [this].concat(Array.prototype.slice.call(arguments)));
    };

    return Space;
}(window.Collection.Base);

angular.module('BB.Services').provider("SpaceCollections", function () {
    return {
        $get: function $get() {
            return new window.BaseCollections();
        }
    };
});
'use strict';

angular.module('angular-hal', []).provider('data_cache', function () {

    this.$get = function () {
        var data = [];

        return {

            set: function set(key, val) {
                data[key] = val;
                return val;
            },
            get: function get(key) {
                return data[key];
            },
            del: function del(key) {
                delete data[key];
            },
            has: function has(key) {
                return key in data;
            },
            delMatching: function delMatching(str) {
                for (var k in data) {
                    if (k.indexOf(str) != -1) delete data[k];
                }
            }

        };
    };
}).provider('shared_header', function () {
    this.$get = function () {
        var data = {};

        return {

            set: function set(key, val, store) {
                // also store this in the session store
                store.setItem(key, val);
                data[key] = val;
                return val;
            },
            get: function get(key) {
                return data[key];
            },
            del: function del(key) {
                delete data[key];
            },
            has: function has(key) {
                return key in data;
            }
        };
    };
}).factory('halClient', ['$http', '$q', 'data_cache', 'shared_header', 'UriTemplate', '$cookies', '$sessionStorage', '$localStorage', function ($http, $q, data_cache, shared_header, UriTemplate, $cookies, $sessionStorage, $localStorage) {

    if ($sessionStorage.getItem('auth_token')) shared_header.set('auth_token', $sessionStorage.getItem('auth_token'), $sessionStorage);else if ($cookies.get('Auth-Token') && !shared_header.has('auth_token')) {
        shared_header.set('auth_token', $cookies.get('Auth-Token'), $sessionStorage);
    }

    return {
        setCache: function setCache(cache) {
            data_cache = cache;
        },
        clearCache: function clearCache(str) {
            data_cache.delMatching(str);
        },
        createResource: function createResource(store) {
            if (typeof store === 'string') {
                store = JSON.parse(store);
            }
            var resource = store.data;
            resource._links = store.links;
            var key = store.links.self.href;
            var options = store.options;
            return new BaseResource(key, options, resource);
        },
        $get: function $get(href, options) {
            if (data_cache.has(href) && (!options || !options.no_cache)) return data_cache.get(href);
            return data_cache.set(href, callService('GET', href, options));
            //        return callService('GET', href, options);
        } //get
        , $post: function $post(href, options, data) {
            return callService('POST', href, options, data);
        } //post
        , $put: function $put(href, options, data) {
            return callService('PUT', href, options, data);
        } //put
        , $patch: function $patch(href, options, data) {
            return callService('PATCH', href, options, data);
        } //patch
        , $del: function $del(href, options, data) {
            return callService('DELETE', href, options, data);
        } //del
        , $parse: function $parse(data) {
            return parseHal(data);
        } //parse
    };

    function BaseResource(href, options, data, extra) {
        if (!options) options = {};
        if (!extra) extra = {};
        var links = {};
        var embedded = data_cache;
        if (data.hasOwnProperty('auth_token')) {
            options['auth_token'] = data['auth_token'];
        }

        href = getSelfLink(href, data).href;

        defineHiddenProperty(this, '$href', function (rel, params) {
            if (!(rel in links)) return null;

            return hrefLink(links[rel], params);
        });
        defineHiddenProperty(this, '$has', function (rel) {
            return rel in links;
        });
        defineHiddenProperty(this, '$flush', function (rel, params) {
            var link = links[rel];
            return flushLink(link, params);
        });
        defineHiddenProperty(this, '$get', function (rel, params) {
            var link = links[rel];
            return callLink('GET', link, params);
        });
        defineHiddenProperty(this, '$post', function (rel, params, data) {
            var link = links[rel];
            return callLink('POST', link, params, data);
        });
        defineHiddenProperty(this, '$put', function (rel, params, data) {
            var link = links[rel];
            return callLink('PUT', link, params, data);
        });
        defineHiddenProperty(this, '$patch', function (rel, params, data) {
            var link = links[rel];
            return callLink('PATCH', link, params, data);
        });
        defineHiddenProperty(this, '$del', function (rel, params, data) {
            var link = links[rel];
            return callLink('DELETE', link, params, data);
        });
        defineHiddenProperty(this, '$links', function () {
            return links;
        });
        defineHiddenProperty(this, '$toStore', function () {
            return JSON.stringify({ data: this, links: links, options: options });
        });
        defineHiddenProperty(this, 'setOption', function (key, value) {
            options[key] = value;
        });
        defineHiddenProperty(this, 'getOption', function (key) {
            return options[key];
        });
        defineHiddenProperty(this, '$link', function (rel) {
            return links[rel];
        });

        Object.keys(data).filter(function (key) {
            return !~['_', '$'].indexOf(key[0]);
        }).forEach(function (key) {
            this[key] = data[key];
            //        Object.defineProperty(this, key, {
            //        configurable: false
            //        , enumerable: true
            //        , value: data[key]
            //     });
        }, this);

        if (data._links) {
            Object.keys(data._links).forEach(function (rel) {
                var link = data._links[rel];
                link = normalizeLink(href, link);
                links[rel] = link;
            }, this);
        }

        if (data._embedded) {
            Object.keys(data._embedded).forEach(function (rel) {
                var embedded = data._embedded[rel];
                var link = getSelfLink(href, embedded);
                links[rel] = link;

                var resource = createResource(href, options, embedded);

                embedResource(resource);
            }, this);
        }

        if (extra.is_new) this.is_new = true;

        function defineHiddenProperty(target, name, value) {
            target[name] = value;
            // Object.defineProperty(target, name, {
            // configurable: false
            //     , enumerable: false
            //    , value: value
            // });
        } //defineHiddenProperty


        function embedResource(resource) {
            if (angular.isArray(resource)) return resource.map(function (resource) {
                return embedResource(resource);
            });

            var href = resource.$href('self');

            embedded.set(href, $q.when(resource));
        } //embedResource

        function hrefLink(link, params) {
            var href = link.templated ? new UriTemplate(link.href).fillFromObject(params || {}) : link.href;

            return href;
        } //hrefLink

        function callLink(method, link, params, data) {
            if (params == null) {
                params = {};
            }

            if (angular.isArray(link)) return $q.all(link.map(function (link) {
                if (method !== 'GET') throw 'method is not supported for arrays';

                return callLink(method, link, params, data);
            }));

            var linkHref = hrefLink(link, params);
            if (method === 'GET') {
                if (embedded.has(linkHref) && !params['no_cache']) {
                    return embedded.get(linkHref);
                } else {
                    return embedded.set(linkHref, callService(method, linkHref, options, data));
                }
            } else {
                return callService(method, linkHref, options, data);
            }
        } //callLink

        function flushLink(link, params) {
            if (angular.isArray(link)) return link.map(function (link) {
                return flushLink(link, params);
            });

            var linkHref = hrefLink(link, params);
            if (embedded.has(linkHref)) embedded.del(linkHref);
        } //flushLink
    } //Resource


    function createResource(href, options, data, extra) {
        if (angular.isArray(data)) return data.map(function (data) {
            return createResource(href, options, data, extra);
        });

        var resource = new BaseResource(href, options, data, extra);

        return resource;
    } //createResource


    function normalizeLink(baseHref, link) {
        if (angular.isArray(link)) return link.map(function (link) {
            return normalizeLink(baseHref, link);
        });

        if (link) {
            if (typeof link === 'string') link = { href: link };
            link.href = resolveUrl(baseHref, link.href);
        } else {
            link = { href: baseHref };
        }

        return link;
    } //normalizeLink


    function getSelfLink(baseHref, resource) {
        if (angular.isArray(resource)) return resource.map(function (resource) {
            return getSelfLink(baseHref, resource);
        });

        return normalizeLink(baseHref, resource && resource._links && resource._links.self);
    } //getSelfLink


    function callService(method, href, options, data) {
        if (!options) options = {};
        var headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/hal+json,application/json'
        };
        if (options.authorization) headers.Authorization = options.authorization;
        if (options.app_id) shared_header.set('app_id', options.app_id, $sessionStorage);
        if (options.app_key) shared_header.set('app_key', options.app_key, $sessionStorage);
        if (options.auth_token) {
            $sessionStorage.setItem('auth_token', options.auth_token);
            shared_header.set('auth_token', options.auth_token, $sessionStorage);
        }

        if (shared_header.has('app_id')) headers['App-Id'] = shared_header.get('app_id');
        if (shared_header.has('app_key')) headers['App-Key'] = shared_header.get('app_key');

        if (shared_header.has('auth_token')) headers['Auth-Token'] = shared_header.get('auth_token');

        if (options.bypass_auth) headers['Bypass-Auth'] = options.bypass_auth;
        var resource = $http({
            method: method,
            url: options.transformUrl ? options.transformUrl(href) : href,
            headers: headers,
            data: data
        }).then(function (res) {

            // copy out the auth token from the header if the response is new resource
            // Note: we only take the auth token from created responses as at the app layer, success responses might be cached results, thus we don't want to use the auth token from these
            if (res.headers('auth-token') && res.status == 201) {
                options.auth_token = res.headers('Auth-Token');
                shared_header.set('auth_token', res.headers('Auth-Token'), $sessionStorage);
                // if auth token is present in local storage, set it there too
                if ($localStorage.getItem('auth_token')) $localStorage.setItem('auth_token', res.headers('Auth-Token'));
            }
            switch (res.status) {
                case 200:
                    //For back-ends that return `"null"` instead of `null` -_-
                    if (res.data && res.data !== '"null"') return createResource(href, options, res.data);
                    return null;

                case 201:
                    var extra = { is_new: true };
                    if (res.data) return createResource(href, options, res.data, extra);
                    if (res.headers('Content-Location')) return res.headers('Content-Location');
                    return null;

                case 204:
                    return null;

                default:
                    return $q.reject(res);
            }
        }, function (res) {
            return $q.reject(res);
        });

        return resource;
    } //callService

    function parseHal(data) {
        var resource = createResource(data._links.self.href, null, data);
        return resource;
    } //parseHal


    function resolveUrl(baseHref, href) {
        var resultHref = '';
        var reFullUrl = /^((?:\w+\:)?)((?:\/\/)?)([^\/]*)((?:\/.*)?)$/;
        var baseHrefMatch = reFullUrl.exec(baseHref);
        var hrefMatch = reFullUrl.exec(href);

        for (var partIndex = 1; partIndex < 5; partIndex++) {
            if (hrefMatch[partIndex]) resultHref += hrefMatch[partIndex];else resultHref += baseHrefMatch[partIndex];
        }

        return resultHref;
    } //resolveUrl
}]) //service
;
'use strict';

angular.module('ngStorage', []).factory('$fakeStorage', ['$cookies', function ($cookies) {
    function FakeStorage() {}

    FakeStorage.prototype.setItem = function (key, value) {
        $cookies.put(key, value);
    };
    FakeStorage.prototype.getItem = function (key) {
        return typeof $cookies.get(key) == 'undefined' ? null : $cookies.get(key);
    };
    FakeStorage.prototype.removeItem = function (key) {
        if ($cookies.get(key)) {
            $cookies.remove(key);
        }
    };
    FakeStorage.prototype.clear = function () {
        for (var key in $cookies.getAll()) {
            $cookies.remove(key);
        }
    };
    FakeStorage.prototype.key = function (index) {
        return Object.keys($cookies.getAll())[index];
    };
    return new FakeStorage();
}]).factory('$localStorage', ['$window', '$fakeStorage', function ($window, $fakeStorage) {
    function isStorageSupported(storageName) {
        var testKey = 'test',
            storage = $window[storageName];
        try {
            storage.setItem(testKey, '1');
            storage.removeItem(testKey);
            return true;
        } catch (error) {
            return false;
        }
    }

    var storage = isStorageSupported('localStorage') ? $window.localStorage : $fakeStorage;
    return {
        setItem: function setItem(key, value) {
            storage.setItem(key, value);
        },
        getItem: function getItem(key, defaultValue) {
            return storage.getItem(key) || defaultValue;
        },
        setObject: function setObject(key, value) {
            storage.setItem(key, JSON.stringify(value));
        },
        getObject: function getObject(key) {
            return JSON.parse(storage.getItem(key) || '{}');
        },
        removeItem: function removeItem(key) {
            storage.removeItem(key);
        },
        clear: function clear() {
            storage.clear();
        },
        key: function key(index) {
            storage.key(index);
        }
    };
}]).factory('$sessionStorage', ['$window', '$fakeStorage', function ($window, $fakeStorage) {
    function isStorageSupported(storageName) {
        var testKey = 'test',
            storage = $window[storageName];
        try {
            storage.setItem(testKey, '1');
            storage.removeItem(testKey);
            return true;
        } catch (error) {
            return false;
        }
    }

    var storage = isStorageSupported('sessionStorage') ? $window.sessionStorage : $fakeStorage;
    return {
        setItem: function setItem(key, value) {
            storage.setItem(key, value);
        },
        getItem: function getItem(key, defaultValue) {
            return storage.getItem(key) || defaultValue;
        },
        setObject: function setObject(key, value) {
            storage.setItem(key, JSON.stringify(value));
        },
        getObject: function getObject(key) {
            return JSON.parse(storage.getItem(key) || '{}');
        },
        removeItem: function removeItem(key) {
            storage.removeItem(key);
        },
        clear: function clear() {
            storage.clear();
        },
        key: function key(index) {
            storage.key(index);
        }
    };
}]);
'use strict';

// THIS DOESN'T APPEAR TO BE USED?
angular.module('ngLocalData', ['angular-hal']).factory('$localCache', ['halClient', '$q', '$sessionStorage', function (halClient, $q, $sessionStorage) {
    data = {};

    jsonData = function jsonData(data) {
        return data && JSON.parse(data);
    };

    storage = function storage() {
        return $sessionStorage;
    };
    localSave = function localSave(key, item) {
        storage().setItem(key, item.$toStore());
    };
    localLoad = function localLoad(key) {
        res = jsonData(storage().getItem(key));
        if (res) {
            r = halClient.createResource(res);
            def = $q.defer();
            def.resolve(r);
            return def.promise;
        }
        return null;
    };
    localDelete = function localDelete(key) {
        storage().removeItem(key);
    };

    return {

        set: function set(key, val) {
            data[key] = val;
            val.then(function (item) {
                localSave(key, item);
            });
            return val;
        },
        get: function get(key) {
            localLoad(key);
            if (!data[key]) data[key] = localLoad(key);
            return data[key];
        },
        del: function del(key) {
            localDelete(key);
            delete data[key];
        },
        has: function has(key) {
            if (!data[key]) {
                res = localLoad(key);
                if (res) data[key] = res;
            }
            return key in data;
        }
    };
}]).factory('$localData', ['$http', '$rootScope', '$sessionStorage', function ($http, $rootScope, $sessionStorage) {
    function LocalDataFactory(name) {
        function LocalData(value) {
            this.setStore(value);
        }

        LocalData.prototype.jsonData = function (data) {
            return data && JSON.parse(data);
        };

        LocalData.prototype.storage = function () {
            return $sessionStorage;
        };

        LocalData.prototype.localSave = function (item) {
            this.storage().setItem(this.store_name + item.id, JSON.stringify(item));
        };

        LocalData.prototype.localSaveIndex = function (ids) {
            this.storage().setItem(this.store_name, ids.join(","));
            this.ids = ids;
        };

        LocalData.prototype.localLoadIndex = function () {
            store = this.storage().getItem(this.store_name);
            records = store && store.split(",") || [];
            return records;
        };

        LocalData.prototype.localLoad = function (id) {
            return this.jsonData(this.storage().getItem(this.store_name + id));
        };

        LocalData.prototype.count = function () {
            return this.ids.length;
        };

        LocalData.prototype.setStore = function (name) {
            this.store_name = name;
            this.data_store = [];
            this.ids = this.localLoadIndex();
            for (a = 0; a < this.ids.length; a++) {
                this.data_store.push(this.localLoad(this.ids[a]));
            }
            //    var channel = pusher.subscribe(name);
            //    var ds = this;

            //   channel.bind('add', function(data) {
            //     ds.data_store.push(data);
            //     $rootScope.$broadcast("Refresh_" + ds.store_name, "Updated");
            //   });
        };

        LocalData.prototype.update = function (data) {
            ids = [];
            for (x in data) {
                if (data[x].id) {
                    ids.push(data[x].id);
                    this.localSave(data[x]);
                }
            }
            this.localSaveIndex(ids);
        };

        return new LocalData(name);
    }

    return LocalDataFactory;
}]);
'use strict';

/*

 toISODate
 Extended moment with toISODate method to format dates for API date parameter assignment. Locale is enforced as `en` to ensure date is formatted correctly.

 */
if (!moment.fn.toISODate) {
    moment.fn.toISODate = function () {
        return this.clone().locale('en').format('YYYY-MM-DD');
    };
}
'use strict';

// String::includes polyfill
if (!String.prototype.includes) {

    String.prototype.includes = function (search, start) {
        if (typeof start !== 'number') {
            start = 0;
        }
        if (start + search.length > this.length) {
            return false;
        } else {
            return this.indexOf(search, start) !== -1;
        }
    };
}

// Extend String with parameterise method
String.prototype.parameterise = function (seperator) {
    if (seperator == null) {
        seperator = '-';
    }
    return this.trim().replace(/\s/g, seperator).toLowerCase();
};
'use strict';

(function () {

    angular.module('BB').constant('BBAlerts', [{
        key: 'GENERIC',
        type: 'error',
        persist: true
    }, {
        key: 'LOCATION_NOT_FOUND',
        type: 'warning',
        persist: true
    }, {
        key: 'MISSING_LOCATION',
        type: 'warning',
        persist: true
    }, {
        key: 'MISSING_POSTCODE',
        type: 'warning',
        persist: true
    }, {
        key: 'POSTCODE_INVALID',
        type: 'warning',
        persist: true
    }, {
        key: 'ITEM_NO_LONGER_AVAILABLE',
        type: 'error',
        persist: true
    }, {
        key: 'NO_WAITLIST_SPACES_LEFT',
        type: 'error',
        persist: true
    }, {
        key: 'FORM_INVALID',
        type: 'warning',
        persist: true
    }, {
        key: 'GEOLOCATION_ERROR_FORBIDDEN',
        type: 'error',
        persist: true
    }, {
        key: 'GEOLOCATION_ERROR',
        type: 'error',
        persist: true
    }, {
        key: 'EMPTY_BASKET_FOR_CHECKOUT',
        type: 'warning',
        persist: true
    }, {
        key: 'MAXIMUM_TICKETS',
        type: 'warning',
        persist: true
    }, {
        key: 'GIFT_CERTIFICATE_REQUIRED',
        type: 'warning',
        persist: true
    }, {
        key: 'TIME_SLOT_NOT_SELECTED',
        type: 'warning',
        persist: true
    }, {
        key: 'STORE_NOT_SELECTED',
        type: 'warning',
        persist: true
    }, {
        key: 'APPT_AT_SAME_TIME',
        type: 'warning',
        persist: true
    }, {
        key: 'REQ_TIME_NOT_AVAIL',
        type: 'warning',
        persist: true
    }, {
        key: 'TOPUP_SUCCESS',
        type: 'success',
        persist: true
    }, {
        key: 'TOPUP_FAILED',
        type: 'warning',
        persist: true
    }, {
        key: 'UPDATE_SUCCESS',
        type: 'success',
        persist: true
    }, {
        key: 'UPDATE_FAILED',
        type: 'warning',
        persist: true
    }, {
        key: 'ALREADY_REGISTERED',
        type: 'warning',
        persist: true
    }, {
        key: 'LOGIN_FAILED',
        type: 'warning',
        persist: true
    }, {
        key: 'SSO_LOGIN_FAILED',
        type: 'warning',
        persist: true
    }, {
        key: 'PASSWORD_INVALID',
        type: 'warning',
        persist: true
    }, {
        key: 'PASSWORD_RESET_REQ_SUCCESS',
        type: 'success',
        persist: true
    }, {
        key: 'PASSWORD_RESET_REQ_FAILED',
        type: 'warning',
        persist: true
    }, {
        key: 'PASSWORD_RESET_SUCESS',
        type: 'success',
        persist: true
    }, {
        key: 'PASSWORD_RESET_FAILED',
        type: 'warning',
        persist: true
    }, {
        key: 'PASSWORD_MISMATCH',
        type: 'warning',
        persist: true
    }, {
        key: 'ATTENDEES_CHANGED',
        type: 'info',
        persist: true
    }, {
        key: 'PAYMENT_FAILED',
        type: 'danger',
        persist: true
    }, {
        key: 'ACCOUNT_DISABLED',
        type: 'warning',
        persist: true
    }, {
        key: 'FB_LOGIN_NOT_A_MEMBER',
        type: 'warning',
        persist: true
    }, {
        key: 'PHONE_NUMBER_IN_USE',
        type: 'warning',
        persist: true
    }, {
        key: 'EMAIL_IN_USE',
        type: 'warning',
        persist: true
    }, {
        key: 'WAITLIST_ACCEPTED',
        type: 'success',
        persist: false
    }, {
        key: 'BOOKING_CANCELLED',
        type: 'success',
        persist: false
    }, {
        key: 'NOT_BOOKABLE_PERSON',
        type: 'warning',
        persist: false
    }, {
        key: 'NOT_BOOKABLE_RESOURCE',
        type: 'warning',
        persist: false
    }, {
        key: 'COUPON_APPLY_FAILED',
        type: 'warning',
        title: '',
        persist: true
    }, {
        key: 'DEAL_APPLY_FAILED',
        type: 'warning',
        title: '',
        persist: true
    }, {
        key: 'DEAL_REMOVE_FAILED',
        type: 'warning',
        title: '',
        persist: true
    }]);
})();
'use strict';

(function () {

    angular.module('BB').constant('routeStates', {
        Company: 0,
        Category: 1,
        Service: 2,
        Person: 3,
        Resource: 4,
        Duration: 5,
        Date: 6,
        Time: 7,
        Client: 8,
        Summary: 9,
        Basket: 10,
        Checkout: 11,
        Slot: 12,
        Event: 13,
        Login: 14,
        Questions: 15,
        Confirmation: 16
    });
})();
'use strict';

// strips the postcode from the end of the address. i.e.
// '15 some address, somwhere, SS1 4RP' becomes '15 some address, somwhere'
angular.module('BB.Filters').filter('stripPostcode', function () {
    return function (address) {
        // test to see if the address contains a postcode by searching for a any
        // letter followed by a number i.e N1, CM11
        var match = address.toLowerCase().match(/[a-z]+\d/);
        // if there's a match, get the index of the match and remove postcode
        if (match) {
            address = address.substr(0, match.index);
        }
        // trim white space
        address = $.trim(address);
        //  remove trailing comma if there is one
        if (/,$/.test(address)) {
            address = address.slice(0, -1);
        }

        return address;
    };
});

angular.module('BB.Filters').filter('labelNumber', function () {
    return function (input, labels) {
        var response = input;
        if (labels[input]) {
            response = labels[input];
        }
        return response;
    };
});

angular.module('BB.Filters').filter('interpolate', ['version', function (version) {
    return function (text) {
        return String(text).replace(/\%VERSION\%/mg, version);
    };
}]);

angular.module('BB.Filters').filter('rag', function () {
    return function (value, v1, v2) {
        if (value <= v1) {
            return "red";
        } else if (value <= v2) {
            return "amber";
        } else {
            return "green";
        }
    };
});

angular.module('BB.Filters').filter('time', function ($window) {
    return function (v) {
        return $window.sprintf("%02d:%02d", Math.floor(v / 60), v % 60);
    };
});

angular.module('BB.Filters').filter('address_single_line', function () {
    return function (address) {

        if (!address) {
            return;
        }
        if (!address.address1) {
            return;
        }

        var addr = "";
        addr += address.address1;
        if (address.address2 && address.address2.length > 0) {
            addr += ", ";
            addr += address.address2;
        }
        if (address.address3 && address.address3.length > 0) {
            addr += ", ";
            addr += address.address3;
        }
        if (address.address4 && address.address4.length > 0) {
            addr += ", ";
            addr += address.address4;
        }
        if (address.address5 && address.address5.length > 0) {
            addr += ", ";
            addr += address.address5;
        }
        if (address.postcode && address.postcode.length > 0) {
            addr += ", ";
            addr += address.postcode;
        }
        return addr;
    };
});

angular.module('BB.Filters').filter('address_multi_line', function () {
    return function (address) {

        if (!address) {
            return;
        }
        if (!address.address1) {
            return;
        }

        var str = "";
        if (address.address1) {
            str += address.address1;
        }
        if (address.address2 && str.length > 0) {
            str += "<br/>";
        }
        if (address.address2) {
            str += address.address2;
        }
        if (address.address3 && str.length > 0) {
            str += "<br/>";
        }
        if (address.address3) {
            str += address.address3;
        }
        if (address.address4 && str.length > 0) {
            str += "<br/>";
        }
        if (address.address4) {
            str += address.address4;
        }
        if (address.address5 && str.length > 0) {
            str += "<br/>";
        }
        if (address.address5) {
            str += address.address5;
        }
        if (address.postcode && str.length > 0) {
            str += "<br/>";
        }
        if (address.postcode) {
            str += address.postcode;
        }
        return str;
    };
});

angular.module('BB.Filters').filter('map_lat_long', function () {
    return function (address) {
        if (!address) {
            return;
        }
        if (!address.map_url) {
            return;
        }

        var cord = /([-+]*\d{1,3}[\.]\d*)[, ]([-+]*\d{1,3}[\.]\d*)/.exec(address.map_url);
        return cord[0];
    };
});

/**
 * @ngdoc filter
 * @name distance
 * @kind function
 *
 * @description
 * Formats distance using current locale.
 *
 * @param {number} distance_in_km Distance in kilometres
 * @param {integer} round_by The number of decimal places to round by

 * @returns {string} Formatted distance
 *
 *

 <example module="distanceExample">
 <file name="index.html">
 <script>
 angular.module('distanceExample', [])
 .controller('ExampleController', ['$scope', function($scope) {
 $scope.distance = 10;
 }]);
 </script>
 <div ng-controller="ExampleController">
 <span>Price: {{distance | distance:1}}</span><br/>
 </div>
 </file>
 </example>
 */
angular.module('BB.Filters').filter('distance', function ($translate, bbLocale) {
    return function (distance_in_km, round_by) {

        if (!distance_in_km) {
            return '';
        }

        var distance = distance_in_km;
        var use_miles = bbLocale.getLocale().match(/^(en|en-gb|en-us)$/gi);
        if (use_miles) {
            distance *= 0.621371192;
        }
        if (round_by) {
            distance = Math.round(distance * Math.pow(10, round_by)) / Math.pow(10, round_by);
        }
        var unit = use_miles ? $translate.instant('CORE.FILTERS.DISTANCE.MILES') : $translate.instant('CORE.FILTERS.DISTANCE.KILOMETRES');
        distance = distance + ' ' + unit;

        return distance;
    };
});

/**
 * @ngdoc filter
 * @name currency
 * @kind function
 *
 * @description
 * Formats price using either the configured Company currency or the provided currency symbol.
 *
 * @param {integer} amount Input amount to format
 * @param {string} currency_code Optional currency symbol
 * @param {boolean} pretty_price Use to omit decimal places when price is whole. Default is false
 * @returns {string} Formatted currency.
 *
 *
 <example module="currencyExample">
 <file name="index.html">
 <script>
 angular.module('currencyExample', [])
 .controller('ExampleController', ['$scope', function($scope) {
 $scope.price = 950;
 }]);
 </script>
 <div ng-controller="ExampleController">
 <span>Price: {{price | currency}}</span><br/>
 </div>
 </file>
 </example>
 */
angular.module('BB.Filters').filter('currency', function ($window, $rootScope, CompanyStoreService, $translate) {
    return function (amount, currency_code, pretty_price) {

        if (pretty_price == null) {
            pretty_price = false;
        }
        if (!angular.isNumber(amount)) {
            return;
        }

        var currency_codes = { USD: "$", GBP: "£", AUD: "$", EUR: "€", CAD: "$", MIXED: "~", RUB: "₽" };

        if (!currency_code) {
            currency_code = CompanyStoreService.currency_code;
        }

        var format = $translate.instant(['CORE.FILTERS.CURRENCY.THOUSANDS_SEPARATOR', 'CORE.FILTERS.CURRENCY.DECIMAL_SEPARATOR', 'CORE.FILTERS.CURRENCY.CURRENCY_FORMAT']);

        var hide_decimal = pretty_price && amount % 100 === 0;
        var decimal_places = hide_decimal ? 0 : 2;

        return $window.accounting.formatMoney(amount / 100, currency_codes[currency_code], decimal_places, format.THOUSANDS_SEPARATOR, format.DECIMAL_SEPARATORS, format.CURRENCY_FORMAT);
    };
});

angular.module('BB.Filters').filter('icurrency', function ($filter) {
    return function (number, currency_code) {
        return $filter('currency')(number, currency_code);
    };
});

angular.module('BB.Filters').filter('raw_currency', function () {
    return function (number) {
        return number / 100.0;
    };
});

angular.module('BB.Filters').filter('pretty_price', function ($translate, $filter) {
    return function (price, currency_code) {
        if (parseFloat(price) === 0) {
            return $translate.instant('CORE.FILTERS.PRETTY_PRICE.FREE');
        } else {
            return $filter('currency')(price, currency_code, true);
        }
    };
});

angular.module('BB.Filters').filter('ipretty_price', function ($filter) {
    return function (number, currencyCode) {
        return $filter('pretty_price')(number, currencyCode);
    };
});

/**
 * @ngdoc filter
 * @name time_period
 * @kind function
 *
 * @description
 * Formats a number as a humanized duration, e.g. 1 hour, 2 minutes
 *
 * @param {number} minutes Input to format
 * @returns {string} Humanized duration.
 *
 *

 <example module="timePeriodExample">
 <file name="index.html">
 <script>
 angular.module('timePeriodExample', [])
 .controller('ExampleController', ['$scope', function($scope) {
 $scope.duration = 90;
 }]);
 </script>
 <div ng-controller="ExampleController">
 <span>Duration: {{amount | time_period}}</span>
 </div>
 </file>
 </example>
 */
angular.module('BB.Filters').filter('time_period', function ($translate) {
    return function (v) {

        if (!angular.isNumber(v)) {
            return;
        }

        var minutes = parseInt(v);

        var hours = Math.floor(minutes / 60);
        minutes %= 60;
        var show_seperator = hours > 0 && minutes > 0;

        var time_period = $translate.instant('CORE.FILTERS.TIME_PERIOD.TIME_PERIOD', {
            hours: hours,
            minutes: minutes,
            show_seperator: +show_seperator
        }, 'messageformat');

        return time_period;
    };
});

/**
 * @ngdoc filter
 * @name time_period_from_seconds
 * @kind function
 *
 * @description
 * Formats a number as a humanized duration, e.g. 1 hour, 2 minutes, 5 seconds
 *
 * @param {number} seconds Input to format
 * @returns {string} Humanized duration.
 *
 *

 <example module="timePeriodExample">
 <file name="index.html">
 <script>
 angular.module('timePeriodExample', [])
 .controller('ExampleController', ['$scope', function($scope) {
 $scope.duration = 90;
 }]);
 </script>
 <div ng-controller="ExampleController">
 <span>Duration: {{amount | time_period_from_seconds}}</span>
 </div>
 </file>
 </example>
 */
angular.module('BB.Filters').filter('time_period_from_seconds', function ($translate, $filter) {
    return function (v, precision) {

        if (!angular.isNumber(v)) {
            return;
        }

        var seconds = parseInt(v);
        var time_period = '';

        if (precision == 'minutes') {
            return moment.duration(seconds / 60, 'minutes').humanize();
        }

        if (seconds >= 60) {
            time_period += $filter('time_period')(seconds / 60);
            if (seconds % 60 > 0) {
                time_period += $translate.instant('CORE.FILTERS.TIME_PERIOD.TIME_PERIOD');
            }
        }
        if (seconds % 60 > 0) {
            time_period += moment.duration(seconds % 60, 'seconds').humanize();
        }

        return time_period;
    };
});

angular.module('BB.Filters').filter('twelve_hour_time', function ($window) {
    return function (time, options) {

        if (!angular.isNumber(time)) {
            return;
        }

        var omit_mins_on_hour = options && options.omit_mins_on_hour || false;
        var separator = options && options.separator ? options.separator : ":";

        var t = time;
        var h = Math.floor(t / 60);
        var m = t % 60;
        var suffix = 'am';
        if (h >= 12) {
            suffix = 'pm';
        }
        if (h > 12) {
            h -= 12;
        }
        if (m === 0 && omit_mins_on_hour) {
            time = '' + h;
        } else {
            time = '' + h + separator + $window.sprintf("%02d", m);
        }
        time += suffix;
        return time;
    };
});

angular.module('BB.Filters').filter('round_up', function () {
    return function (number, interval) {
        var result = number / interval;
        result = parseInt(result);
        result = result * interval;
        if (number % interval > 0) {
            result = result + interval;
        }
        return result;
    };
});

/**
 * @ngdoc filter
 * @name exclude_days
 * @kind function
 *
 * @description
 * Formats a phone number using provided country code. If no country code is passed in, the country of the current company is used.
 *
 * @param {array} days Array of BBModel.Day objects
 * @param {array} excluded String array of days to exclude, e.g. ['Saturday','Sunday']
 * @returns {array} Filtered array excluding specificed days
 *
 */
angular.module('BB.Filters').filter('exclude_days', function () {
    return function (days, excluded) {
        return _.filter(days, function (day) {
            return excluded.indexOf(day.date.format('dddd')) === -1;
        });
    };
});

/**
 * @ngdoc filter
 * @name local_phone_number
 * @kind function
 *
 * @description
 * Formats a phone number using provided country code. If no country code is passed in, the country of the current company is used.
 *
 * @param {string} phone_number The phone number to format
 * @param {string} country_code (Optional) The country code in Alpha-2 ISO-3166 format
 * @returns {string} Formatted phone number
 *
 *

 <example module="localPhoneNumberExample">
 <file name="index.html">
 <script>
 angular.module('localPhoneNumberExample', [])
 .controller('ExampleController', ['$scope', function($scope) {
 $scope.number = "+44 7877 123456";
 }]);
 </script>
 <div ng-controller="ExampleController">
 <span>Phone Number: {{number | local_phone_number}}</span>
 </div>
 </file>
 </example>
 */
angular.module('BB.Filters').filter('local_phone_number', function (CompanyStoreService, ValidatorService) {
    return function (phone_number, country_code) {

        if (!phone_number) {
            return;
        }

        if (!country_code) {
            country_code = CompanyStoreService.country_code;
        }

        switch (country_code) {
            case "gb":
                return phone_number.replace(/^(\+44 \(0\)|\S{0})/, '0');
            case "us":
                return phone_number.replace(ValidatorService.us_phone_number, "($1) $2 $3");
            default:
                return phone_number;
        }
    };
});

/**
 * @ngdoc filter
 * @name datetime
 * @kind function
 *
 * @description
 * Format given moment object or datelike string using provided format.
 *
 * @param {moment|string} date The date to format
 * @param {string} format The format to apply. Defaults to LLL
 * @param {boolean} showTimeZone Whether or not to display the time zone
 * @param {string} timeZoneToConvert The time zone to convert to
 *
 *

 <example module="dateTimeExample">
 <file name="index.html">
 <script>
 angular.module('dateTimeExample', [])
 .controller('ExampleController', ['$scope', function($scope) {
 $scope.date = moment();
 }]);
 </script>
 <div ng-controller="ExampleController">
 <span>Date: {{date | datetime}}</span>
 </div>
 </file>
 </example>
 */
angular.module('BB.Filters').filter('datetime', function ($translate, bbTimeZone) {
    return function (date, format, showTimeZone, timeZoneToConvert) {

        var timeZone = '';

        if (format == null) {
            format = "LLL";
        }

        if (!date || date && !moment(date).isValid()) {
            return;
        }

        var newDate = moment(date);

        // use the display timezone unless a timeZoneToConvert has been passed in
        if (timeZoneToConvert) {
            newDate.tz(timeZoneToConvert);
        } else {
            newDate.tz(bbTimeZone.getDisplay());
        }

        if (showTimeZone) {
            timeZone = '(' + $translate.instant('I18N.TIMEZONE_LOCATIONS.CODES.' + newDate.format('zz')) + ')';
        }

        return newDate.format(format) + ' ' + timeZone;
    };
});

angular.module('BB.Filters').filter('range', function () {
    return function (input, min, max) {
        __range__(parseInt(min), parseInt(max), true).map(function (i) {
            return input.push(i);
        });
        return input;
    };
});

angular.module('BB.Filters').filter('international_number', function () {
    return function (number, prefix) {
        if (number && prefix) {
            return prefix + ' ' + number;
        } else if (number) {
            return '' + number;
        } else {
            return "";
        }
    };
});

angular.module('BB.Filters').filter("startFrom", function () {
    return function (input, start) {
        if (input === undefined) {
            return input;
        } else {
            return input.slice(+start);
        }
    };
});

angular.module('BB.Filters').filter('add', function () {
    return function (item, value) {
        if (item && value) {
            item = parseInt(item);
            return item + value;
        }
    };
});

angular.module('BB.Filters').filter('spaces_remaining', function () {
    return function (spaces) {
        if (spaces < 1) {
            return 0;
        } else {
            return spaces;
        }
    };
});

angular.module('BB.Filters').filter('key_translate', function () {
    return function (input) {
        var upper_case = angular.uppercase(input);
        var remove_punctuations = upper_case.replace(/[\.,-\/#!$%\^&\*;:{}=\-_`~()]/g, "");
        var add_underscore = remove_punctuations.replace(/\ /g, "_");
        return add_underscore;
    };
});

angular.module('BB.Filters').filter('nl2br', function () {
    return function (str) {
        if (str) {
            // replace new lines with <br/> tags for multiline display in HTML
            return str.replace(/\n/g, '<br/>');
        }
    };
});

angular.module('BB.Filters').filter('clearTimezone', function () {
    return function (val, offset) {
        if (val !== null && val.length > 19) {
            return val.substring(0, 19);
        }
        return val;
    };
});

angular.module('BB.Filters').filter("format_answer", function () {
    return function (answer) {
        if (typeof answer === "boolean") {
            answer = answer === true ? "Yes" : "No";
        } else if (moment(answer, 'YYYY-MM-DD', true).isValid()) {
            answer = moment(answer).format("D MMMM YYYY");
        }
        return answer;
    };
});

angular.module('BB.Filters').filter('snakeCase', function () {
    return function (string) {
        return string.trim().replace(/\s/g, '_').toLowerCase();
    };
});

// -------------------------------------------------------------------------------------------
// filters out all non alpha-numeric characters with the exception of space and underscore
// -------------------------------------------------------------------------------------------
angular.module('BB.Filters').filter('wordCharactersAndSpaces', function () {
    return function (string) {
        return string.replace(/[^a-zA-Z0-9\_\s]+/, '');
    };
});

function __range__(left, right, inclusive) {
    var range = [];
    var ascending = left < right;
    var end = !inclusive ? right : ascending ? right + 1 : right - 1;
    for (var i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {
        range.push(i);
    }
    return range;
}
'use strict';

/**
 * @ngdoc filter
 * @name BB.Filters.filter:props
 * @description
 * Does an OR operation
 */
angular.module('BB.Filters').filter('props', function ($translate) {
    'ngInject';

    return function (items, props) {
        var out = [];
        if (angular.isArray(items)) {
            var keys = Object.keys(props);
            items.forEach(function (item) {
                var itemMatches = false;
                var i = 0;
                while (i < keys.length) {
                    var prop = keys[i];
                    var text = props[prop].toLowerCase();

                    if (item[prop] != null && $translate.instant(item[prop]).toString().toLowerCase().indexOf(text) !== -1) {
                        itemMatches = true;
                        break;
                    }
                    i++;
                }
                if (itemMatches) {
                    out.push(item);
                }
            });
        } else {
            // Let the output be the input untouched
            out = items;
        }

        return out;
    };
});
'use strict';

angular.module('BB.i18n').config(function (bbi18nOptionsProvider, tmhDynamicLocaleProvider, $translateProvider) {
    'ngInject';

    // sanitize just the translation text using the sanitize strategy as interpolation
    // param sanitization (sanitizeParameters) invalidates moment objects

    $translateProvider.useSanitizeValueStrategy('escape'); // TODO use sanitize strategy once it's reliable: https://angular-translate.github.io/docs/#/guide/19_security

    $translateProvider.useLocalStorage();

    $translateProvider.addInterpolation('$translateMessageFormatInterpolation');

    $translateProvider.fallbackLanguage(bbi18nOptionsProvider.getOption('available_languages'));

    tmhDynamicLocaleProvider.localeLocationPattern('angular-i18n/angular-locale_{{locale}}.js');

    tmhDynamicLocaleProvider.useCookieStorage();
});
'use strict';

angular.module('BB.i18n').run(function ($localStorage, bbi18nOptions, bbLocale, RuntimeTranslate, bbTimeZone, bbTimeZoneOptions) {
    'ngInject';

    RuntimeTranslate.registerAvailableLanguageKeys(bbi18nOptions.available_languages, bbi18nOptions.available_language_associations);

    bbLocale.determineLocale();
    bbTimeZone.determine();
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbWalletRemainder
 * @restrict A
 * @scope
 *   basketTotal: '='
 *   walletAmount: '='
 * @description
 *
 * Calculates wallet remainder
 *
 */

angular.module('BB.Directives').directive('bbWalletRemainder', function () {
    return {
        restrict: 'A',
        scope: {
            totalPrice: '=',
            walletAmount: '='
        },
        controllerAs: 'vm',
        bindToController: true,
        template: '<span translate="PUBLIC_BOOKING.BASKET.WALLET.REMAINDER" translate-values="{remainder: vm.amountRemaining}"></span>',
        controller: function controller() {
            return this.amountRemaining = this.walletAmount - this.totalPrice;
        }
    };
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:Address
 *
 * @description
 * Representation of an Address Object
 *
 * @property {string} address1 First line of the address
 * @property {string} address2 Second line of the address
 * @property {string} address3 Third line of the address
 * @property {string} address4 Fourth line of the address
 * @property {string} address5 Fifth line of the address
 * @property {string} postcode The Postcode/Zipcode
 * @property {string} country The country
 */ //


angular.module('BB.Models').factory("AddressModel", function ($q, BBModel, BaseModel, AddressListService) {
    return function (_BaseModel) {
        _inherits(Address, _BaseModel);

        function Address(data) {
            _classCallCheck(this, Address);

            // Assign value to map_url if the value is an empty String
            // Note: This is not ideal as it will not show a map marker. But the map_url prop should already be set, so this is just a fallback
            var _this = _possibleConstructorReturn(this, _BaseModel.call(this, data));

            if (!_this.map_url || _this.map_url === "") {
                if (_this.lat && _this.long) {
                    _this.map_url = "https://www.google.com/maps/@" + _this.lat + "," + _this.long + ",17z";
                }
            }
            return _this;
        }

        /***
         * @ngdoc method
         * @name addressSingleLine
         * @methodOf BB.Models:Address
         * @description
         * Get a the address as a single comma sepeated line
         *
         * @returns {string} The returned address
         */


        Address.prototype.addressSingleLine = function addressSingleLine() {
            var str = "";
            if (this.address1) {
                str += this.address1;
            }
            if (this.address2 && str.length > 0) {
                str += ", ";
            }
            if (this.address2) {
                str += this.address2;
            }
            if (this.address3 && str.length > 0) {
                str += ", ";
            }
            if (this.address3) {
                str += this.address3;
            }
            if (this.address4 && str.length > 0) {
                str += ", ";
            }
            if (this.address4) {
                str += this.address4;
            }
            if (this.address5 && str.length > 0) {
                str += ", ";
            }
            if (this.address5) {
                str += this.address5;
            }
            if (this.postcode && str.length > 0) {
                str += ", ";
            }
            if (this.postcode) {
                str += this.postcode;
            }
            return str;
        };

        /***
         * @ngdoc method
         * @name hasAddress
         * @methodOf BB.Models:Address
         * @description
         * Checks if this is considered a valid address
         *
         * @returns {boolean} If this is a valid address
         */


        Address.prototype.hasAddress = function hasAddress() {
            return this.address1 || this.address2 || this.postcode;
        };

        /***
         * @ngdoc method
         * @name addressCsvLine
         * @methodOf BB.Models:Address
         * @description
         * Get all address fields as a single comma sepeated line - suitable for csv export
         *
         * @returns {string} The returned address
         */


        Address.prototype.addressCsvLine = function addressCsvLine() {
            var str = "";
            if (this.address1) {
                str += this.address1;
            }
            str += ", ";
            if (this.address2) {
                str += this.address2;
            }
            str += ", ";
            if (this.address3) {
                str += this.address3;
            }
            str += ", ";
            if (this.address4) {
                str += this.address4;
            }
            str += ", ";
            if (this.address5) {
                str += this.address5;
            }
            str += ", ";
            if (this.postcode) {
                str += this.postcode;
            }
            str += ", ";
            if (this.country) {
                str += this.country;
            }
            return str;
        };

        /***
         * @ngdoc method
         * @name addressMultiLine
         * @methodOf BB.Models:Address
         * @description
         * Get a the address as multiple lines with line feeds
         *
         * @returns {string} The returned address
         */


        Address.prototype.addressMultiLine = function addressMultiLine() {
            var str = "";
            if (this.address1) {
                str += this.address1;
            }
            if (this.address2 && str.length > 0) {
                str += "<br/>";
            }
            if (this.address2) {
                str += this.address2;
            }
            if (this.address3 && str.length > 0) {
                str += "<br/>";
            }
            if (this.address3) {
                str += this.address3;
            }
            if (this.address4 && str.length > 0) {
                str += "<br/>";
            }
            if (this.address4) {
                str += this.address4;
            }
            if (this.address5 && str.length > 0) {
                str += "<br/>";
            }
            if (this.address5) {
                str += this.address5;
            }
            if (this.postcode && str.length > 0) {
                str += "<br/>";
            }
            if (this.postcode) {
                str += this.postcode;
            }
            return str;
        };

        Address.$query = function $query(prms) {
            return AddressListService.query(prms);
        };

        Address.$getAddress = function $getAddress(prms) {
            return AddressListService.getAddress(prms);
        };

        return Address;
    }(BaseModel);
});
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:Affiliate
 *
 * @description
 * Representation of an Affiliate Object
 *
 * @property {string} affiliate_id Id of the affiliated company
 * @property {string} reference The reference of the affiliated company
 * @property {integer} country_code Country code of the affiliated company
 */ //


// helpful functions about a company
angular.module('BB.Models').factory("AffiliateModel", function ($q, BBModel, BaseModel, halClient, $rootScope) {
    return function (_BaseModel) {
        _inherits(Affiliate, _BaseModel);

        function Affiliate(data) {
            _classCallCheck(this, Affiliate);

            var _this = _possibleConstructorReturn(this, _BaseModel.call(this, data));

            _this.test = 1;
            return _this;
        }

        /***
         * @ngdoc method
         * @name getCompanyByRef
         * @methodOf BB.Models:Affiliate
         * @description
         * Find a company in according to reference
         *
         * @param {string} ref A reference to find a company based on it
         *
         * @returns {promise} A promise for the company reference
         */


        Affiliate.prototype.getCompanyByRef = function getCompanyByRef(ref) {

            var prms = {
                id: this.cookie,
                reference: ref
            };

            var href = $rootScope.bb.api_url + '/api/v1/affiliates/{id}/companies/{reference}';
            var uri = new UriTemplate(href).fillFromObject(prms || {});

            var defer = $q.defer();

            halClient.$get(uri, {}).then(function (company) {
                if (company) {
                    return defer.resolve(new BBModel.Company(company));
                } else {
                    return defer.reject('No company for ref ' + ref);
                }
            }, function (err) {
                console.log('err ', err);
                return defer.reject(err);
            });
            return defer.promise;
        };

        return Affiliate;
    }(BaseModel);
});
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:Answer
 *
 * @description
 * Representation of an Answer Object
 *
 * @property {string} question The question that the answer belongs to
 */ //


angular.module('BB.Models').factory("AnswerModel", function ($q, BBModel, BaseModel, $bbug) {
    return function (_BaseModel) {
        _inherits(Answer, _BaseModel);

        function Answer(data) {
            _classCallCheck(this, Answer);

            return _possibleConstructorReturn(this, _BaseModel.call(this, data));
        }

        /***
         * @ngdoc method
         * @name getQuestion
         * @methodOf BB.Models:Answer
         * @description
         * Build an array of questions
         *
         * @returns {promise} A promise for the question/s
         */


        Answer.prototype.getQuestion = function getQuestion() {
            var _this2 = this;

            var defer = $q.defer();
            if (this.question) {
                defer.resolve(this.question);
            }
            if (this._data.$has('question')) {
                this._data.$get('question').then(function (question) {
                    _this2.question = question;
                    return defer.resolve(_this2.question);
                });
            } else {
                defer.resolve([]);
            }
            return defer.promise;
        };

        return Answer;
    }(BaseModel);
});
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// build a dynamic injector for each of the models!
// This creates a service that is capable of creating any given model
// It uses dynamic injection, to avoid a cuicular dependancy - as any model, needs to be able to create instances of other models


angular.module('BB.Models').service("BBModel", function ($q, $injector) {});

angular.module('BB.Models').run(function ($q, $injector, BBModel) {

    // the top level models
    var models = ['Address', 'Answer', 'Affiliate', 'Basket', 'BasketItem', 'BookableItem', 'Category', 'Client', 'ClientDetails', 'Company', 'CompanySettings', 'Day', 'Event', 'EventChain', 'EventGroup', 'EventTicket', 'EventSequence', 'Item', 'Items', 'ItemDetails', 'PaymentCallbacks', 'Person', 'PurchaseItem', 'PurchaseTotal', 'Question', 'Resource', 'Service', 'Slot', 'Space', 'Clinic', 'SurveyQuestion', 'TimeSlot', 'BusinessQuestion', 'Image', 'Deal', 'PrePaidBooking', 'MembershipLevel', 'Product', 'BBCollection', 'ExternalPurchase', 'PackageItem', 'BulkPurchase', 'Pagination', 'Reason', 'Login'];

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = Array.from(models)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var model = _step.value;

            BBModel[model] = $injector.get(model + "Model");
        }

        // purchase models
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    var purchase_models = ['Booking', 'Total', 'CourseBooking'];
    var pfuncs = {};
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = Array.from(purchase_models)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            model = _step2.value;

            pfuncs[model] = $injector.get('Purchase.' + model + 'Model');
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }

    return BBModel['Purchase'] = pfuncs;
});

//###########################
// The Base Model

// this provides some helpful functions to the models, that map various undelrying HAL resource functions

angular.module('BB.Models').service("BaseModel", function ($q, $injector, $rootScope, $timeout) {
    return function () {
        function Base(data) {
            _classCallCheck(this, Base);

            this.deleted = false;
            this.updateModel(data);
        }

        Base.prototype.updateModel = function updateModel(data) {
            var _this = this;

            if (data) {
                this._data = data;
            }
            if (data) {
                for (var n in data) {
                    var m = data[n];
                    if (typeof m !== 'function') {
                        this[n] = m;
                    }
                }
            }
            if (this._data && this._data.$href) {
                this.self = this._data.$href("self");
                // append get functions for all links...
                // for exmaple if the embedded object contains a link to 'people' we create two functions:
                // getPeople()  - which resolves eventaully to an array of People (this may take a few digest loops). This is good for use in views
                // getPeoplePromise()  -  which always returns a promise of the object - which is useful in controllers
                var links = this.$links();
                this.__linkedData = {};
                this.__linkedPromises = {};
                return function () {
                    var result = [];
                    for (var link in links) {
                        var obj = links[link];
                        var name = _this._snakeToCamel('get_' + link);
                        result.push(function (link, obj, name) {
                            if (!_this[name]) {
                                _this[name] = function (options) {
                                    return this.$buildOject(link, options);
                                };
                            }
                            if (!_this['$' + name]) {
                                return _this['$' + name] = function (options) {
                                    return this.$buildOjectPromise(link, options);
                                };
                            }
                        }(link, obj, name));
                    }
                    return result;
                }();
            }
        };

        Base.prototype._snakeToCamel = function _snakeToCamel(s) {
            return s.replace(/(\_\w)/g, function (m) {
                return m[1].toUpperCase();
            });
        };

        // build out a linked object


        Base.prototype.$buildOject = function $buildOject(link, options) {
            var _this2 = this;

            var linkId = link + (JSON.stringify(options) || '');

            if (this.__linkedData[linkId]) {
                return this.__linkedData[linkId];
            }
            this.$buildOjectPromise(link, options).then(function (ans) {
                _this2.__linkedData[linkId] = ans;
                // re-set it again with a digest loop - jsut to be sure!
                return $timeout(function () {
                    return _this2.__linkedData[linkId] = ans;
                });
            });
            return null;
        };

        // build a promise for a linked object


        Base.prototype.$buildOjectPromise = function $buildOjectPromise(link, options) {
            var linkId = link + (JSON.stringify(options) || '');

            if (this.__linkedPromises[linkId]) {
                return this.__linkedPromises[linkId];
            }
            var prom = $q.defer();
            this.__linkedPromises[linkId] = prom.promise;

            this.$get(link, options).then(function (res) {
                var inj = $injector.get('BB.Service.' + link);
                if (inj) {
                    if (inj.promise) {
                        // unwrap involving another promise
                        return inj.unwrap(res).then(function (ans) {
                            return prom.resolve(ans);
                        }, function (err) {
                            return prom.reject(err);
                        });
                    } else {
                        // unwrap without a promise
                        return prom.resolve(inj.unwrap(res));
                    }
                } else {
                    // no service found - just return the resources as I found it
                    return prom.resolve(res);
                }
            }, function (err) {
                return prom.reject(err);
            });

            return this.__linkedPromises[linkId];
        };

        Base.prototype.get = function get(ikey) {
            if (!this._data) {
                return null;
            }
            return this._data[ikey];
        };

        Base.prototype.set = function set(ikey, value) {
            if (!this._data) {
                return null;
            }
            return this._data[ikey] = value;
        };

        Base.prototype.getOption = function getOption(ikey) {
            if (!this._data) {
                return null;
            }
            return this._data.getOption(ikey);
        };

        Base.prototype.setOption = function setOption(ikey, value) {
            if (!this._data) {
                return null;
            }
            return this._data.setOption(ikey, value);
        };

        Base.prototype.$href = function $href(rel, params) {
            if (this._data) {
                return this._data.$href(rel, params);
            }
        };

        Base.prototype.$has = function $has(rel) {
            if (this._data) {
                return this._data.$has(rel);
            }
        };

        Base.prototype.$flush = function $flush(rel, params) {
            if (this._data) {
                return this._data.$flush(rel, params);
            }
        };

        Base.prototype.$get = function $get(rel, params) {
            if (this._data) {
                return this._data.$get(rel, params);
            }
        };

        Base.prototype.$post = function $post(rel, params, dat) {
            if (this._data) {
                return this._data.$post(rel, params, dat);
            }
        };

        Base.prototype.$put = function $put(rel, params, dat) {
            if (this._data) {
                return this._data.$put(rel, params, dat);
            }
        };

        Base.prototype.$patch = function $patch(rel, params, dat) {
            if (this._data) {
                return this._data.$patch(rel, params, dat);
            }
        };

        Base.prototype.$del = function $del(rel, params, dat) {
            if (this._data) {
                return this._data.$del(rel, params, dat);
            }
        };

        Base.prototype.$links = function $links() {
            if (this._data) {
                return this._data.$links();
            }
        };

        Base.prototype.$link = function $link(rel) {
            if (this._data) {
                return this._data.$link(rel);
            }
        };

        Base.prototype.$toStore = function $toStore() {
            if (this._data) {
                return this._data.$toStore();
            }
        };

        return Base;
    }();
});
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:Basket
 *
 * @description
 * Representation of an Basket Object
 *
 * @property {integer} company_id Company id that the basket belongs to
 * @property {integer} total_price Total price of the basket
 * @property {integer} total_due_price Total price of the basket after applying discounts
 * @property {array} items Array of items that are in the basket
 */

angular.module('BB.Models').factory("BasketModel", function ($q, BBModel, BaseModel, BasketService) {
    return function (_BaseModel) {
        _inherits(Basket, _BaseModel);

        function Basket(data, scope) {
            _classCallCheck(this, Basket);

            var _this = _possibleConstructorReturn(this, _BaseModel.call(this, data));

            if (scope && scope.isAdmin) {
                _this.is_admin = scope.isAdmin;
            } else {
                _this.is_admin = false;
            }
            if (scope != null && scope.parent_client) {
                _this.parent_client_id = scope.parent_client.id;
            }
            _this.items = [];
            _this.reviewed = false;
            return _this;
        }

        /***
         * @ngdoc method
         * @name addItem
         * @methodOf BB.Models:Basket
         * @description
         * Adds an item to the items array of the basket
         *
         */


        Basket.prototype.addItem = function addItem(item) {
            // check if the item is already in the basket
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = Array.from(this.items)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var i = _step.value;

                    if (i === item) {
                        return;
                    }
                    if (i.id && item.id && i.id === item.id) {
                        return;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return this.items.push(item);
        };

        /***
         * @ngdoc method
         * @name clear
         * @methodOf BB.Models:Basket
         * @description
         * Empty items array
         *
         */


        Basket.prototype.clear = function clear() {
            return this.items = [];
        };

        /***
         * @ngdoc method
         * @name clearItem
         * @methodOf BB.Models:Basket
         * @description
         * Remove a given item from the items array
         *
         */


        Basket.prototype.clearItem = function clearItem(item) {
            return this.items = this.items.filter(function (i) {
                return i !== item;
            });
        };

        /***
         * @ngdoc method
         * @name itemsReady
         * @methodOf BB.Models:Basket
         * @description
         * Use to check if the basket is ready to checkout
         *
         * @returns {boolean} Flag to indicate if basket is ready checkout
         */


        Basket.prototype.itemsReady = function itemsReady() {
            if (this.items.length > 0) {
                var ready = true;
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = Array.from(this.items)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var i = _step2.value;

                        if (!i.checkReady()) {
                            ready = false;
                        }
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }

                return ready;
            } else {
                return false;
            }
        };

        /***
         * @ngdoc method
         * @name readyToCheckout
         * @methodOf BB.Models:Basket
         * @description
         * Use to check if the basket is ready to checkout - and has been reviews
         *
         * @returns {boolean} Flag to indicate if basket is ready checkout
         */


        Basket.prototype.readyToCheckout = function readyToCheckout() {
            if (this.items.length > 0 && this.reviewed) {
                var ready = true;
                var _iteratorNormalCompletion3 = true;
                var _didIteratorError3 = false;
                var _iteratorError3 = undefined;

                try {
                    for (var _iterator3 = Array.from(this.items)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                        var i = _step3.value;

                        if (!i.checkReady()) {
                            ready = false;
                        }
                    }
                } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion3 && _iterator3.return) {
                            _iterator3.return();
                        }
                    } finally {
                        if (_didIteratorError3) {
                            throw _iteratorError3;
                        }
                    }
                }

                return ready;
            } else {
                return false;
            }
        };

        /***
         * @ngdoc method
         * @name timeItems
         * @methodOf BB.Models:Basket
         * @description
         * Returns an array of time items (i.e. event and appointment bookings)
         *
         * @returns {array} The available event and appointment items.
         */


        Basket.prototype.timeItems = function timeItems() {
            var titems = [];
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
                for (var _iterator4 = Array.from(this.items)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                    var i = _step4.value;

                    if (i.isTimeItem()) {
                        titems.push(i);
                    }
                }
            } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion4 && _iterator4.return) {
                        _iterator4.return();
                    }
                } finally {
                    if (_didIteratorError4) {
                        throw _iteratorError4;
                    }
                }
            }

            return titems;
        };

        /***
         * @ngdoc method
         * @name hasTimeItems
         * @methodOf BB.Models:Basket
         * @description
         * Indicates if the basket contains time items (i.e. event and appointment bookings)
         *
         * @returns {boolean} Whether the basket contains any event or appointment time items.
         */


        Basket.prototype.hasTimeItems = function hasTimeItems() {
            var _iteratorNormalCompletion5 = true;
            var _didIteratorError5 = false;
            var _iteratorError5 = undefined;

            try {
                for (var _iterator5 = Array.from(this.items)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                    var i = _step5.value;

                    if (i.isTimeItem()) {
                        return true;
                    }
                }
            } catch (err) {
                _didIteratorError5 = true;
                _iteratorError5 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion5 && _iterator5.return) {
                        _iterator5.return();
                    }
                } finally {
                    if (_didIteratorError5) {
                        throw _iteratorError5;
                    }
                }
            }

            return false;
        };

        /***
         * @ngdoc method
         * @name basketItems
         * @methodOf BB.Models:Basket
         * @description
         * Gets all BasketItem's that are not coupons
         *
         * @returns {array} array of basket items
         */


        Basket.prototype.basketItems = function basketItems() {
            var bitems = [];
            var _iteratorNormalCompletion6 = true;
            var _didIteratorError6 = false;
            var _iteratorError6 = undefined;

            try {
                for (var _iterator6 = Array.from(this.items)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                    var i = _step6.value;

                    if (!i.is_coupon) {
                        bitems.push(i);
                    }
                }
            } catch (err) {
                _didIteratorError6 = true;
                _iteratorError6 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion6 && _iterator6.return) {
                        _iterator6.return();
                    }
                } finally {
                    if (_didIteratorError6) {
                        throw _iteratorError6;
                    }
                }
            }

            return bitems;
        };

        /***
         * @ngdoc method
         * @name externalPurchaseItems
         * @methodOf BB.Models:Basket
         * @description
         * Gets all external purchases in the basket
         *
         * @returns {array} array of external purchases
         */


        Basket.prototype.externalPurchaseItems = function externalPurchaseItems() {
            var eitems = [];
            var _iteratorNormalCompletion7 = true;
            var _didIteratorError7 = false;
            var _iteratorError7 = undefined;

            try {
                for (var _iterator7 = Array.from(this.items)[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                    var i = _step7.value;

                    if (i.isExternalPurchase()) {
                        eitems.push(i);
                    }
                }
            } catch (err) {
                _didIteratorError7 = true;
                _iteratorError7 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion7 && _iterator7.return) {
                        _iterator7.return();
                    }
                } finally {
                    if (_didIteratorError7) {
                        throw _iteratorError7;
                    }
                }
            }

            return eitems;
        };

        /***
         * @ngdoc method
         * @name couponItems
         * @methodOf BB.Models:Basket
         * @description
         * Build an array of items that are coupons
         *
         * @returns {array} the newly build array of coupon items
         */


        Basket.prototype.couponItems = function couponItems() {
            var citems = [];
            var _iteratorNormalCompletion8 = true;
            var _didIteratorError8 = false;
            var _iteratorError8 = undefined;

            try {
                for (var _iterator8 = Array.from(this.items)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                    var i = _step8.value;

                    if (i.is_coupon) {
                        citems.push(i);
                    }
                }
            } catch (err) {
                _didIteratorError8 = true;
                _iteratorError8 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion8 && _iterator8.return) {
                        _iterator8.return();
                    }
                } finally {
                    if (_didIteratorError8) {
                        throw _iteratorError8;
                    }
                }
            }

            return citems;
        };

        /***
         * @ngdoc method
         * @name removeCoupons
         * @methodOf BB.Models:Basket
         * @description
         * Remove coupon items from the items array
         *
         * @returns {array} the items array after removing items that are coupons
         */


        Basket.prototype.removeCoupons = function removeCoupons() {
            return this.items = _.reject(this.items, function (x) {
                return x.is_coupon;
            });
        };

        /***
         * @ngdoc method
         * @name setSettings
         * @methodOf BB.Models:Basket
         * @description
         * Extend the settings with the set param passed to the function
         *
         * @returns {object} settings object
         */


        Basket.prototype.setSettings = function setSettings(set) {
            if (!set) {
                return;
            }
            if (!this.settings) {
                this.settings = {};
            }
            return $.extend(this.settings, set);
        };

        /***
         * @ngdoc method
         * @name setClient
         * @methodOf BB.Models:Basket
         * @description
         * Set the client
         *
         * @returns {object} client object
         */


        Basket.prototype.setClient = function setClient(client) {
            return this.client = client;
        };

        /***
         * @ngdoc method
         * @name setClientDetails
         * @methodOf BB.Models:Basket
         * @description
         * Set client details
         *
         * @returns {object} client details
         */


        Basket.prototype.setClientDetails = function setClientDetails(client_details) {
            return this.client_details = new BBModel.PurchaseItem(client_details);
        };

        /***
         * @ngdoc method
         * @name getPostData
         * @methodOf BB.Models:Basket
         * @description
         * Build an array with details for every item in items array
         *
         * @returns {array} newly created details array
         */


        Basket.prototype.getPostData = function getPostData() {
            var post = {
                client: this.client.getPostData(),
                settings: this.settings,
                reference: this.reference
            };
            post.is_admin = this.is_admin;
            post.parent_client_id = this.parent_client_id;
            post.take_from_wallet = this.take_from_wallet;
            post.items = [];
            var _iteratorNormalCompletion9 = true;
            var _didIteratorError9 = false;
            var _iteratorError9 = undefined;

            try {
                for (var _iterator9 = Array.from(this.items)[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                    var item = _step9.value;

                    post.items.push(item.getPostData());
                }
            } catch (err) {
                _didIteratorError9 = true;
                _iteratorError9 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion9 && _iterator9.return) {
                        _iterator9.return();
                    }
                } finally {
                    if (_didIteratorError9) {
                        throw _iteratorError9;
                    }
                }
            }

            return post;
        };

        /***
         * @ngdoc method
         * @name dueTotal
         * @methodOf BB.Models:Basket
         * @description
         * Total price after checking every item if it is on the wait list
         *
         * @returns {integer} total
         */
        // the amount due now - taking account of any wait list items


        Basket.prototype.dueTotal = function dueTotal() {
            var total = this.totalPrice();
            var _iteratorNormalCompletion10 = true;
            var _didIteratorError10 = false;
            var _iteratorError10 = undefined;

            try {
                for (var _iterator10 = Array.from(this.items)[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
                    var item = _step10.value;

                    if (item.isWaitlist()) {
                        total -= item.price;
                    }
                }
            } catch (err) {
                _didIteratorError10 = true;
                _iteratorError10 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion10 && _iterator10.return) {
                        _iterator10.return();
                    }
                } finally {
                    if (_didIteratorError10) {
                        throw _iteratorError10;
                    }
                }
            }

            if (total < 0) {
                total = 0;
            }
            return total;
        };

        /***
         * @ngdoc method
         * @name length
         * @methodOf BB.Models:Basket
         * @description
         * Length of the items array
         *
         * @returns {integer} length
         */


        Basket.prototype.length = function length() {
            return this.items.length;
        };

        /***
         * @ngdoc method
         * @name questionPrice
         * @methodOf BB.Models:Basket
         * @description
         * Calculates total question's price
         *
         * @returns {integer} question's price
         */


        Basket.prototype.questionPrice = function questionPrice(options) {
            var unready = options && options.unready;
            var price = 0;
            var _iteratorNormalCompletion11 = true;
            var _didIteratorError11 = false;
            var _iteratorError11 = undefined;

            try {
                for (var _iterator11 = Array.from(this.items)[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
                    var item = _step11.value;

                    if (!item.ready && unready || !unready) {
                        price += item.questionPrice();
                    }
                }
            } catch (err) {
                _didIteratorError11 = true;
                _iteratorError11 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion11 && _iterator11.return) {
                        _iterator11.return();
                    }
                } finally {
                    if (_didIteratorError11) {
                        throw _iteratorError11;
                    }
                }
            }

            return price;
        };

        /***
         * @ngdoc method
         * @name totalPrice
         * @methodOf BB.Models:Basket
         * @description
         * Calculates total price of the items after coupuns have been applied
         *
         * @returns {integer} total price
         */
        // return the total price after coupons have been applied


        Basket.prototype.totalPrice = function totalPrice(options) {
            var unready = options && options.unready;
            var price = 0;
            var _iteratorNormalCompletion12 = true;
            var _didIteratorError12 = false;
            var _iteratorError12 = undefined;

            try {
                for (var _iterator12 = Array.from(this.items)[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                    var item = _step12.value;

                    if (!item.ready && unready || !unready) {
                        price += item.totalPrice();
                    }
                }
            } catch (err) {
                _didIteratorError12 = true;
                _iteratorError12 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion12 && _iterator12.return) {
                        _iterator12.return();
                    }
                } finally {
                    if (_didIteratorError12) {
                        throw _iteratorError12;
                    }
                }
            }

            return price;
        };

        /***
         * @ngdoc method
         * @name updateTotalPrice
         * @methodOf BB.Models:Basket
         * @description
         * Update the total_price attribute using totalPrice method
         *
         * @returns {integer} the updated total_price variable
         */


        Basket.prototype.updateTotalPrice = function updateTotalPrice(options) {
            return this.total_price = this.totalPrice(options);
        };

        /***
         * @ngdoc method
         * @name fullPrice
         * @methodOf BB.Models:Basket
         * @description
         * Calculates full price of all items, before applying any coupons or deals
         *
         * @returns {integer} full price
         */
        // return the full price before any coupons or deals have been applied


        Basket.prototype.fullPrice = function fullPrice() {
            var price = 0;
            var _iteratorNormalCompletion13 = true;
            var _didIteratorError13 = false;
            var _iteratorError13 = undefined;

            try {
                for (var _iterator13 = Array.from(this.items)[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
                    var item = _step13.value;

                    price += item.fullPrice();
                }
            } catch (err) {
                _didIteratorError13 = true;
                _iteratorError13 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion13 && _iterator13.return) {
                        _iterator13.return();
                    }
                } finally {
                    if (_didIteratorError13) {
                        throw _iteratorError13;
                    }
                }
            }

            return price;
        };

        /***
         * @ngdoc method
         * @name hasCoupon
         * @methodOf BB.Models:Basket
         * @description
         * Checks if there is an item in items array, that is a coupon
         *
         * @returns {boolean} true or false if a coupon is found or not
         */


        Basket.prototype.hasCoupon = function hasCoupon() {
            var _iteratorNormalCompletion14 = true;
            var _didIteratorError14 = false;
            var _iteratorError14 = undefined;

            try {
                for (var _iterator14 = Array.from(this.items)[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
                    var item = _step14.value;

                    if (item.is_coupon) {
                        return true;
                    }
                }
            } catch (err) {
                _didIteratorError14 = true;
                _iteratorError14 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion14 && _iterator14.return) {
                        _iterator14.return();
                    }
                } finally {
                    if (_didIteratorError14) {
                        throw _iteratorError14;
                    }
                }
            }

            return false;
        };

        /***
         * @ngdoc method
         * @name totalCoupons
         * @methodOf BB.Models:Basket
         * @description
         * Calculates the full discount for the basket
         *
         * @returns {integer} full discount
         */
        // return the total coupon discount applied to the basket


        Basket.prototype.totalCoupons = function totalCoupons() {
            return this.fullPrice() - this.totalPrice() - this.totalDealPaid();
        };

        /***
         * @ngdoc method
         * @name totalDuration
         * @methodOf BB.Models:Basket
         * @description
         * Calculates total duration of all items in basket
         *
         * @returns {integer} total duration
         */


        Basket.prototype.totalDuration = function totalDuration() {
            var duration = 0;
            var _iteratorNormalCompletion15 = true;
            var _didIteratorError15 = false;
            var _iteratorError15 = undefined;

            try {
                for (var _iterator15 = Array.from(this.items)[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
                    var item = _step15.value;

                    if (item.service && item.service.listed_duration) {
                        duration += item.service.listed_duration;
                    }
                }
            } catch (err) {
                _didIteratorError15 = true;
                _iteratorError15 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion15 && _iterator15.return) {
                        _iterator15.return();
                    }
                } finally {
                    if (_didIteratorError15) {
                        throw _iteratorError15;
                    }
                }
            }

            return duration;
        };

        /***
         * @ngdoc method
         * @name containsDeal
         * @methodOf BB.Models:Basket
         * @description
         * Checks if there is an item in items array, that is a deal
         *
         * @returns {boolean} true or false depending if a deal was found or not
         */


        Basket.prototype.containsDeal = function containsDeal() {
            var _iteratorNormalCompletion16 = true;
            var _didIteratorError16 = false;
            var _iteratorError16 = undefined;

            try {
                for (var _iterator16 = Array.from(this.items)[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
                    var item = _step16.value;

                    if (item.deal_id) {
                        return true;
                    }
                }
            } catch (err) {
                _didIteratorError16 = true;
                _iteratorError16 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion16 && _iterator16.return) {
                        _iterator16.return();
                    }
                } finally {
                    if (_didIteratorError16) {
                        throw _iteratorError16;
                    }
                }
            }

            return false;
        };

        /***
         * @ngdoc method
         * @name hasDeal
         * @methodOf BB.Models:Basket
         * @description
         * Checks if there is any item in items array with a deal code
         *
         * @returns {boolean} true or false depending if a deal code was found or not
         */


        Basket.prototype.hasDeal = function hasDeal() {
            var _iteratorNormalCompletion17 = true;
            var _didIteratorError17 = false;
            var _iteratorError17 = undefined;

            try {
                for (var _iterator17 = Array.from(this.items)[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
                    var item = _step17.value;

                    if (item.deal_codes && item.deal_codes.length > 0) {
                        return true;
                    }
                }
            } catch (err) {
                _didIteratorError17 = true;
                _iteratorError17 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion17 && _iterator17.return) {
                        _iterator17.return();
                    }
                } finally {
                    if (_didIteratorError17) {
                        throw _iteratorError17;
                    }
                }
            }

            return false;
        };

        /***
         * @ngdoc method
         * @name getDealCodes
         * @methodOf BB.Models:Basket
         * @description
         * Builds an array of deal codes
         *
         * @returns {array} deal codes array
         */


        Basket.prototype.getDealCodes = function getDealCodes() {
            this.deals = this.items[0] && this.items[0].deal_codes ? this.items[0].deal_codes : [];
            return this.deals;
        };

        /***
         * @ngdoc method
         * @name totalDeals
         * @methodOf BB.Models:Basket
         * @description
         * Calculates the total amount of deal codes array
         *
         * @returns {integer} total amount of deals
         */
        // return the total value of deals (gift certificates) applied to the basket


        Basket.prototype.totalDeals = function totalDeals() {
            var value = 0;
            var _iteratorNormalCompletion18 = true;
            var _didIteratorError18 = false;
            var _iteratorError18 = undefined;

            try {
                for (var _iterator18 = Array.from(this.getDealCodes())[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
                    var deal = _step18.value;

                    value += deal.value;
                }
            } catch (err) {
                _didIteratorError18 = true;
                _iteratorError18 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion18 && _iterator18.return) {
                        _iterator18.return();
                    }
                } finally {
                    if (_didIteratorError18) {
                        throw _iteratorError18;
                    }
                }
            }

            return value;
        };

        /***
         * @ngdoc method
         * @name totalDealPaid
         * @methodOf BB.Models:Basket
         * @description
         * Calculates the amount paid by gift certificates
         *
         * @returns {integer} amount paid by deals
         */
        // return amount paid by deals (gift certficates)


        Basket.prototype.totalDealPaid = function totalDealPaid() {
            var total_cert_paid = 0;
            var _iteratorNormalCompletion19 = true;
            var _didIteratorError19 = false;
            var _iteratorError19 = undefined;

            try {
                for (var _iterator19 = Array.from(this.items)[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
                    var item = _step19.value;

                    if (item.certificate_paid) {
                        total_cert_paid += item.certificate_paid;
                    }
                }
            } catch (err) {
                _didIteratorError19 = true;
                _iteratorError19 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion19 && _iterator19.return) {
                        _iterator19.return();
                    }
                } finally {
                    if (_didIteratorError19) {
                        throw _iteratorError19;
                    }
                }
            }

            return total_cert_paid;
        };

        /***
         * @ngdoc method
         * @name remainingDealBalance
         * @methodOf BB.Models:Basket
         * @description
         * Calculates the difference between total deals amount and amount paid by deals
         *
         * @returns {integer} The remaining deal (gift certificate) balance
         */
        // return the remaining deal (gift certificate) balance


        Basket.prototype.remainingDealBalance = function remainingDealBalance() {
            return this.totalDeals() - this.totalDealPaid();
        };

        /***
         * @ngdoc method
         * @name hasWaitlistItem
         * @methodOf BB.Models:Basket
         * @description
         * Checks if the basket contains an wait list event
         *
         * @returns {boolean} true or false
         */


        Basket.prototype.hasWaitlistItem = function hasWaitlistItem() {
            var _iteratorNormalCompletion20 = true;
            var _didIteratorError20 = false;
            var _iteratorError20 = undefined;

            try {
                for (var _iterator20 = Array.from(this.items)[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
                    var item = _step20.value;

                    if (item.isWaitlist()) {
                        return true;
                    }
                }
            } catch (err) {
                _didIteratorError20 = true;
                _iteratorError20 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion20 && _iterator20.return) {
                        _iterator20.return();
                    }
                } finally {
                    if (_didIteratorError20) {
                        throw _iteratorError20;
                    }
                }
            }

            return false;
        };

        /***
         * @ngdoc method
         * @name hasExternalPurchase
         * @methodOf BB.Models:Basket
         * @description
         * Checks if the basket contains an external purchase
         *
         * @returns {boolean} true or false
         */


        Basket.prototype.hasExternalPurchase = function hasExternalPurchase() {
            var _iteratorNormalCompletion21 = true;
            var _didIteratorError21 = false;
            var _iteratorError21 = undefined;

            try {
                for (var _iterator21 = Array.from(this.items)[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
                    var item = _step21.value;

                    if (item.isExternalPurchase()) {
                        return true;
                    }
                }
            } catch (err) {
                _didIteratorError21 = true;
                _iteratorError21 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion21 && _iterator21.return) {
                        _iterator21.return();
                    }
                } finally {
                    if (_didIteratorError21) {
                        throw _iteratorError21;
                    }
                }
            }

            return false;
        };

        /***
         * @ngdoc method
         * @name useWallet
         * @methodOf BB.Models:Basket
         * @description
         * Indicates if a wallet should be used for payment
         *
         * @returns {boolean} true or false
         */


        Basket.prototype.useWallet = function useWallet(value, client) {
            if (client && client.$has('wallet') && value) {
                this.take_from_wallet = true;
                return true;
            } else {
                this.take_from_wallet = false;
                return false;
            }
        };

        Basket.$applyCoupon = function $applyCoupon(company, params) {
            return BasketService.applyCoupon(company, params);
        };

        Basket.$updateBasket = function $updateBasket(company, params) {
            return BasketService.updateBasket(company, params);
        };

        Basket.$deleteItem = function $deleteItem(item, company, params) {
            return BasketService.deleteItem(item, company, params);
        };

        Basket.$checkout = function $checkout(company, basket, params) {
            return BasketService.checkout(company, basket, params);
        };

        Basket.$empty = function $empty(bb) {
            return BasketService.empty(bb);
        };

        Basket.$applyDeal = function $applyDeal(company, params) {
            return BasketService.applyDeal(company, params);
        };

        Basket.$removeDeal = function $removeDeal(company, params) {
            return BasketService.removeDeal(company, params);
        };

        /***
         * @ngdoc method
         * @name voucherRemainder
         * @methodOf BB.Models:Basket
         * @description
         * Remaining voucher value if used
         *
         * @returns {integer} remaining voucher value
         */


        Basket.prototype.voucherRemainder = function voucherRemainder() {
            var amount = 0;
            var _iteratorNormalCompletion22 = true;
            var _didIteratorError22 = false;
            var _iteratorError22 = undefined;

            try {
                for (var _iterator22 = Array.from(this.items)[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
                    var item = _step22.value;

                    if (item.voucher_remainder) {
                        amount += item.voucher_remainder;
                    }
                }
            } catch (err) {
                _didIteratorError22 = true;
                _iteratorError22 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion22 && _iterator22.return) {
                        _iterator22.return();
                    }
                } finally {
                    if (_didIteratorError22) {
                        throw _iteratorError22;
                    }
                }
            }

            return amount;
        };

        return Basket;
    }(BaseModel);
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:BasketItem
 *
 * @description
 * Representation of an BasketItem Object
 *
 * @property {integer} company_id Company id that the basket item belongs to
 * @property {integer} total_price Total price of the basket item
 * @property {integer} total_due_price Total price of the basket item after applying discounts
 * @property {array} items Arrays of items that are in the basket
 * @property {integer} event_id The event id of the basket item
 * @property {date} datetime Date and time of the event
 * @property {integer} status Status of the items
 *
 */

angular.module('BB.Models').factory("BasketItemModel", function ($q, $window, BBModel, BookableItemModel, BaseModel, $bbug, DateTimeUtilitiesService, $translate, bbTimeZone) {
    return (

        // A class that defines an item in a shopping basket
        // This could represent a time based service, a ticket for an event or class, or any other purchasable item

        function (_BaseModel) {
            _inherits(BasketItem, _BaseModel);

            function BasketItem(data, bb) {
                _classCallCheck(this, BasketItem);

                var _this = _possibleConstructorReturn(this, _BaseModel.call(this, data));

                _this.ready = false;
                _this.days_link = null;
                _this.book_link = null;
                _this.parts_links = {};
                if (!_this.settings) {
                    _this.settings = {};
                }
                _this.has_questions = false;

                // give the basket item a unique reference so that we can track it
                if (!_this.ref) {
                    _this.ref = Math.ceil(moment().unix() * Math.random());
                }

                if (_this.date) {
                    _this.date = new BBModel.Day({ date: _this.date, spaces: 1 });
                }

                // if we were given an id then the item is ready - we need to fake a few items
                if (_.isNumber(_this.time)) {
                    _this.time = new BBModel.TimeSlot({
                        time: _this.time,
                        date: _this.date ? _this.date.date : null,
                        event_id: _this.event_id,
                        selected: true,
                        avail: 1,
                        price: _this.price
                    });
                }

                if (_this.datetime) {
                    _this.date = new BBModel.Day({ date: _this.datetime.toISODate(), spaces: 1 });

                    var t = _this.datetime.hour() * 60 + _this.datetime.minute();
                    _this.time = new BBModel.TimeSlot({
                        time: t,
                        date: _this.date ? _this.date.date : null,
                        event_id: _this.event_id,
                        selected: true,
                        avail: 1,
                        price: _this.price
                    });
                }

                if (_this.id) {
                    _this.reserve_ready = true; // if it has an id - it must be held - so therefore it must already be 'reservable'
                    // keep a note of a possibly held item - we might change this item - but we should know waht was possibly already selected
                    _this.held = { time: _this.time, date: _this.date, event_id: _this.event_id, id: _this.id };
                }

                _this.promises = [];

                if (data) {

                    var prom = void 0,
                        serv = void 0;
                    if (data.$has("answers")) {
                        data.$get("answers").then(function (answers) {
                            data.questions = [];
                            return Array.from(answers).map(function (a) {
                                return data.questions.push({ id: a.question_id, answer: a.value });
                            });
                        });
                    }

                    if (data.$has('company')) {
                        var comp = data.$get('company');
                        _this.promises.push(comp);
                        comp.then(function (comp) {
                            var c = new BBModel.Company(comp);
                            _this.promises.push(c.getSettings());
                            return _this.setCompany(c);
                        });
                    }

                    if (data.$has('service')) {
                        serv = data.$get('service');
                        _this.promises.push(serv);
                        serv.then(function (serv) {
                            if (serv.$has('category')) {
                                prom = serv.$get('category');
                                _this.promises.push(prom);
                                prom.then(function (cat) {
                                    return _this.setCategory(new BBModel.Category(cat));
                                });
                            }
                            _this.setService(new BBModel.Service(serv), data.questions);
                            if (_this.duration) {
                                _this.setDuration(_this.duration);
                            }
                            _this.checkReady();
                            if (_this.time) {
                                return _this.time.service = _this.service;
                            }
                        }); // the time slot sometimes wants to know thing about the service
                    }

                    if (data.$has('event_group')) {
                        serv = data.$get('event_group');
                        _this.promises.push(serv);
                        serv.then(function (serv) {
                            if (serv.$has('category')) {
                                prom = serv.$get('category');
                                _this.promises.push(prom);
                                prom.then(function (cat) {
                                    return _this.setCategory(new BBModel.Category(cat));
                                });
                            }

                            _this.setEventGroup(new BBModel.EventGroup(serv));
                            if (_this.time) {
                                return _this.time.service = _this.event_group;
                            }
                        }); // the time slot sometimes wants to know thing about the service
                    }

                    if (data.$has('event_chain')) {
                        var chain = data.$get('event_chain');
                        _this.promises.push(chain);
                        if (!data.$has('event')) {
                            // onlt set the event chain if we don't have the full event details - which will also set the event chain
                            chain.then(function (serv) {
                                return _this.setEventChain(new BBModel.EventChain(serv), data.questions);
                            });
                        }
                    }

                    if (data.$has('resource')) {
                        var res = data.$get('resource');
                        _this.promises.push(res);
                        res.then(function (res) {
                            return _this.setResource(new BBModel.Resource(res), false);
                        });
                    }
                    if (data.$has('person')) {
                        var per = data.$get('person');
                        _this.promises.push(per);
                        per.then(function (per) {
                            return _this.setPerson(new BBModel.Person(per), false);
                        });
                    }
                    if (data.$has('event')) {
                        data.$get('event').then(function (event) {
                            return _this.setEvent(new BBModel.Event(event));
                        });
                    }

                    if (data.settings) {
                        _this.settings = $bbug.extend(true, {}, data.settings);
                    }

                    if (data.attachment_id) {
                        _this.attachment_id = data.attachment_id;
                    }

                    if (data.person_group_id) {
                        _this.setPersonGroupId(data.person_group_id);
                    }

                    if (data.$has('product')) {
                        data.$get('product').then(function (product) {
                            return _this.setProduct(new BBModel.Product(product));
                        });
                    }

                    if (data.$has('package_item')) {
                        data.$get('package_item').then(function (package_item) {
                            return _this.setPackageItem(new BBModel.PackageItem(package_item));
                        });
                    }

                    if (data.$has('bulk_purchase')) {
                        data.$get('bulk_purchase').then(function (bulk_purchase) {
                            return _this.setBulkPurchase(new BBModel.BulkPurchase(bulk_purchase));
                        });
                    }

                    if (data.$has('deal')) {
                        data.$get('deal').then(function (deal) {
                            return _this.setDeal(new BBModel.Deal(deal));
                        });
                    }

                    if (data.$has('pre_paid_booking')) {
                        data.$get('pre_paid_booking').then(function (pre_paid_booking) {
                            return _this.setPrepaidBooking(new BBModel.PrePaidBooking(pre_paid_booking));
                        });
                    }

                    if (data.clinic_id) {
                        _this.clinic_id = data.clinic_id;
                    }
                }
                return _this;
            }

            /***
             * @ngdoc method
             * @name setDefaults
             * @methodOf BB.Models:BasketItem
             * @description
             * Set the default settings
             *
             * @returns {object} Default settings
             */


            BasketItem.prototype.setDefaults = function setDefaults(defaults) {
                if (defaults.settings) {
                    this.settings = defaults.settings;
                }
                if (defaults.company) {
                    this.setCompany(defaults.company);
                }
                if (defaults.merge_resources) {
                    this.setResource(null);
                }
                if (defaults.merge_people) {
                    this.setPerson(null);
                }
                if (defaults.resource) {
                    this.setResource(defaults.resource);
                }
                if (defaults.person) {
                    this.setPerson(defaults.person);
                }
                if (defaults.service) {
                    this.setService(defaults.service);
                }
                if (defaults.category) {
                    this.setCategory(defaults.category);
                }
                if (defaults.date) {
                    // NOTE: date is not set as it might not be available
                    defaults.date = moment(defaults.date);
                }
                if (defaults.time) {
                    // NOTE: time is not set as it might not be available
                    var time = defaults.time ? parseInt(defaults.time) : 0;
                    defaults.datetime = DateTimeUtilitiesService.convertTimeToMoment(defaults.date, time);
                }
                if (defaults.service_ref) {
                    this.service_ref = defaults.service_ref;
                }
                if (defaults.group) {
                    this.group = defaults.group;
                }
                if (defaults.clinic) {
                    this.clinic = defaults.clinic;
                    this.clinic_id = defaults.clinic.id;
                }
                if (defaults.private_note) {
                    this.private_note = defaults.private_note;
                }
                if (defaults.event_group) {
                    this.setEventGroup(defaults.event_group);
                }
                if (defaults.event) {
                    this.setEvent(defaults.event);
                }
                return this.defaults = defaults;
            };

            /***
             * @ngdoc method
             * @name storeDefaults
             * @methodOf BB.Models:BasketItem
             * @description
             * Store the default settings by attaching them to the current context
             *
             * @returns {array} defaults variable
             */


            BasketItem.prototype.storeDefaults = function storeDefaults(defaults) {
                return this.defaults = defaults;
            };

            /***
             * @ngdoc method
             * @name canLoadItem
             * @methodOf BB.Models:BasketItem
             * @description
             * See if this item is read to have a specific object type loads - i.e. services, resources, or people
             * @param {object} company a hash representing a company object
             *
             * @returns {boolean} if this item can be loaded
             */


            BasketItem.prototype.canLoadItem = function canLoadItem(item) {
                if (this.service && this.item !== 'service') {
                    return true; // we have a service and we want something else
                } else if (this.resource && !this.anyResource() && item !== 'resource') {
                    return true; // we have a resource and we want something else
                } else if (this.person && !this.anyPerson() && item !== 'person') {
                    return true; // we have a person and we want something else
                } else {
                    return false;
                }
            };

            /***
             * @ngdoc method
             * @name defaultService
             * @methodOf BB.Models:BasketItem
             * @description
             * Return the default service or event group
             *
             * @returns {Object} Default Service or EventGroup
             */


            BasketItem.prototype.defaultService = function defaultService() {
                if (this.defaults && this.defaults.service) {
                    return this.defaults.service;
                } else if (this.defaults && this.defaults.event_group) {
                    return this.defaults.event_group;
                } else {
                    return null;
                }
            };

            /***
             * @ngdoc method
             * @name setSlot
             * @methodOf BB.Models:BasketItem
             * @description
             * Set the current slot based on the passed parameter
             *
             * @param {object} slot A hash representing a slot object
             * @returns {array} The available slot
             */


            BasketItem.prototype.setSlot = function setSlot(slot) {

                this.date = new BBModel.Day({ date: slot.datetime.toISODate(), spaces: 1 });
                var t = slot.datetime.hour() * 60 + slot.datetime.minute();
                this.time = new BBModel.TimeSlot({ time: t, avail: 1, price: this.price });
                return this.available_slot = slot.id;
            };

            /***
             * @ngdoc method
             * @name setCompany
             * @methodOf BB.Models:BasketItem
             * @description
             * Set the current company based on the passed parameter
             * @param {object} company a hash representing a company object
             */


            BasketItem.prototype.setCompany = function setCompany(company) {
                this.company = company;
                this.parts_links.company = this.company.$href('self');
                if (this.item_details) {
                    return this.item_details.currency_code = this.company.currency_code;
                }
            };

            /***
             * @ngdoc method
             * @name clearExistingItem
             * @methodOf BB.Models:BasketItem
             * @description
             * Clear existing item
             */


            BasketItem.prototype.clearExistingItem = function clearExistingItem() {
                if (this.$has('self') && this.event_id) {
                    var prom = this.$del('self');
                    this.promises.push(prom);
                    prom.then(function () {});
                }

                delete this.earliest_time;
                return delete this.event_id; // when changing the service - we ahve to clear any pre-set event
            };

            /***
             * @ngdoc method
             * @name setItem
             * @methodOf BB.Models:BasketItem
             * @description
             * Set the current item based on the item object passed as parameter
             */


            BasketItem.prototype.setItem = function setItem(item) {
                if (!item) {
                    return;
                }
                if (item.type === "person") {
                    return this.setPerson(item);
                } else if (item.type === "service") {
                    return this.setService(item);
                } else if (item.type === "resource") {
                    return this.setResource(item);
                }
            };

            /***
             * @ngdoc method
             * @name setService
             * @methodOf BB.Models:BasketItem
             * @description
             * Set service in according of server parameter, if default_question is null
             *
             * @returns {array} The returned service set
             */


            BasketItem.prototype.setService = function setService(serv, default_questions) {
                var _this2 = this;

                // if there was previously a service - reset the item details - i.e. the asnwers to questions
                var prom = void 0;
                if (default_questions == null) {
                    default_questions = null;
                }
                if (this.service) {
                    if (this.service.self && serv.self && this.service.self === serv.self) {
                        // return if it's the same service
                        // make sure we reset the fact that we are using this service
                        if (this.service.$has('book')) {
                            this.book_link = this.service;
                        }
                        if (serv.$has('days')) {
                            this.days_link = serv;
                        }
                        if (serv.$has('book')) {
                            this.book_link = serv;
                        }
                        return;
                    }
                    // if it's a different service
                    this.item_details = null;
                    this.clearExistingItem();
                }

                if (this.service && serv && this.service.self && serv.self) {
                    if (this.service.self !== serv.self && serv.durations && serv.durations.length > 1) {
                        this.duration = null;
                        this.listed_duration = null;
                    }
                }

                this.service = serv;
                if (serv && serv instanceof BookableItemModel) {
                    this.service = serv.item;
                }

                this.parts_links.service = this.service.$href('self');
                if (this.service.$has('book')) {
                    this.book_link = this.service;
                }
                if (serv.$has('days')) {
                    this.days_link = serv;
                }
                if (serv.$has('book')) {
                    this.book_link = serv;
                }

                if (this.service.$has('questions')) {
                    this.has_questions = true;

                    // we have a questions link - but are there actaully any questions ?
                    prom = this.service.$get('questions');
                    this.promises.push(prom);
                    prom.then(function (details) {
                        if (_this2.company) {
                            details.currency_code = _this2.company.currency_code;
                        }
                        _this2.item_details = new BBModel.ItemDetails(details);
                        _this2.has_questions = _this2.item_details.hasQuestions;
                        if (default_questions) {
                            _this2.item_details.setAnswers(default_questions);
                            return _this2.setAskedQuestions();
                        }
                    } // make sure the item knows the questions were all answered
                    , function (err) {
                        return _this2.has_questions = false;
                    });
                } else {
                    this.has_questions = false;
                }

                // select the first and only duration if this service only has one option

                if (this.service && this.service.durations && this.service.durations.length === 1) {
                    this.setDuration(this.service.durations[0]);
                    this.listed_duration = this.service.durations[0];
                }
                // check if the service has a listed duration (this is used for calculating the end time for display)
                if (this.service && this.service.listed_durations && this.service.listed_durations.length === 1) {
                    this.listed_duration = this.service.listed_durations[0];
                }

                if (this.service.$has('category')) {
                    // we have a category?
                    prom = this.service.$getCategory();
                    if (prom) {
                        return this.promises.push(prom);
                    }
                }
            };

            /***
             * @ngdoc method
             * @name setEventGroup
             * @methodOf BB.Models:BasketItem
             * @description
             * Set event group based on the event_group param
             *
             * @param {object} event_group a hash
             */


            BasketItem.prototype.setEventGroup = function setEventGroup(event_group) {
                if (this.event_group) {
                    if (this.event_group.self && event_group.self && this.event_group.self === event_group.self) {
                        // return if it's the same event_chain
                        return;
                    }
                }

                this.event_group = event_group;
                this.parts_links.event_group = this.event_group.$href('self').replace('event_group', 'service');

                if (this.event_group.$has('category')) {
                    // we have a category?
                    var prom = this.event_group.$getCategory();
                    if (prom) {
                        return this.promises.push(prom);
                    }
                }
            };

            /***
             * @ngdoc method
             * @name setEventChain
             * @methodOf BB.Models:BasketItem
             * @description
             * Set event chain in according of event_chain parameter, default_qustions is null
             *
             * @returns {array} The returned set event chaint
             */


            BasketItem.prototype.setEventChain = function setEventChain(event_chain, default_questions) {
                var _this3 = this;

                if (default_questions == null) {
                    default_questions = null;
                }
                if (this.event_chain) {

                    if (this.event_chain.self && event_chain.self && this.event_chain.self === event_chain.self) {
                        // return if it's the same event_chain
                        return;
                    }
                }

                this.event_chain = event_chain;
                this.base_price = parseFloat(event_chain.price);

                if (this.price != null && this.price !== this.base_price) {
                    this.setPrice(this.price);
                } else {
                    this.setPrice(this.base_price);
                }

                if (this.event_chain.isSingleBooking()) {
                    // i.e. does not have tickets sets and max bookings is 1

                    // if you can only book one ticket - just use that
                    this.tickets = {
                        name: $translate.instant('COMMON.TERMINOLOGY.ADMITTANCE'),
                        max: 1,
                        type: "normal",
                        price: this.base_price
                    };

                    this.tickets.pre_paid_booking_id = this.pre_paid_booking_id;
                    if (this.num_book) {
                        this.tickets.qty = this.num_book;
                    }
                }

                if (this.event_chain.$has('questions')) {

                    this.has_questions = true;

                    // we have a questions link - but are there actaully any questions ?
                    var prom = this.event_chain.$get('questions');
                    this.promises.push(prom);
                    return prom.then(function (details) {
                        _this3.item_details = new BBModel.ItemDetails(details);
                        _this3.has_questions = _this3.item_details.hasQuestions;
                        if (_this3.questions) {
                            var _iteratorNormalCompletion = true;
                            var _didIteratorError = false;
                            var _iteratorError = undefined;

                            try {
                                for (var _iterator = Array.from(_this3.item_details.questions)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                    var q = _step.value;

                                    var a = _.find(_this3.questions, function (c) {
                                        return c.id === q.id;
                                    });
                                    if (a && q.answer === undefined || a !== q.answer) {
                                        q.answer = a.answer;
                                    }
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return) {
                                        _iterator.return();
                                    }
                                } finally {
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }

                            _this3.setAskedQuestions();
                        }
                        if (default_questions) {
                            _this3.item_details.setAnswers(default_questions);
                            return _this3.setAskedQuestions();
                        }
                    } // make sure the item knows the questions were all answered
                    , function (err) {
                        return _this3.has_questions = false;
                    });
                } else {
                    return this.has_questions = false;
                }
            };

            /***
             * @ngdoc method
             * @name setEvent
             * @methodOf BB.Models:BasketItem
             * @description
             * Set event according to event parameter
             *
             * @param {object} event A hash representing an event object
             */


            BasketItem.prototype.setEvent = function setEvent(event, default_questions) {
                var _this4 = this;

                if (default_questions == null) {
                    default_questions = null;
                }
                if (this.event) {
                    this.event.unselect();
                }
                this.event = event;
                this.event.select();
                this.event_chain_id = event.event_chain_id;
                this.setDate({ date: event.date });
                this.setTime(event.time);
                this.setDuration(event.duration);
                if (event.$has('book')) {
                    this.book_link = event;
                }
                if (event.qty) {
                    this.num_book = event.qty;
                }
                var prom = this.event.getChain();
                this.promises.push(prom);
                prom.then(function (chain) {
                    return _this4.setEventChain(chain, default_questions);
                });
                prom = this.event.getGroup();
                this.promises.push(prom);
                prom.then(function (group) {
                    return _this4.setEventGroup(group);
                });
                if (this.event.getSpacesLeft() <= 0 && !this.company.settings) {
                    if (this.company.getSettings().has_waitlists) {
                        return this.status = 8;
                    }
                } else if (this.event.getSpacesLeft() <= 0 && this.company.settings && this.company.settings.has_waitlists) {
                    return this.status = 8;
                }
            };

            /***
             * @ngdoc method
             * @name setCategory
             * @methodOf BB.Models:BasketItem
             * @description
             * Set category according to cat parameter
             *
             * @param {object} cat A hash representing a category object
             */
            // if someone sets a category - we may then later restrict the service list by category


            BasketItem.prototype.setCategory = function setCategory(cat) {
                return this.category = cat;
            };

            /***
             * @ngdoc method
             * @name setPerson
             * @methodOf BB.Models:BasketItem
             * @description
             * Set person according to per parameter
             *
             * @param {object} per A hash representing a person object
              * @param {boolean} set_selected The returned set resource for basket item
             */


            BasketItem.prototype.setPerson = function setPerson(per, set_selected) {
                if (set_selected == null) {
                    set_selected = true;
                }
                if (set_selected && this.earliest_time) {
                    delete this.earliest_time;
                }

                if (!per) {
                    this.person = true;
                    if (set_selected) {
                        this.settings.person = -1;
                    }
                    this.parts_links.person = null;
                    if (this.service) {
                        this.setService(this.service);
                    }
                    if (this.resource && !this.anyResource()) {
                        this.setResource(this.resource, false);
                    }
                    if (this.event_id) {
                        delete this.event_id; // when changing the person - we ahve to clear any pre-set event
                        if (this.resource && this.defaults && this.defaults.merge_resources) {
                            return this.setResource(null);
                        } // if a resources has been automatically set - clear it
                    }
                } else {
                    this.person = per;
                    if (set_selected) {
                        this.settings.person = this.person.id;
                    }
                    this.parts_links.person = this.person.$href('self');
                    if (per.$has('days')) {
                        this.days_link = per;
                    }
                    if (per.$has('book')) {
                        this.book_link = per;
                    }
                    if (this.event_id && this.$has('person') && this.$href('person') !== this.person.self) {
                        delete this.event_id; // when changing the person - we ahve to clear any pre-set event
                        if (this.resource && this.defaults && this.defaults.merge_resources) {
                            return this.setResource(null);
                        } // if a resources has been automatically set - clear it
                    }
                }
            };

            /***
             * @ngdoc method
             * @name setStaffGroup
             * @methodOf BB.Models:BasketItem
             * @description Set the current staff group id
             */


            BasketItem.prototype.setPersonGroupId = function setPersonGroupId(id) {
                return this.person_group_id = id;
            };

            /***
             * @ngdoc method
             * @name setResource
             * @methodOf BB.Models:BasketItem
             * @description
             * Set resource in according of res parameter, if set_selected is true
             *
             * @returns {object} The returned set resource for basket item
             */


            BasketItem.prototype.setResource = function setResource(res, set_selected) {
                if (set_selected == null) {
                    set_selected = true;
                }
                if (set_selected && this.earliest_time) {
                    delete this.earliest_time;
                }

                if (!res) {
                    this.resource = true;
                    if (set_selected) {
                        this.settings.resource = -1;
                    }
                    this.parts_links.resource = null;
                    if (this.service) {
                        this.setService(this.service);
                    }
                    if (this.person && !this.anyPerson()) {
                        this.setPerson(this.person, false);
                    }
                    if (this.event_id) {
                        delete this.event_id; // when changing the resource - we ahve to clear any pre-set event
                        if (this.person && this.defaults && this.defaults.merge_people) {
                            return this.setPerson(null);
                        } // if a person has been automatically set - clear it
                    }
                } else {
                    this.resource = res;
                    if (set_selected) {
                        this.settings.resource = this.resource.id;
                    }
                    this.parts_links.resource = this.resource.$href('self');
                    if (res.$has('days')) {
                        this.days_link = res;
                    }
                    if (res.$has('book')) {
                        this.book_link = res;
                    }
                    if (this.event_id && this.$has('resource') && this.$href('resource') !== this.resource.self) {
                        delete this.event_id; // when changing the resource - we ahve to clear any pre-set event
                        if (this.person && this.defaults && this.defaults.merge_people) {
                            return this.setPerson(null);
                        } // if a person has been automatically set - clear it
                    }
                }
            };

            /***
             * @ngdoc method
             * @name setDuration
             * @methodOf BB.Models:BasketItem
             * @description
             * Set duration in according of dur parameter
             *
             * @returns {integer} The returned set duration for basket item
             */


            BasketItem.prototype.setDuration = function setDuration(dur) {
                this.duration = dur;
                if (this.service) {
                    this.base_price = this.service.getPriceByDuration(dur);
                } else if (this.time && this.time.price) {
                    this.base_price = this.time.price;
                } else if (this.price) {
                    this.base_price = this.price;
                }

                return this.setPrice(this.base_price);
            };

            /***
             * @ngdoc method
             * @name print_time
             * @methodOf BB.Models:BasketItem
             * @description
             * Get to print time
             *
             * @returns {date} The returned print time
             */


            BasketItem.prototype.print_time = function print_time() {
                if (this.time) {
                    return this.time.print_time();
                }
            };

            /***
             * @ngdoc method
             * @name print_end_time
             * @methodOf BB.Models:BasketItem
             * @description
             * Get to print end time
             *
             * @returns {date} The returned print end time
             */


            BasketItem.prototype.print_end_time = function print_end_time() {
                if (this.time) {
                    return this.time.print_end_time(this.duration);
                }
            };

            /***
             * @ngdoc method
             * @name print_time12
             * @methodOf BB.Models:BasketItem
             * @description
             * Get to print time12 if show suffix is true
             *
             * @returns {date} The returned print time12
             */


            BasketItem.prototype.print_time12 = function print_time12(show_suffix) {
                if (show_suffix == null) {
                    show_suffix = true;
                }
                if (this.time) {
                    return this.time.print_time12(show_suffix);
                }
            };

            /***
             * @ngdoc method
             * @name print_end_time12
             * @methodOf BB.Models:BasketItem
             * @description
             * Get to print end time12 if show_suffix is true
             *
             * @returns {date} The returned print end time12
             */


            BasketItem.prototype.print_end_time12 = function print_end_time12(show_suffix) {
                if (show_suffix == null) {
                    show_suffix = true;
                }
                if (this.time) {
                    return this.time.print_end_time12(show_suffix, this.duration);
                }
            };

            /***
             * @ngdoc method
             * @name setTime
             * @methodOf BB.Models:BasketItem
             * @description
             * Set time in according of time parameter
             *
             * @returns {date} The returned set time
             */


            BasketItem.prototype.setTime = function setTime(time) {
                if (this.time) {
                    this.time.unselect();
                }
                this.time = time;
                if (this.time) {
                    this.time.select();

                    if (this.datetime) {
                        this.datetime = DateTimeUtilitiesService.convertTimeToMoment(this.date.date, this.time.time);
                    }

                    if (this.price && this.time.price && this.price !== this.time.price) {
                        this.setPrice(this.time.price);
                    } else if (this.price && !this.time.price) {
                        this.setPrice(this.price);
                    } else if (this.time.price && !this.price) {
                        this.setPrice(this.time.price);
                    } else if (this.price && this.time.price) {
                        this.setPrice(this.price);
                    } else {
                        this.setPrice(null);
                    }
                }

                return this.checkReady();
            };

            /***
             * @ngdoc method
             * @name setDate
             * @methodOf BB.Models:BasketItem
             * @description
             * Set date in according of date parameter
             *
             * @returns {date} The returned set date
             */


            BasketItem.prototype.setDate = function setDate(date) {
                this.date = date;
                if (this.date) {
                    this.date.date = bbTimeZone.convertToCompany(moment(this.date.date));
                    if (this.datetime) {
                        this.datetime.date(this.date.date.date());
                        this.datetime.month(this.date.date.month());
                        this.datetime.year(this.date.date.year());
                    }
                }

                return this.checkReady();
            };

            /***
             * @ngdoc method
             * @name clearDateTime
             * @methodOf BB.Models:BasketItem
             * @description
             * Clear date and time
             *
             * @returns {date} The returned clear date and time
             */


            BasketItem.prototype.clearDateTime = function clearDateTime() {
                delete this.date;
                delete this.time;
                delete this.datetime;
                this.ready = false;
                return this.reserve_ready = false;
            };

            /***
             * @ngdoc method
             * @name clearTime
             * @methodOf BB.Models:BasketItem
             * @description
             * Clear time
             *
             * @returns {date} The returned clear time
             */


            BasketItem.prototype.clearTime = function clearTime() {
                delete this.time;
                this.ready = false;
                return this.reserve_ready = false;
            };

            /***
             * @ngdoc method
             * @name clearTime
             * @methodOf BB.Models:BasketItem
             * @description
             * Set group in according of group parameter
             *
             * @returns {object} The returned set group
             */


            BasketItem.prototype.setGroup = function setGroup(group) {
                return this.group = group;
            };

            /***
             * @ngdoc method
             * @name setAskedQuestions
             * @methodOf BB.Models:BasketItem
             * @description
             * Set asked questions
             *
             * @returns {object} The returned set asked questions
             */


            BasketItem.prototype.setAskedQuestions = function setAskedQuestions() {
                this.asked_questions = true;
                return this.checkReady();
            };

            /***
             * @ngdoc method
             * @name checkReady
             * @methodOf BB.Models:BasketItem
             * @description
             * Check if an item is fully ready for checkout
             * @ready - means it's fully ready for checkout
             * @reserve_ready - means the question still need asking - but it can be reserved
             *
             * @returns {boolean} whether it's fully ready for checkout
             */


            BasketItem.prototype.checkReady = function checkReady() {
                this.ready = false;

                if (this.checkReserveReady() && (this.asked_questions || !this.has_questions)) {
                    this.ready = true;
                }

                return this.ready;
            };

            /***
             * @ngdoc method
             * @name checkReserveReady
             * @methodOf BB.Models:BasketItem
             * @description
             * Check if an item can be reserved
             *
             * @returns {boolean} whether it's ready to be reserved
             */


            BasketItem.prototype.checkReserveReady = function checkReserveReady() {
                this.reserve_ready = false;

                if (this.date && this.time && this.service || this.event || this.product || this.package_item || this.bulk_purchase || this.external_purchase || this.deal || this.is_coupon || this.date && this.service && this.service.duration_unit === 'day') {
                    this.reserve_ready = true;
                }

                return this.reserve_ready;
            };

            /***
             * @ngdoc method
             * @name getPostData
             * @methodOf BB.Models:BasketItem
             * @description
             * Build an array with details for every basket item in items array
             *
             * @returns {array} Newly created details array
             */


            BasketItem.prototype.getPostData = function getPostData() {
                if (this.cloneAnswersItem) {
                    var _iteratorNormalCompletion2 = true;
                    var _didIteratorError2 = false;
                    var _iteratorError2 = undefined;

                    try {
                        for (var _iterator2 = Array.from(this.cloneAnswersItem.item_details.questions)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                            var o_question = _step2.value;
                            var _iteratorNormalCompletion3 = true;
                            var _didIteratorError3 = false;
                            var _iteratorError3 = undefined;

                            try {
                                for (var _iterator3 = Array.from(this.item_details.questions)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                                    var m_question = _step3.value;

                                    if (m_question.id === o_question.id) {
                                        m_question.answer = o_question.answer;
                                        // mark questionds as asked if we're cloning
                                        this.setAskedQuestions();
                                    }
                                }
                            } catch (err) {
                                _didIteratorError3 = true;
                                _iteratorError3 = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                                        _iterator3.return();
                                    }
                                } finally {
                                    if (_didIteratorError3) {
                                        throw _iteratorError3;
                                    }
                                }
                            }
                        }
                    } catch (err) {
                        _didIteratorError2 = true;
                        _iteratorError2 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                _iterator2.return();
                            }
                        } finally {
                            if (_didIteratorError2) {
                                throw _iteratorError2;
                            }
                        }
                    }
                }

                var data = {};
                if (this.date) {
                    data.date = this.date.date.toISODate();
                }
                if (this.time) {
                    data.time = this.time.time;
                    if (this.time.event_id) {
                        data.event_id = this.time.event_id;
                    } else if (this.time.event_ids) {
                        // what's this about?
                        data.event_ids = this.time.event_ids;
                    }
                } else if (this.date && this.date.event_id) {
                    data.event_id = this.date.event_id;
                }
                data.price = this.price;
                data.paid = this.paid;
                if (this.book_link) {
                    data.book = this.book_link.$href('book');
                }
                data.id = this.id;
                data.duration = this.duration;
                data.settings = this.settings;
                data.child_client_ids = this.child_client_ids;
                if (!data.settings) {
                    data.settings = {};
                }
                if (this.earliest_time) {
                    data.settings.earliest_time = this.earliest_time;
                }
                if (this.item_details && this.asked_questions) {
                    data.questions = this.item_details.getPostData();
                }
                if (this.move_item_id) {
                    data.move_item_id = this.move_item_id;
                }
                if (this.srcBooking) {
                    data.move_item_id = this.srcBooking.id;
                }
                if (this.service) {
                    data.service_id = this.service.id;
                }
                if (this.resource) {
                    data.resource_id = this.resource.id;
                }
                if (this.person) {
                    data.person_id = this.person.id;
                }
                if (this.person_group_id) {
                    data.person_group_id = this.person_group_id;
                }
                data.length = this.length;
                if (this.event) {
                    data.event_id = this.event.id;
                    // when can events have a prepaid booking id?
                    if (this.event.pre_paid_booking_id != null) {
                        data.pre_paid_booking_id = this.event.pre_paid_booking_id;
                    } else if (this.tickets && this.tickets.pre_paid_booking_id != null) {
                        data.pre_paid_booking_id = this.tickets.pre_paid_booking_id;
                    }
                    data.tickets = this.tickets;
                }
                if (this.pre_paid_booking_id != null) {
                    data.pre_paid_booking_id = this.pre_paid_booking_id;
                }
                data.event_chain_id = this.event_chain_id;
                data.event_group_id = this.event_group_id;
                data.qty = this.qty;
                if (this.status) {
                    data.status = this.status;
                }
                if (this.num_resources != null) {
                    data.num_resources = parseInt(this.num_resources);
                }
                if (this.package_item) {
                    data.package_id = this.package_item.id;
                }
                if (this.bulk_purchase) {
                    data.bulk_purchase_id = this.bulk_purchase.id;
                }
                data.external_purchase = this.external_purchase;
                if (this.deal) {
                    data.deal = this.deal;
                }
                if (this.deal && this.recipient) {
                    data.recipient = this.recipient;
                }
                if (this.deal && this.recipient && this.recipient_mail) {
                    data.recipient_mail = this.recipient_mail;
                }
                data.coupon_id = this.coupon_id;
                data.is_coupon = this.is_coupon;
                if (this.attachment_id) {
                    data.attachment_id = this.attachment_id;
                }
                if (this.deal_codes) {
                    data.vouchers = this.deal_codes;
                }
                if (this.product) {
                    data.product_id = this.product.id;
                }
                data.ref = this.ref;
                if (this.move_reason) {
                    data.move_reason = this.move_reason;
                }

                if (this.email) {
                    data.email = this.email;
                }
                if (this.first_name) {
                    data.first_name = this.first_name;
                }
                if (this.last_name) {
                    data.last_name = this.last_name;
                }

                if (this.email != null) {
                    data.email = this.email;
                }
                if (this.email_admin != null) {
                    data.email_admin = this.email_admin;
                }
                if (this.private_note) {
                    data.private_note = this.private_note;
                }
                if (this.available_slot) {
                    data.available_slot = this.available_slot;
                }
                if (this.clinic_id) {
                    data.clinic_id = this.clinic_id;
                }
                return data;
            };

            /***
             * @ngdoc method
             * @name setPrice
             * @methodOf BB.Models:BasketItem
             * @description
             * Set price in according of nprice parameter
             *
             * @returns {integer} The returned set price
             */


            BasketItem.prototype.setPrice = function setPrice(nprice) {
                var printed_price = void 0;
                if (nprice != null) {
                    this.price = parseFloat(nprice);
                    printed_price = this.price / 100;
                    this.printed_price = printed_price % 1 === 0 ? "\xA3" + parseInt(printed_price) : $window.sprintf("£%.2f", printed_price);
                    if (this.company && this.company.settings) {
                        this.printed_vat_cal = this.company.settings.payment_tax;
                    }
                    if (this.printed_vat_cal) {
                        this.printed_vat = this.printed_vat_cal / 100 * printed_price;
                    }
                    if (this.printed_vat_cal) {
                        return this.printed_vat_inc = this.printed_vat_cal / 100 * printed_price + printed_price;
                    }
                } else {
                    this.price = null;
                    this.printed_price = null;
                    this.printed_vat_cal = null;
                    this.printed_vat = null;
                    return this.printed_vat_inc = null;
                }
            };

            /***
             * @ngdoc method
             * @name getStep
             * @methodOf BB.Models:BasketItem
             * @description
             * Build a temp object with current step variables
             *
             * @returns {object} Temp hash
             */


            BasketItem.prototype.getStep = function getStep() {
                var temp = {};
                temp.service = this.service;
                temp.category = this.category;
                temp.person = this.person;
                temp.resource = this.resource;
                temp.duration = this.duration;
                temp.event = this.event;
                temp.event_group = this.event_group;
                temp.event_chain = this.event_chain;
                temp.time = this.time;
                temp.date = this.date;
                temp.days_link = this.days_link;
                temp.book_link = this.book_link;
                temp.ready = this.ready;
                temp.num_book = this.num_book;
                temp.tickets = this.tickets;
                return temp;
            };

            /***
             * @ngdoc method
             * @name loadStep
             * @methodOf BB.Models:BasketItem
             * @description
             * Build current step variables based on a hash object passed as parameter
             *
             * @param {object} step Hash object representing a step
             *
             * @returns {object} The returned load step
             */


            BasketItem.prototype.loadStep = function loadStep(step) {
                this.service = step.service;
                this.category = step.category;
                this.person = step.person;
                this.resource = step.resource;
                this.duration = step.duration;
                this.event = step.event;
                this.event_chain = step.event_chain;
                this.event_group = step.event_group;
                this.time = step.time;
                this.date = step.date;
                this.days_link = step.days_link;
                this.book_link = step.book_link;
                this.ready = step.ready;
                this.num_book = step.num_book;
                return this.tickets = step.tickets;
            };

            /***
             * @ngdoc method
             * @name describe
             * @methodOf BB.Models:BasketItem
             * @description
             * Get information about of the basket item
             *
             * @returns {object} The returned title
             */


            BasketItem.prototype.describe = function describe() {
                var title = "-";
                if (this.service) {
                    title = this.service.name;
                }
                if (this.event_group && this.event && title === "-") {
                    title = this.event_group.name + " - " + this.event.description;
                }
                if (this.product) {
                    title = this.product.name;
                }
                if (this.external_purchase) {
                    title = this.external_purchase.name;
                }
                if (this.deal) {
                    title = this.deal.name;
                }
                if (this.package_item) {
                    title = this.package_item.name;
                }
                if (this.bulk_purchase) {
                    title = this.bulk_purchase.name;
                }
                return title;
            };

            /***
             * @ngdoc method
             * @name booking_date
             * @methodOf BB.Models:BasketItem
             * @description
             * Get booking date of the basket item, in according of format parameter
             *
             * @returns {date} The returned booking date
             */


            BasketItem.prototype.booking_date = function booking_date(format) {
                if (!this.date || !this.date.date) {
                    return null;
                }
                return this.date.date.format(format);
            };

            /***
             * @ngdoc method
             * @name booking_time
             * @methodOf BB.Models:BasketItem
             * @description
             * Get booking time of the basket item in according with separator = '-'
             *
             * @returns {date} The returned booking time
             */


            BasketItem.prototype.booking_time = function booking_time(seperator) {
                if (seperator == null) {
                    seperator = '-';
                }
                if (!this.time) {
                    return null;
                }
                var duration = this.listed_duration ? this.listed_duration : this.duration;
                return this.time.print_time() + " " + seperator + " " + this.time.print_end_time(duration);
            };

            /***
             * @ngdoc method
             * @name duePrice
             * @methodOf BB.Models:BasketItem
             * @description
             * Get due price for the basket item
             *
             * @returns {string} The returned price
             */


            BasketItem.prototype.duePrice = function duePrice() {
                if (this.isWaitlist()) {
                    return 0;
                }
                return this.price;
            };

            /***
             * @ngdoc method
             * @name isWaitlist
             * @methodOf BB.Models:BasketItem
             * @description
             * Checks if this is a wait list
             *
             * @returns {boolean} If this is a wait list
             */


            BasketItem.prototype.isWaitlist = function isWaitlist() {
                return this.status && this.status === 8; // 8 = waitlist
            };

            /***
             * @ngdoc method
             * @name start_datetime
             * @methodOf BB.Models:BasketItem
             * @description
             * Get booking start date and time
             *
             * @returns {date} The returned start date time
             */


            BasketItem.prototype.start_datetime = function start_datetime() {
                if (!this.date || !this.time) {
                    return null;
                }
                return DateTimeUtilitiesService.convertTimeToMoment(this.date.date, this.time.time);
            };

            BasketItem.prototype.startDatetime = function startDatetime() {
                return this.start_datetime();
            };

            /***
             * @ngdoc method
             * @name end_datetime
             * @methodOf BB.Models:BasketItem
             * @description
             * Get booking end date and time
             *
             * @returns {date} The returned end date time
             */


            BasketItem.prototype.end_datetime = function end_datetime() {
                if (!this.date || !this.time || !this.listed_duration && !this.duration) {
                    return null;
                }
                var duration = this.listed_duration ? this.listed_duration : this.duration;
                var time = this.time.time + duration;
                return DateTimeUtilitiesService.convertTimeToMoment(this.date.date, time);
            };

            BasketItem.prototype.endDatetime = function endDatetime() {
                return this.end_datetime();
            };

            /***
             * @ngdoc method
             * @name setSrcBooking
             * @methodOf BB.Models:BasketItem
             * @description
             * Set a booking are to be a move if according of booking parameter
             *
             * @returns {object} The returned end date time
             */
            // set a booking are to be a move (or a copy?) from a previous booking


            BasketItem.prototype.setSrcBooking = function setSrcBooking(booking) {
                this.srcBooking = booking;
                // convert duration from seconds to minutes
                return this.duration = booking.duration;
            };

            /***
             * @ngdoc method
             * @name anyPerson
             * @methodOf BB.Models:BasketItem
             * @description
             * Verify type of any person
             *
             * @returns {boolean} The returned any person
             */


            BasketItem.prototype.anyPerson = function anyPerson() {
                return this.person && typeof this.person === 'boolean';
            };

            /***
             * @ngdoc method
             * @name anyResource
             * @methodOf BB.Models:BasketItem
             * @description
             * Verify type of any resorce
             *
             * @returns {boolean} The returned any resource
             */


            BasketItem.prototype.anyResource = function anyResource() {
                return this.resource && typeof this.resource === 'boolean';
            };

            /***
             * @ngdoc method
             * @name isMovingBooking
             * @methodOf BB.Models:BasketItem
             * @description
             * Verify if booking has been moved
             *
             * @returns {boolean} The returned moving booking
             */


            BasketItem.prototype.isMovingBooking = function isMovingBooking() {
                return this.srcBooking || this.move_item_id;
            };

            /***
             * @ngdoc method
             * @name setCloneAnswers
             * @methodOf BB.Models:BasketItem
             * @description
             * Set clone answers in according of other item parameter
             *
             * @returns {object} The returned clone answers
             */


            BasketItem.prototype.setCloneAnswers = function setCloneAnswers(otherItem) {
                return this.cloneAnswersItem = otherItem;
            };

            /***
             * @ngdoc method
             * @name questionPrice
             * @methodOf BB.Models:BasketItem
             * @description
             * Question price for the basket item
             *
             * @returns {integer} The returned question price
             */


            BasketItem.prototype.questionPrice = function questionPrice() {

                if (!this.item_details) {
                    return 0;
                }
                return this.item_details.questionPrice(this.getQty());
            };

            /***
             * @ngdoc method
             * @name getQty
             * @methodOf BB.Models:BasketItem
             * @description
             * Get quantity of tickets
             *
             * @returns {integer} The returned quatity of tickets
             */


            BasketItem.prototype.getQty = function getQty() {
                if (this.qty) {
                    return this.qty;
                }
                if (this.tickets) {
                    return this.tickets.qty;
                }
                return 1;
            };

            /***
             * @ngdoc method
             * @name totalPrice
             * @methodOf BB.Models:BasketItem
             * @description
             * Total price of the basket item (price including discounts)
             *
             * @returns {integer} The returned total price
             */


            BasketItem.prototype.totalPrice = function totalPrice() {
                if (this.tickets && this.tickets.pre_paid_booking_id) {
                    return 0;
                }
                if (this.pre_paid_booking_id) {
                    return 0;
                }
                if (this.discount_price != null) {
                    return this.discount_price + this.questionPrice();
                }
                var pr = this.total_price;
                if (!angular.isNumber(pr)) {
                    pr = this.price;
                }
                if (!angular.isNumber(pr)) {
                    pr = 0;
                }
                return pr + this.questionPrice();
            };

            /***
             * @ngdoc method
             * @name fullPrice
             * @methodOf BB.Models:BasketItem
             * @description
             * Full price for the basket item (price not including discounts)
             *
             * @returns {integer} The returned full price
             */


            BasketItem.prototype.fullPrice = function fullPrice() {
                var pr = this.base_price;
                if (!pr) {
                    pr = this.total_price;
                }
                if (!pr) {
                    pr = this.price;
                }
                if (!pr) {
                    pr = 0;
                }
                return pr + this.questionPrice();
            };

            /***
             * @ngdoc method
             * @name setProduct
             * @methodOf BB.Models:BasketItem
             * @description
             * Apply a product to the BasketItem
             *
             */


            BasketItem.prototype.setProduct = function setProduct(product) {
                this.product = product;
                if (this.product.$has('book')) {
                    this.book_link = this.product;
                }
                if (product.price) {
                    return this.setPrice(product.price);
                }
            };

            /***
             * @ngdoc method
             * @name setPackageItem
             * @methodOf BB.Models:BasketItem
             * @description
             * Apply a package to the BasketItem
             *
             */


            BasketItem.prototype.setPackageItem = function setPackageItem(package_item) {
                this.package_item = package_item;
                if (this.package_item.$has('book')) {
                    this.book_link = this.package_item;
                }
                if (package_item.price) {
                    return this.setPrice(package_item.price);
                }
            };

            /***
             * @ngdoc method
             * @name setBulkPurchase
             * @methodOf BB.Models:BasketItem
             * @description
             * Apply a bulk purchase to the BasketItem
             *
             */


            BasketItem.prototype.setBulkPurchase = function setBulkPurchase(bulk_purchase) {
                this.bulk_purchase = bulk_purchase;
                if (this.bulk_purchase.$has('book')) {
                    this.book_link = this.bulk_purchase;
                }
                if (bulk_purchase.price) {
                    return this.setPrice(bulk_purchase.price);
                }
            };

            /***
             * @ngdoc method
             * @name setExternalPurchase
             * @methodOf BB.Models:BasketItem
             * @description
             * Apply an external purchase to the BasketItem
             *
             */


            BasketItem.prototype.setExternalPurchase = function setExternalPurchase(external_purchase) {
                this.external_purchase = external_purchase;
                this.book_link = this.company;
                if (external_purchase.price) {
                    return this.setPrice(external_purchase.price);
                }
            };

            /***
             * @ngdoc method
             * @name setDeal
             * @methodOf BB.Models:BasketItem
             * @description
             * Apply a deal on to BasketItem
             *
             */


            BasketItem.prototype.setDeal = function setDeal(deal) {
                this.deal = deal;
                if (this.deal.$has('book')) {
                    this.book_link = this.deal;
                }
                if (deal.price) {
                    return this.setPrice(deal.price);
                }
            };

            /***
             * @ngdoc method
             * @name hasPrice
             * @methodOf BB.Models:BasketItem
             * @description
             * Checks if the BasketItem has a price
             *
             * @returns {boolean} Whether there is a price or not
             */


            BasketItem.prototype.hasPrice = function hasPrice() {
                return this.price != null;
            };

            /***
             * @ngdoc method
             * @name getAttachment
             * @methodOf BB.Models:BasketItem
             * @description
             * Get attachment of the basket item
             *
             * @returns {object} The attachment
             */


            BasketItem.prototype.getAttachment = function getAttachment() {
                var _this5 = this;

                if (this.attachment) {
                    return this.attachment;
                }
                if (this.$has('attachment') && this.attachment_id) {
                    return this._data.$get('attachment').then(function (att) {
                        _this5.attachment = att;
                        return _this5.attachment;
                    });
                }
            };

            /***
             * @ngdoc method
             * @name deleteAttachment
             * @methodOf BB.Models:BasketItem
             * @description
             * Delete attachment of the basket item
             *
             * @returns {object} The attachment
             */

            BasketItem.prototype.deleteAttachment = function deleteAttachment() {
                if (this.attachment_id) {
                    this._data.$del("del_attachment", {});
                    return this.attachment_id = null;
                }
            };

            /***
             * @ngdoc method
             * @name setPrepaidBooking
             * @methodOf BB.Models:BasketItem
             * @description
             * Apply a prepaid booking to BasketItem
             *
             */


            BasketItem.prototype.setPrepaidBooking = function setPrepaidBooking(pre_paid_booking) {
                this.pre_paid_booking = pre_paid_booking;
                return this.pre_paid_booking_id = pre_paid_booking.id;
            };

            /***
             * @ngdoc method
             * @name hasPrepaidBooking
             * @methodOf BB.Models:BasketItem
             * @description
             * Indicates if the basket item has a prepaid booking applied
             *
             * @returns {boolean} boolean indicating if the BasketItem has a prepaid booking
             */


            BasketItem.prototype.hasPrepaidBooking = function hasPrepaidBooking() {
                return this.pre_paid_booking_id != null;
            };

            /***
             * @ngdoc method
             * @name getEventId
             * @methodOf BB.Models:BasketItem
             * @description
             * Get the event id for the BasketItem
             *
             * @returns {string} The Event ID
             */


            BasketItem.prototype.getEventId = function getEventId() {
                if (this.time && this.time.event_id) {
                    return this.time.event_id;
                } else if (this.date && this.date.event_id) {
                    return this.date.event_id;
                } else if (this.event) {
                    return this.event.id;
                }
            };

            /***
             * @ngdoc method
             * @name isExternalPurchase
             * @methodOf BB.Models:BasketItem
             * @description
             * Indicates if the BasketItem is an external purchase
             *
             * @returns {boolean} Whether it is an external purchase or not.
             */


            BasketItem.prototype.isExternalPurchase = function isExternalPurchase() {
                return this.external_purchase != null;
            };

            /***
             * @ngdoc method
             * @name getName
             * @methodOf BB.Models:BasketItem
             * @description
             * Returns the basket item name
             *
             * @returns {String} The name of the basket item.
             */


            BasketItem.prototype.getName = function getName() {
                if (this.session_name) {
                    return this.session_name;
                } else {
                    return this.service_name;
                }
            };

            /***
             * @ngdoc method
             * @name getAttendeeName
             * @methodOf BB.Models:BasketItem
             * @description
             * Returns the attendee name
             *
             * @returns {String} The name of the attendee.
             */


            BasketItem.prototype.getAttendeeName = function getAttendeeName(client) {
                if (this.first_name) {
                    return this.first_name + " " + this.last_name;
                } else if (client) {
                    return client.getName();
                }
            };

            /***
             * @ngdoc method
             * @name isTimeItem
             * @methodOf BB.Models:BasketItem
             * @description
             * Indicates if the BasketItem is a time item (i.e. either an event
             * or appointment booking)
             *
             * @returns {boolean} Whether it is a time item or not.
             */


            BasketItem.prototype.isTimeItem = function isTimeItem() {
                return this.service || this.event;
            };

            return BasketItem;
        }(BaseModel)
    );
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:BookableItem
 *
 * @description
 * Representation of an BookableItem Object
 *
 * @property {string} name Property name display "-Waiting-"
 * @property {string} ready The ready
 * @property {string} promise The promise
 * @property {string} item Bookable item
 */ //


angular.module('BB.Models').factory("BookableItemModel", function ($q, BBModel, BaseModel, ItemService) {
    return __initClass__(function (_BaseModel) {
        _inherits(BookableItem, _BaseModel);

        BookableItem.initClass = function initClass() {

            this.prototype.item = null;

            this.prototype.promise = null;
        };

        function BookableItem(data) {
            _classCallCheck(this, BookableItem);

            var _this = _possibleConstructorReturn(this, _BaseModel.apply(this, arguments));

            _this.name = "-Waiting-";
            _this.ready = $q.defer();
            _this.promise = _this._data.$get('item');
            _this.promise.then(function (val) {
                var m = void 0,
                    n = void 0;
                if (val.type === "person") {
                    _this.item = new BBModel.Person(val);
                    if (_this.item) {
                        for (n in _this.item._data) {
                            m = _this.item._data[n];
                            if (_this.item._data.hasOwnProperty(n) && typeof m !== 'function') {
                                _this[n] = m;
                            }
                        }
                        return _this.ready.resolve();
                    } else {
                        return _this.ready.resolve();
                    }
                } else if (val.type === "resource") {
                    _this.item = new BBModel.Resource(val);
                    if (_this.item) {
                        for (n in _this.item._data) {
                            m = _this.item._data[n];
                            if (_this.item._data.hasOwnProperty(n) && typeof m !== 'function') {
                                _this[n] = m;
                            }
                        }
                        return _this.ready.resolve();
                    } else {
                        return _this.ready.resolve();
                    }
                } else if (val.type === "service") {
                    _this.item = new BBModel.Service(val);
                    if (_this.item) {
                        for (n in _this.item._data) {
                            m = _this.item._data[n];
                            if (_this.item._data.hasOwnProperty(n) && typeof m !== 'function') {
                                _this[n] = m;
                            }
                        }
                        return _this.ready.resolve();
                    } else {
                        return _this.ready.resolve();
                    }
                }
            });
            return _this;
        }

        BookableItem.$query = function $query(params) {
            return ItemService.query(params);
        };

        return BookableItem;
    }(BaseModel));
});

function __initClass__(c) {
    c.initClass();
    return c;
}
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:BulkPurchase
 *
 * @description
 * Representation of a BulkPurchase Object
 */ //

angular.module('BB.Models').factory("BulkPurchaseModel", function ($q, BBModel, BaseModel, BulkPurchaseService) {
    return function (_BaseModel) {
        _inherits(BulkPurchase, _BaseModel);

        function BulkPurchase() {
            _classCallCheck(this, BulkPurchase);

            return _possibleConstructorReturn(this, _BaseModel.apply(this, arguments));
        }

        BulkPurchase.$query = function $query(company) {
            return BulkPurchaseService.query(company);
        };

        return BulkPurchase;
    }(BaseModel);
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:BussinessQuestion
 *
 * @description
 * Representation of an BussinessQuestion Object
 */ //


angular.module('BB.Models').factory("BusinessQuestionModel", function ($q, $filter, BBModel, BaseModel) {
    return function (_BaseModel) {
        _inherits(BusinessQuestion, _BaseModel);

        function BusinessQuestion(data) {
            _classCallCheck(this, BusinessQuestion);

            return _possibleConstructorReturn(this, _BaseModel.call(this, data));
        }

        return BusinessQuestion;
    }(BaseModel);
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:Category
 *
 * @description
 * Representation of a Category Object
 */ //


angular.module('BB.Models').factory("CategoryModel", function ($q, BBModel, BaseModel, CategoryService) {
    return function (_BaseModel) {
        _inherits(Category, _BaseModel);

        function Category() {
            _classCallCheck(this, Category);

            return _possibleConstructorReturn(this, _BaseModel.apply(this, arguments));
        }

        Category.$query = function $query(company) {
            return CategoryService.query(company);
        };

        return Category;
    }(BaseModel);
});
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:Client
 *
 * @description
 * Representation of an Client Object
 *
 * @property {string} first_name Client first name
 * @property {string} last_name Client last name
 * @property {string} email Client email address
 * @property {string} address1 The first line of client address
 * @property {string} address2 The second line of client address
 * @property {string} address3 The third line of client address
 * @property {string} address4 The fourth line of client address
 * @property {string} address4 The fifth line of client address
 * @property {string} postcode Postcode of the client
 * @property {string} country Country of the client
 * @property {integer} phone The phone number of the client
 * @property {integer} mobile The mobile phone number of the client
 * @property {integer} id Id of the client
 * @property {array} answers Answers of the client
 * @property {boolean} deleted Verify if the client account is deleted or not
 * @property {object} extra_info Can contain any data in addition to locale
 */ //


angular.module('BB.Models').factory("ClientModel", function ($q, BBModel, BaseModel, ClientService, bbLocale) {
    return function (_BaseModel) {
        _inherits(Client, _BaseModel);

        function Client(data) {
            _classCallCheck(this, Client);

            var _this = _possibleConstructorReturn(this, _BaseModel.apply(this, arguments));

            _this.name = _this.getName();
            _this.setExtraInfo();
            if (data) {
                if (data.answers && data.$has('questions')) {
                    _this.waitingQuestions = $q.defer();
                    _this.gotQuestions = _this.waitingQuestions.promise;
                    data.$get('questions').then(function (details) {
                        _this.client_details = new BBModel.ClientDetails(details);
                        _this.client_details.setAnswers(data.answers);
                        _this.questions = _this.client_details.questions;
                        _this.setAskedQuestions(); // make sure the item knows the questions were all answered
                        return _this.waitingQuestions.resolve();
                    });
                }
            }
            return _this;
        }

        /***
         * @ngdoc method
         * @name setClientDetails
         * @methodOf BB.Models:Client
         * @description
         * Set client details in according to details parameter
         *
         * @returns {object} The returned client details
         */


        Client.prototype.setClientDetails = function setClientDetails(details) {
            this.client_details = details;
            return this.questions = this.client_details.questions;
        };

        /**
         * @ngdoc method
         * @name setTimeZone
         * @methodOf BB.Models:Client
         * @description
         * Set client time zone in according to time_zone parameter
         * @param {string} time_zone timezone
         */


        Client.prototype.setTimeZone = function setTimeZone(time_zone) {
            if (time_zone != null) {
                this.time_zone = time_zone;
            }
        };

        /**
         * @ngdoc method
         * @name setExtraInfo
         * @methodOf BB.Models:Client
         * @description
         * Set the extra_info object
         * @param {object} extra_info Can contain any data in addition to locale
         */


        Client.prototype.setExtraInfo = function setExtraInfo() {
            var extra_info = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            this.extra_info = extra_info;
        };

        /***
         * @ngdoc method
         * @name setDefaults
         * @methodOf BB.Models:Client
         * @description
         * Set client defaults in according of values parameter
         *
         * @returns {object} The returned client defaults
         */


        Client.prototype.setDefaults = function setDefaults(values) {
            if (values.name) {
                this.name = values.name;
            }
            if (values.first_name) {
                this.first_name = values.first_name;
            }
            if (values.last_name) {
                this.last_name = values.last_name;
            }
            if (values.phone) {
                this.phone = values.phone;
            }
            if (values.mobile) {
                this.mobile = values.mobile;
            }
            if (values.email) {
                this.email = values.email;
            }
            if (values.id) {
                this.id = values.id;
            }
            if (values.ref) {
                this.comp_ref = values.ref;
            }
            if (values.comp_ref) {
                this.comp_ref = values.comp_ref;
            }
            if (values.address1) {
                this.address1 = values.address1;
            }
            if (values.address2) {
                this.address2 = values.address2;
            }
            if (values.address3) {
                this.address3 = values.address3;
            }
            if (values.address4) {
                this.address4 = values.address4;
            }
            if (values.address5) {
                this.address5 = values.address5;
            }
            if (values.postcode) {
                this.postcode = values.postcode;
            }
            if (values.country) {
                this.country = values.country;
            }
            if (values.answers) {
                this.default_answers = values.answers;
            }
            if (values.time_zone) {
                return this.time_zone = values.time_zone;
            }
            if (values.extra_info) {
                return this.extra_info = values.extra_info;
            }
        };

        /***
         * @ngdoc method
         * @name pre_fill_answers
         * @methodOf BB.Models:Client
         * @description
         * Pre fill client answers according of details
         *
         * @returns {object} The returned pre fill answers
         */


        Client.prototype.pre_fill_answers = function pre_fill_answers(details) {
            var _this2 = this;

            if (!this.default_answers) {
                return;
            }
            return function () {
                var result = [];
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Array.from(details.questions)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var q = _step.value;

                        var item = void 0;
                        if (_this2.default_answers[q.name]) {
                            item = q.answer = _this2.default_answers[q.name];
                        }
                        result.push(item);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                return result;
            }();
        };

        /***
         * @ngdoc method
         * @name getName
         * @methodOf BB.Models:Client
         * @description
         * Get client first name and last name
         *
         * @returns {string} The returned client name
         */


        Client.prototype.getName = function getName() {
            var str = "";
            if (this.first_name) {
                str += this.first_name;
            }
            if (str.length > 0 && this.last_name) {
                str += " ";
            }
            if (this.last_name) {
                str += this.last_name;
            }
            return str;
        };

        /***
         * @ngdoc method
         * @name addressSingleLine
         * @methodOf BB.Models:Address
         * @description
         * Get the address and postcode of the client
         *
         * @returns {string} The returned address
         */


        Client.prototype.addressSingleLine = function addressSingleLine() {
            var str = "";
            if (this.address1) {
                str += this.address1;
            }
            if (this.address2 && str.length > 0) {
                str += ", ";
            }
            if (this.address2) {
                str += this.address2;
            }
            if (this.address3 && str.length > 0) {
                str += ", ";
            }
            if (this.address3) {
                str += this.address3;
            }
            if (this.address4 && str.length > 0) {
                str += ", ";
            }
            if (this.address4) {
                str += this.address4;
            }
            if (this.address5 && str.length > 0) {
                str += ", ";
            }
            if (this.address5) {
                str += this.address5;
            }
            if (this.postcode && str.length > 0) {
                str += ", ";
            }
            if (this.postcode) {
                str += this.postcode;
            }
            return str;
        };

        /***
         * @ngdoc method
         * @name hasAddress
         * @methodOf BB.Models:Address
         * @description
         * Checks if this is considered a valid address
         *
         * @returns {boolean} If this is a valid address
         */


        Client.prototype.hasAddress = function hasAddress() {
            return this.address1 || this.address2 || this.postcode;
        };

        /***
         * @ngdoc method
         * @name addressCsvLine
         * @methodOf BB.Models:Address
         * @description
         * Get all address fields, postcode and country for CSV file
         *
         * @returns {string} The returned address
         */


        Client.prototype.addressCsvLine = function addressCsvLine() {
            var str = "";
            if (this.address1) {
                str += this.address1;
            }
            str += ", ";
            if (this.address2) {
                str += this.address2;
            }
            str += ", ";
            if (this.address3) {
                str += this.address3;
            }
            str += ", ";
            if (this.address4) {
                str += this.address4;
            }
            str += ", ";
            if (this.address5) {
                str += this.address5;
            }
            str += ", ";
            if (this.postcode) {
                str += this.postcode;
            }
            str += ", ";
            if (this.country) {
                str += this.country;
            }
            return str;
        };

        /***
         * @ngdoc method
         * @name addressMultiLine
         * @methodOf BB.Models:Address
         * @description
         * Get address several lines separated by line breaks
         *
         * @returns {string} The returned address
         */


        Client.prototype.addressMultiLine = function addressMultiLine() {
            var str = "";
            if (this.address1) {
                str += this.address1;
            }
            if (this.address2 && str.length > 0) {
                str += "<br/>";
            }
            if (this.address2) {
                str += this.address2;
            }
            if (this.address3 && str.length > 0) {
                str += "<br/>";
            }
            if (this.address3) {
                str += this.address3;
            }
            if (this.address4 && str.length > 0) {
                str += "<br/>";
            }
            if (this.address4) {
                str += this.address4;
            }
            if (this.address5 && str.length > 0) {
                str += "<br/>";
            }
            if (this.address5) {
                str += this.address5;
            }
            if (this.postcode && str.length > 0) {
                str += "<br/>";
            }
            if (this.postcode) {
                str += this.postcode;
            }
            return str;
        };

        /***
         * @ngdoc method
         * @name getPostData
         * @methodOf BB.Models:Address
         * @description
         * Build an array with details of the client
         *
         * @returns {array} newly created details array
         */


        Client.prototype.getPostData = function getPostData() {
            var x = {};
            x.first_name = this.first_name;
            x.last_name = this.last_name;
            if (this.house_number) {
                x.address1 = this.house_number + " " + this.address1;
            } else {
                x.address1 = this.address1;
            }
            x.address2 = this.address2;
            x.address3 = this.address3;
            x.address4 = this.address4;
            x.address5 = this.address5;
            x.postcode = this.postcode;
            x.country = this.country;
            x.email = this.email;
            x.id = this.id;
            x.comp_ref = this.comp_ref;
            x.parent_client_id = this.parent_client_id;
            x.password = this.password;
            x.notifications = this.notifications;
            if (this.member_level_id) {
                x.member_level_id = this.member_level_id;
            }
            if (this.send_welcome_email) {
                x.send_welcome_email = this.send_welcome_email;
            }
            if (this.default_company_id) {
                x.default_company_id = this.default_company_id;
            }
            if (this.time_zone) {
                x.time_zone = this.time_zone;
            }

            if (this.phone) {
                x.phone = this.phone;
                if (this.phone_prefix) {
                    x.phone_prefix = this.phone_prefix;
                }
            }

            if (this.mobile) {
                this.remove_prefix();
                x.mobile = this.mobile;
                x.mobile_prefix = this.mobile_prefix;
            }

            if (this.questions) {
                x.questions = [];
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = Array.from(this.questions)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var q = _step2.value;

                        x.questions.push(q.getPostData());
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }
            }

            x.extra_info = this.extra_info;
            x.extra_info.locale = bbLocale.getLocale();

            return x;
        };

        /***
         * @ngdoc method
         * @name valid
         * @methodOf BB.Models:Address
         * @description
         * Checks if this is considered a valid email
         *
         * @returns {boolean} If this is a valid email
         */


        Client.prototype.valid = function valid() {
            if (this.isValid) {
                return this.isValid;
            }
            if (this.email || this.hasServerId()) {
                return true;
            } else {
                return false;
            }
        };

        /***
         * @ngdoc method
         * @name setValid
         * @methodOf BB.Models:Address
         * @description
         * Set valid client, according of val
         *
         * @returns {object} The returned valid client
         */


        Client.prototype.setValid = function setValid(val) {
            return this.isValid = val;
        };

        /***
         * @ngdoc method
         * @name hasServerId
         * @methodOf BB.Models:Address
         * @description
         * Checks if this has a id
         *
         * @returns {boolean} If this has a id
         */


        Client.prototype.hasServerId = function hasServerId() {
            return this.id;
        };

        /***
         * @ngdoc method
         * @name setAskedQuestions
         * @methodOf BB.Models:Address
         * @description
         * Set asked questions of the client
         *
         * @returns {boolean} If this is set
         */


        Client.prototype.setAskedQuestions = function setAskedQuestions() {
            return this.asked_questions = true;
        };

        /***
         * @ngdoc method
         * @name fullMobile
         * @methodOf BB.Models:Address
         * @description
         * Full mobile phone number of the client
         *
         * @returns {object} The returned full mobile number
         */


        Client.prototype.fullMobile = function fullMobile() {
            if (!this.mobile) {
                return;
            }
            if (!this.mobile_prefix) {
                return this.mobile;
            }
            return '+' + this.mobile_prefix + (this.mobile.substr(0, 1) === '0' ? this.mobile.substr(1) : this.mobile);
        };

        /***
         * @ngdoc method
         * @name remove_prefix
         * @methodOf BB.Models:Address
         * @description
         * Remove prefix from mobile number of the client
         *
         * @returns {array} The returned full mobile number without prefix
         */


        Client.prototype.remove_prefix = function remove_prefix() {
            var pref_arr = this.mobile.match(/^(\+|00)(999|998|997|996|995|994|993|992|991|990|979|978|977|976|975|974|973|972|971|970|969|968|967|966|965|964|963|962|961|960|899|898|897|896|895|894|893|892|891|890|889|888|887|886|885|884|883|882|881|880|879|878|877|876|875|874|873|872|871|870|859|858|857|856|855|854|853|852|851|850|839|838|837|836|835|834|833|832|831|830|809|808|807|806|805|804|803|802|801|800|699|698|697|696|695|694|693|692|691|690|689|688|687|686|685|684|683|682|681|680|679|678|677|676|675|674|673|672|671|670|599|598|597|596|595|594|593|592|591|590|509|508|507|506|505|504|503|502|501|500|429|428|427|426|425|424|423|422|421|420|389|388|387|386|385|384|383|382|381|380|379|378|377|376|375|374|373|372|371|370|359|358|357|356|355|354|353|352|351|350|299|298|297|296|295|294|293|292|291|290|289|288|287|286|285|284|283|282|281|280|269|268|267|266|265|264|263|262|261|260|259|258|257|256|255|254|253|252|251|250|249|248|247|246|245|244|243|242|241|240|239|238|237|236|235|234|233|232|231|230|229|228|227|226|225|224|223|222|221|220|219|218|217|216|215|214|213|212|211|210|98|95|94|93|92|91|90|86|84|82|81|66|65|64|63|62|61|60|58|57|56|55|54|53|52|51|49|48|47|46|45|44|43|41|40|39|36|34|33|32|31|30|27|20|7|1)/);
            if (pref_arr) {
                this.mobile.replace(pref_arr[0], "");
                return this.mobile_prefix = pref_arr[0];
            }
        };

        /***
         * @ngdoc method
         * @name $getPrePaidBookings
         * @methodOf BB.Models:Address
         * @description
         * Get pre paid bookings promise of the client
         *
         * @returns {promise} A promise for client pre paid bookings
         */


        Client.prototype.$getPrePaidBookings = function $getPrePaidBookings(params) {
            var defer = $q.defer();
            if (this.$has('pre_paid_bookings')) {
                this.$get('pre_paid_bookings', params).then(function (collection) {
                    return collection.$get('pre_paid_bookings').then(function (prepaids) {
                        return defer.resolve(Array.from(prepaids).map(function (prepaid) {
                            return new BBModel.PrePaidBooking(prepaid);
                        }));
                    }, function (err) {
                        return defer.reject(err);
                    });
                }, function (err) {
                    return (
                        // =====================================================================================================
                        // TO FIX IN API:
                        // When a default Client is generated by SSO, @get('pre_paid_bookings') returns 401
                        // which in turn throws an error in the Widget
                        // I am going to fail this error silently so that the Widget will not display the error for CHORLEY
                        // =====================================================================================================
                        defer.resolve([])
                    );
                });
                // defer.reject(err)
                // return empty array if there are no prepaid bookings
            } else {
                defer.resolve([]);
            }
            return defer.promise;
        };

        Client.$create_or_update = function $create_or_update(company, client) {
            return ClientService.create_or_update(company, client);
        };

        Client.$query_by_email = function $query_by_email(company, email) {
            return ClientService.query_by_email(company, email);
        };

        return Client;
    }(BaseModel);
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:ClientDetails
 *
 * @description
 * Representation of an ClientDetails Object
 *
 * @property {array} questions Questions of the client
 * @property {integer} company_id The company id of the client company
 */ //


angular.module('BB.Models').factory("ClientDetailsModel", function ($q, BBModel, BaseModel, ClientDetailsService) {
    return function (_BaseModel) {
        _inherits(ClientDetails, _BaseModel);

        function ClientDetails(data) {
            _classCallCheck(this, ClientDetails);

            var _this = _possibleConstructorReturn(this, _BaseModel.apply(this, arguments));

            _this.questions = [];
            if (_this._data) {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Array.from(data.questions)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var q = _step.value;

                        _this.questions.push(new BBModel.Question(q));
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
            _this.hasQuestions = _this.questions.length > 0;
            return _this;
        }

        /***
         * @ngdoc method
         * @name getPostData
         * @methodOf BB.Models:ClientDetails
         * @description
         * Get post data from client details according to questions
         *
         * @returns {object} The returned data
         */


        ClientDetails.prototype.getPostData = function getPostData(questions) {
            var data = [];
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = Array.from(questions)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var q = _step2.value;

                    data.push({ answer: q.answer, id: q.id, price: q.price });
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            return data;
        };

        /***
         * @ngdoc method
         * @name setAnswers
         * @methodOf BB.Models:ClientDetails
         * @description
         * Set answers of the client details in function of answers
         *
         * @returns {object} The returned answers
         */
        // load the answers from an answer set - probably from loading an existing basket item


        ClientDetails.prototype.setAnswers = function setAnswers(answers) {
            var _this2 = this;

            // turn answers into a hash
            var ahash = {};
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = Array.from(answers)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var a = _step3.value;

                    ahash[a.question_id] = a;
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }

            return function () {
                var result = [];
                var _iteratorNormalCompletion4 = true;
                var _didIteratorError4 = false;
                var _iteratorError4 = undefined;

                try {
                    for (var _iterator4 = Array.from(_this2.questions)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                        var q = _step4.value;

                        var item = void 0;
                        if (ahash[q.id]) {
                            // if we have answer for it
                            item = q.answer = ahash[q.id].answer;
                        }
                        result.push(item);
                    }
                } catch (err) {
                    _didIteratorError4 = true;
                    _iteratorError4 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion4 && _iterator4.return) {
                            _iterator4.return();
                        }
                    } finally {
                        if (_didIteratorError4) {
                            throw _iteratorError4;
                        }
                    }
                }

                return result;
            }();
        };

        ClientDetails.$query = function $query(company) {
            return ClientDetailsService.query(company);
        };

        return ClientDetails;
    }(BaseModel);
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:Clinic
 *
 * @description
 * Representation of an Clinic Object
 *
 * @property {string} setTimes Set times for the clinic
 * @property {string} setResourcesAndPeople Set resources and people for the clinic
 * @property {object} settings Clinic settings
 * @property {string} resources Clinic resources
 * @property {integer} resource_ids Clinic resources ids
 * @property {string} people Clinic people
 * @property {integer} person_ids Clinic Person ids
 * @property {string} services Clinic services
 * @property {integer} services_ids Clinic service ids
 * @property {string} uncovered The uncovered
 * @property {string} className The class Name
 * @property {string} start_time The clinic start thime
 * @property {string} start The clinic start
 * @property {string} end_time The clinic end time
 * @property {string} end The clinic end
 * @property {string} title The title
 */ //


angular.module('BB.Models').factory("ClinicModel", function ($q, BBModel, BaseModel) {
    return function (_BaseModel) {
        _inherits(Clinic, _BaseModel);

        function Clinic(data) {
            _classCallCheck(this, Clinic);

            var _this = _possibleConstructorReturn(this, _BaseModel.call(this, data));

            _this.setTimes();
            _this.setResourcesAndPeople();
            if (!_this.settings) {
                _this.settings = {};
            }
            return _this;
        }

        /***
         * @ngdoc method
         * @name setResourcesAndPeople
         * @methodOf BB.Models:Clinic
         * @description
         * Set resources and people for clinic
         *
         * @returns {object} The returned resources and people
         */


        Clinic.prototype.setResourcesAndPeople = function setResourcesAndPeople() {
            this.resources = _.reduce(this.resource_ids, function (h, id) {
                h[id] = true;
                return h;
            }, {});
            this.people = _.reduce(this.person_ids, function (h, id) {
                h[id] = true;
                return h;
            }, {});
            this.services = _.reduce(this.service_ids, function (h, id) {
                h[id] = true;
                return h;
            }, {});
            this.uncovered = !this.person_ids || this.person_ids.length === 0;
            if (this.uncovered) {
                return this.className = "clinic_uncovered";
            } else {
                return this.className = "clinic_covered";
            }
        };

        /***
         * @ngdoc method
         * @name setTimes
         * @methodOf BB.Models:Clinic
         * @description
         * Set time for clinic
         *
         * @returns {object} The returned time
         */


        Clinic.prototype.setTimes = function setTimes() {
            if (this.start_time) {
                this.start_time = moment(this.start_time);
                this.start = this.start_time;
            }
            if (this.end_time) {
                this.end_time = moment(this.end_time);
                this.end = this.end_time;
            }
            return this.title = this.name;
        };

        return Clinic;
    }(BaseModel);
});
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

angular.module('BB.Models').factory("BBCollectionModel", function ($q, BBModel, BaseModel) {
    return function (_BaseModel) {
        _inherits(BBCollection, _BaseModel);

        function BBCollection() {
            _classCallCheck(this, BBCollection);

            return _possibleConstructorReturn(this, _BaseModel.apply(this, arguments));
        }

        BBCollection.prototype.getNextPage = function getNextPage(params) {

            var deferred = $q.defer();

            this.$get('next', params).then(function (collection) {
                return deferred.resolve(new BBModel.BBCollection(collection));
            }, function () {
                return deferred.reject();
            });

            return deferred.promise;
        };

        return BBCollection;
    }(BaseModel);
});
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:Company
 *
 * @description
 * Representation of an Company Object
 *
 * @constructor
 * @param {HALobject=} data A HAL object to initialise the company from
 *
 * @property {string} name The company name
 * @property {string} description The company description
 * @property {string} country_code the Country code for thie company
 * @property {string} currency_code A CCY for this company
 * @property {string} reference A custom external reference for the company
 * @property {integer} id The company ID
 * @property {boolean} live If this company is set live
 * @property {array} companies An array of child companies if this is a parent company
 * @property {string} timezone The timezone for the business
 */ //


// helpful functions about a company
angular.module('BB.Models').factory("CompanyModel", function ($q, $log, BBModel, BaseModel, halClient, AppConfig, $sessionStorage, CompanyService) {
    return function (_BaseModel) {
        _inherits(Company, _BaseModel);

        function Company(data) {
            _classCallCheck(this, Company);

            // instantiate each child company as a hal resource
            // we'll set the @companies array to all companies - including grandchildren
            // and we'll have an array called child_companies that contains only direct ancesstors
            var _this = _possibleConstructorReturn(this, _BaseModel.call(this, data));

            if (_this.companies) {
                var all_companies = [];
                _this.child_companies = [];
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Array.from(_this.companies)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var comp = _step.value;

                        var c = new BBModel.Company(halClient.$parse(comp));
                        _this.child_companies.push(c);
                        if (c.companies) {
                            // if that company has it's own child companies
                            var _iteratorNormalCompletion2 = true;
                            var _didIteratorError2 = false;
                            var _iteratorError2 = undefined;

                            try {
                                for (var _iterator2 = Array.from(c.companies)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                    var child = _step2.value;

                                    all_companies.push(child);
                                }
                            } catch (err) {
                                _didIteratorError2 = true;
                                _iteratorError2 = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                        _iterator2.return();
                                    }
                                } finally {
                                    if (_didIteratorError2) {
                                        throw _iteratorError2;
                                    }
                                }
                            }
                        } else {
                            all_companies.push(c);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                _this.companies = all_companies;
            }
            return _this;
        }

        /***
         * @ngdoc method
         * @name getCompanyByRef
         * @methodOf BB.Models:Company
         * @description
         * Find a child company by reference
         *
         * @returns {promise} A promise for the child company
         */


        Company.prototype.getCompanyByRef = function getCompanyByRef(ref) {
            var defer = $q.defer();
            this.$get('companies').then(function (companies) {
                var company = _.find(companies, function (c) {
                    return c.reference === ref;
                });
                if (company) {
                    defer.resolve(company);
                } else {
                    defer.reject('No company for ref ' + ref);
                }
            }, function (err) {
                console.log('err ', err);
                return defer.reject(err);
            });
            return defer.promise;
        };

        /***
         * @ngdoc method
         * @name findChildCompany
         * @methodOf BB.Models:Company
         * @description
         * Find a child company by id
         *
         * @returns {object} The child company
         */


        Company.prototype.findChildCompany = function findChildCompany(id) {
            if (!this.companies) {
                return null;
            }
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = Array.from(this.companies)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var c = _step3.value;

                    if (c.id === parseInt(id)) {
                        return c;
                    }
                    if (c.ref && c.ref === String(id)) {
                        return c;
                    }
                }
                // failed to find by id - maybe by name ?
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }

            if (typeof id === "string") {
                var name = id.replace(/[\s\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|'’!<>;:,.~`=+-@£&%"]/g, '').toLowerCase();
                var _iteratorNormalCompletion4 = true;
                var _didIteratorError4 = false;
                var _iteratorError4 = undefined;

                try {
                    for (var _iterator4 = Array.from(this.companies)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                        c = _step4.value;

                        var cname = c.name.replace(/[\s\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|'’!<>;:,.~`=+-@£&%"]/g, '').toLowerCase();
                        if (name === cname) {
                            return c;
                        }
                    }
                } catch (err) {
                    _didIteratorError4 = true;
                    _iteratorError4 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion4 && _iterator4.return) {
                            _iterator4.return();
                        }
                    } finally {
                        if (_didIteratorError4) {
                            throw _iteratorError4;
                        }
                    }
                }
            }
            return null;
        };

        /***
         * @ngdoc method
         * @name getSettings
         * @methodOf BB.Models:Company
         * @description
         * Get settings company
         *
         * @returns {promise} A promise for settings company
         */


        Company.prototype.getSettings = function getSettings() {
            var _this2 = this;

            var def = $q.defer();
            if (this.settings) {
                def.resolve(this.settings);
            } else {
                if (this.$has('settings')) {
                    this.$get('settings').then(function (set) {
                        _this2.settings = new BBModel.CompanySettings(set);
                        def.resolve(_this2.settings);
                    });
                } else {
                    def.reject("Company has no settings");
                }
            }
            return def.promise;
        };

        /***
         * @ngdoc method
         * @name pusherSubscribe
         * @methodOf BB.Models:Company
         * @description
         * Push subscribe for company
         *
         * @returns {object} Subscriber company
         */


        Company.prototype.pusherSubscribe = function pusherSubscribe(callback, options) {
            if (options == null) {
                options = {};
            }
            if (typeof Pusher !== 'undefined' && Pusher !== null && this.pusher == null) {
                if (!this.$has('pusher')) {
                    return;
                }
                this.pusher = new Pusher('c8d8cea659cc46060608', {
                    encrypted: options.hasOwnProperty('encrypted') ? options.encrypted : true,
                    authEndpoint: this.$link('pusher').href,
                    auth: {
                        headers: {
                            'App-Id': AppConfig.appId,
                            'App-Key': AppConfig.appKey,
                            'Auth-Token': $sessionStorage.getItem('auth_token')
                        }
                    }
                });
            }

            var channelName = 'private-c' + this.id + '-w' + this.numeric_widget_id;

            // Nuke the channel if it exists, must be done if this is to be used in multiple pages
            // this is being delt differently in the newer implementation
            if (this.pusher.channel(channelName) != null) {
                this.pusher.unsubscribe(channelName);
            }

            this.pusher_channel = this.pusher.subscribe(channelName);
            this.pusher_channel.bind('booking', callback);
            this.pusher_channel.bind('cancellation', callback);
            return this.pusher_channel.bind('updating', callback);
        };

        /***
         * @ngdoc method
         * @name getPusherChannel
         * @methodOf BB.Models:Company
         *
         * @returns {object} Pusher channel
         */


        Company.prototype.getPusherChannel = function getPusherChannel(model, options) {
            if (options == null) {
                options = {};
            }
            if (!this.pusher) {
                if (!this.$has('pusher')) {
                    return;
                }
                this.pusher = new Pusher('c8d8cea659cc46060608', {
                    encrypted: options.hasOwnProperty('encrypted') ? options.encrypted : true,
                    authEndpoint: this.$link('pusher').href,
                    auth: {
                        headers: {
                            'App-Id': AppConfig.appId,
                            'App-Key': AppConfig.appKey,
                            'Auth-Token': $sessionStorage.getItem('auth_token')
                        }
                    }
                });
            }
            if (this.$has(model)) {
                var channelName = this.$href(model);
                channelName = channelName.replace(/https?:\/\//, '').replace(/\//g, '-').replace(/:/g, '_');
                if (this.pusher.channel(channelName)) {
                    return this.pusher.channel(channelName);
                } else {
                    this.pusher.subscribe(channelName);
                    return this.pusher.channel(channelName);
                }
            }
        };

        Company.prototype.getOpeningHours = function getOpeningHours() {
            var _this3 = this;

            var openingHoursPromise = $q.defer();
            if (this.$has('opening_hours')) {
                this.$get('opening_hours').then(function (openingHours) {
                    _this3.openingHours = openingHours.openingHoursSpecification;
                    _this3.formatOpeningHoursSchema();
                    openingHoursPromise.resolve(_this3.openingHours);
                }, function (err) {
                    $log.info(err);
                    openingHoursPromise.reject(err);
                });
            }

            return openingHoursPromise.promise;
        };

        Company.prototype.formatOpeningHoursSchema = function formatOpeningHoursSchema() {
            if (!this.openingHours) return;
            this.openingHours.forEach(function (day) {
                // http://schema.org/Monday => monday
                day.dayKey = day.dayOfWeek.replace('http://schema.org/', '').toUpperCase();
                // create moment objects from time strings passed in format 'HH:mm:ss'
                if (day.opens) {
                    day.opens = moment(day.opens, 'HH:mm:ss');
                }

                if (day.closes) {
                    day.closes = moment(day.closes, 'HH:mm:ss');
                }
            });
        };

        Company.$query = function $query(company_id, options) {
            return CompanyService.query(company_id, options);
        };

        return Company;
    }(BaseModel);
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:CompanySettings
 *
 * @description
 * Representation of an CompanySettings Object
 */ //


angular.module('BB.Models').factory("CompanySettingsModel", function ($q, BBModel, BaseModel) {
  return function (_BaseModel) {
    _inherits(CompanySettings, _BaseModel);

    function CompanySettings() {
      _classCallCheck(this, CompanySettings);

      return _possibleConstructorReturn(this, _BaseModel.apply(this, arguments));
    }

    return CompanySettings;
  }(BaseModel);
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:Day
 *
 * @description
 * Representation of an Day Object
 *
 * @property {string} string_date The string date
 * @property {date} date Second The date
 */ //

angular.module('BB.Models').factory("DayModel", function ($q, BBModel, BaseModel, DayService) {
    return function (_BaseModel) {
        _inherits(Day, _BaseModel);

        function Day(data) {
            _classCallCheck(this, Day);

            var _this = _possibleConstructorReturn(this, _BaseModel.apply(this, arguments));

            _this.string_date = _this.date;
            _this.date = moment(_this.date);
            return _this;
        }

        /***
         * @ngdoc method
         * @name day
         * @methodOf BB.Models:Day
         * @description
         * Get day date
         *
         * @returns {date} The returned day
         */


        Day.prototype.day = function day() {
            return this.date.date();
        };

        /***
         * @ngdoc method
         * @name off
         * @methodOf BB.Models:Day
         * @description
         * Get off by month
         *
         * @returns {date} The returned off
         */


        Day.prototype.off = function off(month) {
            return this.date.month() !== month;
        };

        /***
         * @ngdoc method
         * @name class
         * @methodOf BB.Models:Day
         * @description
         * Get class in according of month
         *
         * @returns {string} The returned class
         */


        Day.prototype.class = function _class(month) {
            var str = "";
            if (this.date.month() < month) {
                str += "off off-prev";
            }
            if (this.date.month() > month) {
                str += "off off-next";
            }
            if (this.spaces === 0) {
                str += " not-avail";
            }
            return str;
        };

        Day.$query = function $query(prms) {
            return DayService.query(prms);
        };

        return Day;
    }(BaseModel);
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

angular.module('BB.Models').factory("DealModel", function ($q, BBModel, BaseModel, DealService) {
    return function (_BaseModel) {
        _inherits(Deal, _BaseModel);

        function Deal() {
            _classCallCheck(this, Deal);

            return _possibleConstructorReturn(this, _BaseModel.apply(this, arguments));
        }

        Deal.$query = function $query(company) {
            return DealService.query(company);
        };

        return Deal;
    }(BaseModel);
});
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:Event
 *
 * @description
 * This is the event object returned by the API
 *
 * @property {integer} id The event id
 * @property {date} datetime The event date and time
 * @property {string} description Description of the event
 * @property {integer} status Status of the event
 * @property {integer} spaces_booked The booked spaces
 * @property {integer} duration Duration of the event
 */ //


angular.module('BB.Models').factory("EventModel", function ($q, BBModel, BaseModel, DateTimeUtilitiesService, EventService, $translate) {
    return function (_BaseModel) {
        _inherits(Event, _BaseModel);

        function Event(data) {
            _classCallCheck(this, Event);

            var _this = _possibleConstructorReturn(this, _BaseModel.call(this, data));

            _this.date = moment.parseZone(_this.datetime);
            _this.time = new BBModel.TimeSlot({ time: DateTimeUtilitiesService.convertMomentToTime(_this.date) });
            if (_this.duration) {
                _this.end_datetime = _this.date.clone().add(_this.duration, 'minutes');
            }
            _this.date_unix = _this.date.unix();
            return _this;
        }

        /***
         * @ngdoc method
         * @name getGroup
         * @methodOf BB.Models:Event
         * @description
         * Get event groups
         *
         * @returns {promise} A promise for the group event
         */


        Event.prototype.getGroup = function getGroup() {
            var _this2 = this;

            var defer = $q.defer();
            if (this.group) {
                defer.resolve(this.group);
            } else if (this.$has('event_groups') || this.$has('event_group')) {
                var event_group = 'event_group';
                if (this.$has('event_groups')) {
                    event_group = 'event_groups';
                }
                this.$get(event_group).then(function (group) {
                    _this2.group = new BBModel.EventGroup(group);
                    return defer.resolve(_this2.group);
                }, function (err) {
                    return defer.reject(err);
                });
            } else {
                defer.reject("No event group");
            }
            return defer.promise;
        };

        /***
         * @ngdoc method
         * @name getGroup
         * @methodOf BB.Models:Event
         * @description
         * Get the chains of the event
         *
         * @returns {promise} A promise for the chains event
         */


        Event.prototype.getChain = function getChain(params) {
            var _this3 = this;

            var defer = $q.defer();
            if (this.chain) {
                defer.resolve(this.chain);
            } else {
                if (this.$has('event_chains') || this.$has('event_chain')) {
                    var event_chain = 'event_chain';
                    if (this.$has('event_chains')) {
                        event_chain = 'event_chains';
                    }
                    this.$get(event_chain, params).then(function (chain) {
                        _this3.chain = new BBModel.EventChain(chain);
                        return defer.resolve(_this3.chain);
                    });
                } else {
                    defer.reject("No event chain");
                }
            }
            return defer.promise;
        };

        /***
         * @ngdoc method
         * @name getDuration
         * @methodOf BB.Models:Event
         * @description
         * Get duration of the event chains
         *
         * @returns {promise} A promise for duration of the event
         */


        Event.prototype.getDuration = function getDuration() {
            var _this4 = this;

            var defer = new $q.defer();
            if (this.duration) {
                defer.resolve(this.duration);
            } else {
                this.getChain().then(function (chain) {
                    _this4.duration = chain.duration;
                    return defer.resolve(_this4.duration);
                });
            }
            return defer.promise;
        };

        /***
         * @ngdoc method
         * @name getDescription
         * @methodOf BB.Models:Event
         * @description
         * Get duration of the event
         *
         * @returns {object} The returned description
         */


        Event.prototype.getDescription = function getDescription() {
            return this.getChain().description;
        };

        /***
         * @ngdoc method
         * @name getColour
         * @methodOf BB.Models:Event
         * @description
         * Get the colour
         *
         * @returns {string} The returned colour
         */


        Event.prototype.getColour = function getColour() {
            if (this.getGroup()) {
                return this.getGroup().colour;
            } else {
                return "#FFFFFF";
            }
        };

        /***
         * @ngdoc method
         * @name getPounds
         * @methodOf BB.Models:Event
         * @description
         * Get pounts
         *
         * @returns {integer} The returned pounts
         */


        Event.prototype.getPounds = function getPounds() {
            if (this.chain) {
                return Math.floor(this.getPrice()).toFixed(0);
            }
        };

        /***
         * @ngdoc method
         * @name getPrice
         * @methodOf BB.Models:Event
         * @description
         * Get price
         *
         * @returns {integer} The returned price
         */


        Event.prototype.getPrice = function getPrice() {
            return 0;
        };

        /***
         * @ngdoc method
         * @name getPence
         * @methodOf BB.Models:Event
         * @description
         * Get price
         *
         * @returns {integer} The returned pence
         */


        Event.prototype.getPence = function getPence() {
            if (this.chain) {
                return (this.getPrice() % 1).toFixed(2).slice(-2);
            }
        };

        /***
         * @ngdoc method
         * @name getNumBooked
         * @methodOf BB.Models:Event
         * @description
         * Get the number booked
         *
         * @returns {object} The returned number booked
         */


        Event.prototype.getNumBooked = function getNumBooked() {
            return this.spaces_blocked + this.spaces_booked + this.spaces_reserved + this.spaces_held;
        };

        /***
         * @ngdoc method
         * @name getSpacesLeft
         * @methodOf BB.Models:Event
         * @description
         * Get the number of spaces left (possibly limited by a specific ticket pool)
         *
         * @returns {object} The returned spaces left
         */


        Event.prototype.getSpacesLeft = function getSpacesLeft(pool) {
            if (pool == null) {
                pool = null;
            }
            if (pool && this.ticket_spaces && this.ticket_spaces[pool]) {
                return this.ticket_spaces[pool].left;
            } else {
                var x = this.num_spaces - this.getNumBooked();
                if (x < 0) {
                    return 0;
                }
                return x;
            }
        };

        /***
         * @ngdoc method
         * @name getWaitSpacesLeft
         * @methodOf BB.Models:Event
         * @description
         * Get the number of waitlist spaces left (possibly limited by a specific ticket pool)
         *
         * @returns {object} The returned spaces left
         */


        Event.prototype.getWaitSpacesLeft = function getWaitSpacesLeft() {
            var wait = this.chain.waitlength;
            if (!wait) {
                wait = 0;
            }
            wait = wait - this.spaces_wait;
            if (wait <= 0) {
                return 0;
            }

            return wait;
        };

        /***
         * @ngdoc method
         * @name hasSpace
         * @methodOf BB.Models:Event
         * @description
         * Checks if this considered a valid space
         *
         * @returns {boolean} If this is a valid space
         */


        Event.prototype.hasSpace = function hasSpace() {
            return this.getSpacesLeft() > 0;
        };

        /***
         * @ngdoc method
         * @name hasWaitlistSpace
         * @methodOf BB.Models:Event
         * @description
         * Checks if this considered a valid waiting list space
         *
         * @returns {boolean} If this is a valid waiting list space
         */


        Event.prototype.hasWaitlistSpace = function hasWaitlistSpace() {
            return this.getSpacesLeft() <= 0 && this.getChain().waitlength > this.spaces_wait;
        };

        /***
         * @ngdoc method
         * @name getRemainingDescription
         * @methodOf BB.Models:Event
         * @description
         * Get the remaining description
         *
         * @returns {object} The returned remaining description
         */


        Event.prototype.getRemainingDescription = function getRemainingDescription() {
            var left = this.getSpacesLeft();
            if (left > 0 && left < 3) {
                return $translate.instant("CORE.EVENT.SPACES_LEFT", { N: left }, 'messageformat');
            }
            if (this.hasWaitlistSpace()) {
                return $translate.instant("CORE.EVENT.JOIN_WAITLIST");
            }
            return "";
        };

        /***
         * @ngdoc method
         * @name select
         * @methodOf BB.Models:Event
         * @description
         * Checks is this considered a selected
         *
         * @returns {boolean} If this is a selected
         */


        Event.prototype.select = function select() {
            return this.selected = true;
        };

        /***
         * @ngdoc method
         * @name unselect
         * @methodOf BB.Models:Event
         * @description
         * Unselect if is selected
         *
         * @returns {boolean} If this is a unselected
         */


        Event.prototype.unselect = function unselect() {
            if (this.selected) {
                return delete this.selected;
            }
        };

        /***
         * @ngdoc method
         * @name prepEvent
         * @methodOf BB.Models:Event
         * @description
         * Prepare the event
         *
         * @returns {promise} A promise for the event
         */


        Event.prototype.prepEvent = function prepEvent(params) {
            var _this5 = this;

            // build out some useful event stuff
            var def = $q.defer();
            this.getChain(params).then(function () {

                if (_this5.chain.$has('address')) {
                    _this5.chain.$getAddress().then(function (address) {
                        return _this5.chain.address = address;
                    });
                }

                return _this5.chain.getTickets().then(function (tickets) {
                    _this5.tickets = tickets;

                    _this5.price_range = {};
                    if (tickets && tickets.length > 0) {
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = Array.from(_this5.tickets)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var ticket = _step.value;

                                if (!_this5.price_range.from || _this5.price_range.from && ticket.price < _this5.price_range.from) {
                                    _this5.price_range.from = ticket.price;
                                }
                                if (!_this5.price_range.to || _this5.price_range.to && ticket.price > _this5.price_range.to) {
                                    _this5.price_range.to = ticket.price;
                                }
                                ticket.old_price = ticket.price;
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return) {
                                    _iterator.return();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                    } else {
                        _this5.price_range.from = _this5.price;
                        _this5.price_range.to = _this5.price;
                    }

                    _this5.ticket_prices = _.indexBy(tickets, 'name');

                    return def.resolve(_this5);
                });
            });
            return def.promise;
        };

        /***
         * @ngdoc method
         * @name updatePrice
         * @methodOf BB.Models:Event
         * @description
         * Update price for the ticket
         *
         * @returns {object} The returned update price
         */


        Event.prototype.updatePrice = function updatePrice() {
            return Array.from(this.tickets).map(function (ticket) {
                return ticket.pre_paid_booking_id ? ticket.price = 0 : ticket.price = ticket.old_price;
            });
        };

        Event.$query = function $query(company, params) {
            return EventService.query(company, params);
        };

        Event.$summary = function $summary(company, params) {
            return EventService.summary(company, params);
        };

        /***
         * @ngdoc method
         * @name numTicketsSelected
         * @methodOf BB.Models:Event
         * @description
         *
         *
         * @returns {object} get number of tickets selected
         */


        Event.prototype.numTicketsSelected = function numTicketsSelected() {
            var num = 0;
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = Array.from(this.tickets)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var ticket = _step2.value;

                    num += ticket.qty;
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            return num;
        };

        return Event;
    }(BaseModel);
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:EventChain
 *
 * @description
 * Representation of an EventChain Object
 *
 * @property {integer} id The id of event chain
 * @property {string} name Name of the event chain
 * @property {string} description The description of the event
 * @property {integer} capacity_view The capacity view
 * @property {date} start_date Event chain start date
 * @property {date} finish_date Event chain finish date
 * @property {integer} price The price of the event chain
 * @property {string} ticket_type Type of the ticket
 * @property {boolean} course Verify is couse exist or not
 */ //


angular.module('BB.Models').factory("EventChainModel", function ($q, BBModel, BaseModel, EventChainService, $translate) {
    return function (_BaseModel) {
        _inherits(EventChain, _BaseModel);

        function EventChain(data) {
            _classCallCheck(this, EventChain);

            var _this = _possibleConstructorReturn(this, _BaseModel.apply(this, arguments));

            _this.capacity_view = _this.setCapacityView(_this.capacity_view);
            if (_this.start_date) {
                _this.start_date = moment(_this.start_date);
            }
            if (_this.end_date) {
                _this.end_date = moment(_this.end_date);
            }
            return _this;
        }

        EventChain.prototype.setCapacityView = function setCapacityView(capacity_view) {
            var capacity_view_str = void 0;
            switch (capacity_view) {
                case 0:
                    capacity_view_str = "DO_NOT_DISPLAY";
                    break;
                case 1:
                    capacity_view_str = "NUM_SPACES";
                    break;
                case 2:
                    capacity_view_str = "NUM_SPACES_LEFT";
                    break;
                case 3:
                    capacity_view_str = "NUM_SPACES_AND_SPACES_LEFT";
                    break;
                default:
                    capacity_view_str = "NUM_SPACES_AND_SPACES_LEFT";
            }
            return capacity_view_str;
        };

        EventChain.prototype.name = function name() {
            //comment
            return this._data.name;
        };

        /***
         * @ngdoc method
         * @name isSingleBooking
         * @methodOf BB.Models:EventChain
         * @description
         * Verify if is a single booking
         *
         * @returns {array} If maximum number of bookings is equal with 1 and not have an ticket sets
         */


        EventChain.prototype.isSingleBooking = function isSingleBooking() {
            return this.max_num_bookings === 1 && !this.$has('ticket_sets');
        };

        /***
         * @ngdoc method
         * @name hasTickets
         * @methodOf BB.Models:EventChain
         * @description
         * Checks if this is considered a valid tickets
         *
         * @returns {boolean} If this have an ticket sets
         */


        EventChain.prototype.hasTickets = function hasTickets() {
            return this.$has('ticket_sets');
        };

        /***
         * @ngdoc method
         * @name getTickets
         * @methodOf BB.Models:EventChain
         * @description
         * Get the tickets of the event
         *
         * @returns {promise} A promise for the tickets
         */


        EventChain.prototype.getTickets = function getTickets() {
            var _this2 = this;

            var def = $q.defer();
            if (this.tickets) {
                def.resolve(this.tickets);
            } else {
                if (this.$has('ticket_sets')) {
                    this.$get('ticket_sets').then(function (tickets) {
                        _this2.tickets = [];
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = Array.from(tickets)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var ticket = _step.value;

                                // mark that this ticket is part of ticket set so that the range can be calculated correctly
                                ticket.ticket_set = true;
                                _this2.tickets.push(new BBModel.EventTicket(ticket));
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return) {
                                    _iterator.return();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }

                        _this2.adjustTicketsForRemaining();
                        return def.resolve(_this2.tickets);
                    });
                } else {
                    this.tickets = [new BBModel.EventTicket({
                        name: $translate.instant('COMMON.TERMINOLOGY.ADMITTANCE'),
                        min_num_bookings: 1,
                        max_num_bookings: this.max_num_bookings,
                        type: "normal",
                        price: this.price
                    })];
                    this.adjustTicketsForRemaining();
                    def.resolve(this.tickets);
                }
            }
            return def.promise;
        };

        /***
         * @ngdoc method
         * @name adjustTicketsForRemaining
         * @methodOf BB.Models:EventChain
         * @description
         * Adjust the number of tickets that can be booked due to changes in the number of remaining spaces for each ticket set
         *
         * @returns {object} The returned adjust tickets for remaining
         */


        EventChain.prototype.adjustTicketsForRemaining = function adjustTicketsForRemaining() {
            var _this3 = this;

            if (this.tickets) {
                return function () {
                    var result = [];
                    var _iteratorNormalCompletion2 = true;
                    var _didIteratorError2 = false;
                    var _iteratorError2 = undefined;

                    try {
                        for (var _iterator2 = Array.from(_this3.tickets)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                            _this3.ticket = _step2.value;

                            result.push(_this3.ticket.max_spaces = _this3.spaces);
                        }
                    } catch (err) {
                        _didIteratorError2 = true;
                        _iteratorError2 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                _iterator2.return();
                            }
                        } finally {
                            if (_didIteratorError2) {
                                throw _iteratorError2;
                            }
                        }
                    }

                    return result;
                }();
            }
        };

        EventChain.$query = function $query(prms) {
            return EventChainService.query(prms);
        };

        return EventChain;
    }(BaseModel);
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:EventGroup
 *
 * @description
 * Representation of an EventGroup Object
 *
 * @property {integer} total_entries The total of entries in  event groupst
 * @property {array} event_chains An array with items of the event
 */ //


angular.module('BB.Models').factory("EventGroupModel", function ($q, BBModel, BaseModel) {
    return function (_BaseModel) {
        _inherits(EventGroup, _BaseModel);

        function EventGroup() {
            _classCallCheck(this, EventGroup);

            return _possibleConstructorReturn(this, _BaseModel.apply(this, arguments));
        }

        EventGroup.prototype.name = function name() {
            return this._data.name;
        };

        EventGroup.prototype.colour = function colour() {
            return this._data.colour;
        };

        return EventGroup;
    }(BaseModel);
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:EventSequence
 *
 * @description
 * Representation of an EventSequence Object
 *
 * @property {integer} total_entries The total of entries in  event groupst
 * @property {array} event_chains An array with items of the event
 */ //


angular.module('BB.Models').factory("EventSequenceModel", function ($q, BBModel, BaseModel) {
    return function (_BaseModel) {
        _inherits(EventSequence, _BaseModel);

        function EventSequence() {
            _classCallCheck(this, EventSequence);

            return _possibleConstructorReturn(this, _BaseModel.apply(this, arguments));
        }

        EventSequence.prototype.name = function name() {
            return this._data.name;
        };

        return EventSequence;
    }(BaseModel);
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:EventTicket
 *
 * @description
 * Representation of an EventTicket Object
 *
 * @property {integer} max The maximum of the event ticket
 * @property {integer} max_num_bookings The maximum number of the bookings
 * @property {integer} max_spaces The maximum spaces of the evenet
 * @property {integer} counts_as The counts as
 * @property {string} pool_name The pool name
 * @property {string} name The name
 * @property {string} min_num_bookings The minimum number of the bookings
 * @property {string} qty The quantity of the event ticket
 * @property {string} totalQty The total quantity of the event ticket
 */ //


angular.module('BB.Models').factory("EventTicketModel", function ($q, BBModel, BaseModel) {
    return function (_BaseModel) {
        _inherits(EventTicket, _BaseModel);

        function EventTicket(data) {
            _classCallCheck(this, EventTicket);

            var _this = _possibleConstructorReturn(this, _BaseModel.call(this, data));

            _this.max = _this.max_num_bookings;

            // max_spaces is the total number of spaces reported by the event chain
            // adjust max if total spaces is less than max_num_bookings
            if (_this.max_spaces) {
                var ms = _this.max_spaces;
                // count_as defines the number of spaces a ticket uses
                if (_this.counts_as) {
                    ms = _this.max_spaces / _this.counts_as;
                }
                if (ms < max) {
                    _this.max = ms;
                }
            }
            return _this;
        }

        /***
         * @ngdoc method
         * @name fullName
         * @methodOf BB.Models:EventTicket
         * @description
         * Get the full name
         *
         * @returns {object} The returned full name
         */


        EventTicket.prototype.fullName = function fullName() {
            if (this.pool_name) {
                return this.pool_name + " - " + this.name;
            }
            return this.name;
        };

        /***
         * @ngdoc method
         * @name getRange
         * @methodOf BB.Models:EventTicket
         * @description
         * Get the range between minimum number of bookings and the maximum number of bookings
         *
         * @returns {array} The returned range
         */


        EventTicket.prototype.getRange = function getRange(event, cap) {

            if (!event) {
                return;
            }

            // if not simple ticket, pass pool id to event methods
            var pool = null;
            if (this.ticket_set) {
                pool = this.pool_id;
            }

            var max = this.getMax(event, pool, cap);
            var min = max <= this.min_num_bookings ? max : this.min_num_bookings;

            return [].concat(__range__(min, max, true));
        };

        /***
         * @ngdoc method
         * @name getMax
         * @methodOf BB.Models:EventTicket
         * @description
         * Get the maximum - this looks at an optional cap, the maximum available and potential a running count of tickets already selected (from passing in the event being booked)
         *
         * @returns {Integer} The max number of tickets that can be selected
         */


        EventTicket.prototype.getMax = function getMax(ev, pool, cap) {

            var spaces_left = void 0,
                wait_spaces = void 0;
            if (pool == null) {
                pool = null;
            }
            if (cap == null) {
                cap = null;
            }
            var isAvailable = function isAvailable(event) {
                _.each(event.ticket_spaces, function (ts) {
                    if (ts.left <= 0) {
                        return false;
                    }
                });
                return true;
            };

            if (!ev) {
                return 0;
            }

            // only show wait spaces if no spaces available in any pool
            if (!isAvailable(ev) || ev.getSpacesLeft() <= 0) {
                spaces_left = ev.getWaitSpacesLeft();
                wait_spaces = true;
            } else {
                spaces_left = ev.getSpacesLeft(pool);
            }

            var live_max = spaces_left <= this.max ? spaces_left : this.max;

            var used = 0;

            // count number of spaces used across the same ticket pool (except when spaces_left are waitlist ones)
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = Array.from(ev.tickets)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var ticket = _step.value;

                    if (ticket.pool_id === this.pool_id || wait_spaces) {
                        used += ticket.totalQty();
                    }
                }

                // subtract self from used space count
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            if (this.qty) {
                used = used - this.totalQty();
            }

            // adjust number of spaces used by count_as
            if (this.counts_as) {
                used = Math.ceil(used / this.counts_as);
            }

            live_max = live_max - used;
            if (live_max < 0) {
                live_max = 0;
            }

            var left = left - used;
            if (left < 0) {
                left = 0;
            }

            // use ticket cap if set
            if (this.cap) {
                cap = this.cap;
            }

            if (!cap || cap > left) {
                cap = left;
            }

            // adjust max by cap if it's lower
            if (cap) {
                var c = cap;
                if (this.counts_as) {
                    c = cap / this.counts_as;
                }
                if (c < live_max) {
                    return c;
                }
            }

            return live_max;
        };

        /***
         * @ngdoc method
         * @name totalQty
         * @methodOf BB.Models:EventTicket
         * @description
         * Get the total quantity of the event ticket
         *
         * @returns {array} The returned total quantity
         */


        EventTicket.prototype.totalQty = function totalQty() {
            if (!this.qty) {
                return 0;
            }
            if (!this.counts_as) {
                return this.qty;
            }
            return this.qty * this.counts_as;
        };

        /***
         * @ngdoc method
         * @name add
         * @methodOf BB.Models:EventTicket
         * @description
         * Add to the a quantity a new value
         *
         * @returns {array} The returned new quantity added
         */


        EventTicket.prototype.add = function add(value) {
            if (!this.qty) {
                this.qty = 0;
            }
            this.qty = parseInt(this.qty);

            if (angular.isNumber(this.qty) && this.qty >= this.max && value > 0 || this.qty === 0 && value < 0) {
                return;
            }
            return this.qty += value;
        };

        /***
         * @ngdoc method
         * @name subtract
         * @methodOf BB.Models:EventTicket
         * @description
         * Subtract a value from the quantity
         *
         * @returns {array} The returned substract
         */


        EventTicket.prototype.subtract = function subtract(value) {
            return this.add(-value);
        };

        return EventTicket;
    }(BaseModel);
});

function __range__(left, right, inclusive) {
    var range = [];
    var ascending = left < right;
    var end = !inclusive ? right : ascending ? right + 1 : right - 1;
    for (var i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {
        range.push(i);
    }
    return range;
}
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

angular.module('BB.Models').factory("ExternalPurchaseModel", function ($q, BBModel, BaseModel) {
  return function (_BaseModel) {
    _inherits(ExternalPurchase, _BaseModel);

    function ExternalPurchase() {
      _classCallCheck(this, ExternalPurchase);

      return _possibleConstructorReturn(this, _BaseModel.apply(this, arguments));
    }

    return ExternalPurchase;
  }(BaseModel);
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:Image
 *
 * @description
 * Representation of an Image Object
 *
 * @property {array} iamges An array with event images
 */ //


angular.module('BB.Models').factory("ImageModel", function ($q, $filter, BBModel, BaseModel) {
    return function (_BaseModel) {
        _inherits(Image, _BaseModel);

        function Image(data) {
            _classCallCheck(this, Image);

            return _possibleConstructorReturn(this, _BaseModel.call(this, data));
        }

        return Image;
    }(BaseModel);
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:Items
 *
 * @description
 * Representation of an Items Object
 */ //


angular.module('BB.Models').factory("ItemModel", function ($q, $filter, BBModel, BaseModel) {
    return function (_BaseModel) {
        _inherits(Item, _BaseModel);

        function Item(data) {
            _classCallCheck(this, Item);

            return _possibleConstructorReturn(this, _BaseModel.call(this, data));
        }

        return Item;
    }(BaseModel);
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:ItemDetails
 *
 * @description
 * Representation of an ItemDetails Object
 *
 * @property {string} self The self
 * @property {array} questions The questions
 * @property {array} survey_questions The survey questions
 * @property {string} hasQuestions Has questions about the item details
 * @property {string} hasSurveyQuestions Has survey questions about the item details
 * @property {string} checkConditionalQuestions Check conditional questions about the item details
 */ //


angular.module('BB.Models').factory("ItemDetailsModel", function ($q, $bbug, ItemDetailsService, BBModel, BaseModel) {
    return function (_BaseModel) {
        _inherits(ItemDetails, _BaseModel);

        function ItemDetails(data) {
            _classCallCheck(this, ItemDetails);

            var _this = _possibleConstructorReturn(this, _BaseModel.call(this, data));

            _this._data = data;
            if (_this._data) {
                _this.self = _this._data.$href("self");
            }
            _this.questions = [];
            _this.survey_questions = [];
            if (data) {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Array.from(data.questions)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var q = _step.value;

                        if (q.outcome === false) {
                            if (data.currency_code) {
                                q.currency_code = data.currency_code;
                            }
                            _this.questions.push(new BBModel.Question(q));
                        } else {
                            _this.survey_questions.push(new BBModel.SurveyQuestion(q));
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
            _this.hasQuestions = _this.questions.length > 0;
            _this.hasSurveyQuestions = _this.survey_questions.length > 0;
            return _this;
        }

        /***
         * @ngdoc method
         * @name questionPrice
         * @methodOf BB.Models:ItemDetails
         * @description
         * Get question about price in according of quantity
         *
         * @returns {integer} The returned price
         */


        ItemDetails.prototype.questionPrice = function questionPrice(qty) {
            if (!qty) {
                qty = 1;
            }
            this.checkConditionalQuestions();
            var price = 0;
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = Array.from(this.questions)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var q = _step2.value;

                    price += q.selectedPriceQty(qty);
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            return price;
        };

        /***
         * @ngdoc method
         * @name checkConditionalQuestions
         * @methodOf BB.Models:ItemDetails
         * @description
         * Checks if exist conditional questions
         *
         * @returns {boolean} The returned existing conditional questions
         */


        ItemDetails.prototype.checkConditionalQuestions = function checkConditionalQuestions() {
            return BBModel.Question.$checkConditionalQuestions(this.questions);
        };

        /***
         * @ngdoc method
         * @name getPostData
         * @methodOf BB.Models:ItemDetails
         * @description
         * Get data
         *
         * @returns {array} The returned data
         */


        ItemDetails.prototype.getPostData = function getPostData() {
            var data = [];
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = Array.from(this.questions)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var q = _step3.value;

                    if (q.currentlyShown) {
                        data.push(q.getPostData());
                    }
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }

            return data;
        };

        /***
         * @ngdoc method
         * @name setAnswers
         * @methodOf BB.Models:ItemDetails
         * @description
         * Load the answers from an answer set - probably from loading an existing basket item
         *
         * @returns {object} The returned answers set
         */
        // load the answers from an answer set - probably from loading an existing basket item


        ItemDetails.prototype.setAnswers = function setAnswers(answers) {
            // turn answers into a hash
            var ahash = {};
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
                for (var _iterator4 = Array.from(answers)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                    var a = _step4.value;

                    ahash[a.id] = a;
                }
            } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion4 && _iterator4.return) {
                        _iterator4.return();
                    }
                } finally {
                    if (_didIteratorError4) {
                        throw _iteratorError4;
                    }
                }
            }

            var _iteratorNormalCompletion5 = true;
            var _didIteratorError5 = false;
            var _iteratorError5 = undefined;

            try {
                for (var _iterator5 = Array.from(this.questions)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                    var q = _step5.value;

                    if (ahash[q.id]) {
                        // if we have answer for it
                        q.answer = ahash[q.id].answer;
                    }
                }
            } catch (err) {
                _didIteratorError5 = true;
                _iteratorError5 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion5 && _iterator5.return) {
                        _iterator5.return();
                    }
                } finally {
                    if (_didIteratorError5) {
                        throw _iteratorError5;
                    }
                }
            }

            return this.checkConditionalQuestions();
        };

        /***
         * @ngdoc method
         * @name getQuestion
         * @methodOf BB.Models:ItemDetails
         * @description
         * Get question about item details by id
         *
         * @returns {object} The returned question
         */


        ItemDetails.prototype.getQuestion = function getQuestion(id) {
            return _.findWhere(this.questions, { id: id });
        };

        ItemDetails.$query = function $query(prms) {
            return ItemDetailsService.query(prms);
        };

        return ItemDetails;
    }(BaseModel);
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:Items
 *
 * @description
 * Representation of an Items Object
 */ //


angular.module('BB.Models').factory("ItemsModel", function ($q, $filter, BBModel, BaseModel) {
    return function (_BaseModel) {
        _inherits(Items, _BaseModel);

        function Items(data) {
            _classCallCheck(this, Items);

            return _possibleConstructorReturn(this, _BaseModel.call(this, data));
        }

        return Items;
    }(BaseModel);
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

angular.module('BB.Models').factory("LoginModel", function ($q, LoginService, BBModel, BaseModel) {
    return function (_BaseModel) {
        _inherits(Login, _BaseModel);

        function Login(data) {
            _classCallCheck(this, Login);

            return _possibleConstructorReturn(this, _BaseModel.call(this, data));
        }

        Login.$companyLogin = function $companyLogin(company, params, form) {
            return LoginService.companyLogin(company, params, form);
        };

        Login.$login = function $login(form, options) {
            return LoginService.login(form, options);
        };

        Login.$FBLogin = function $FBLogin(company, params) {
            return LoginService.FBLogin(company, params);
        };

        Login.$companyQuery = function $companyQuery(id) {
            return LoginService.companyQuery(id);
        };

        Login.$memberQuery = function $memberQuery(params) {
            return LoginService.memberQuery(params);
        };

        Login.$ssoLogin = function $ssoLogin(options, data) {
            return LoginService.ssoLogin(options, data);
        };

        Login.$isLoggedIn = function $isLoggedIn() {
            return LoginService.isLoggedIn();
        };

        Login.$setLogin = function $setLogin(member, persist) {
            return LoginService.setLogin(member, persist);
        };

        Login.$member = function $member() {
            return LoginService.member();
        };

        Login.$checkLogin = function $checkLogin() {
            return LoginService.checkLogin();
        };

        Login.$logout = function $logout() {
            return LoginService.logout();
        };

        Login.$FBLogout = function $FBLogout(options) {
            return LoginService.FBLogout(options);
        };

        Login.$sendPasswordReset = function $sendPasswordReset(company, params) {
            return LoginService.sendPasswordReset(company, params);
        };

        Login.$updatePassword = function $updatePassword(member, params) {
            return LoginService.updatePassword(member, params);
        };

        return Login;
    }(BaseModel);
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

angular.module('BB.Models').factory("MembershipLevelModel", function ($q, BBModel, BaseModel, MembershipLevelsService) {
    return function (_BaseModel) {
        _inherits(MembershipLevel, _BaseModel);

        function MembershipLevel() {
            _classCallCheck(this, MembershipLevel);

            return _possibleConstructorReturn(this, _BaseModel.apply(this, arguments));
        }

        MembershipLevel.prototype.$getMembershipLevels = function $getMembershipLevels(company) {
            return MembershipLevelsService.getMembershipLevels(company);
        };

        return MembershipLevel;
    }(BaseModel);
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:PackageItem
 *
 * @description
 * Representation of a PackageItem Object
 */ //

angular.module('BB.Models').factory("PackageItemModel", function ($q, PackageItemService, BBModel, BaseModel) {
    return function (_BaseModel) {
        _inherits(PackageItem, _BaseModel);

        function PackageItem() {
            _classCallCheck(this, PackageItem);

            return _possibleConstructorReturn(this, _BaseModel.apply(this, arguments));
        }

        PackageItem.$query = function $query(company) {
            return PackageItemService.query(company);
        };

        PackageItem.$getPackageServices = function $getPackageServices(package_item) {
            return PackageItemService.getPackageServices(package_item);
        };

        return PackageItem;
    }(BaseModel);
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/***
 * @ngdoc service
 * @name BB.Models:Service
 *
 * @description
 * Representation of an Pagination Object
 *
 * @property {integer} current_page The current page
 * @property {integer} page_size The number of items to show on each page
 * @property {integer} request_page_size The request page size. Defaults to page_size when not provided. This value must be a multiple of the page_size.
 * @property {integer} max_size Limit number for pagination size
 * @property {integer} num_pages The total number of pages
 * @property {integer} num_items The total number of items paginated
 * @property {integer} items The items to be paginated
 * @property {String} summary Summary of current page, i.e. 1 - 10 of 16
 *  
 *  <example module="BB">
 *    <file name="index.html">
 *   <div bb-api-url='https://uk.bookingbug.com'>
 *   <div bb-widget='{company_id:21}'>
 *     <div bb-pagination-example>
 *        <ul>
 *          <li ng-repeat="item in pagination.items | startFrom: (pagination.current_page - 1) * pagination.page_size | limitTo: pagination.page_size | orderBy: sort_by track by $index">
 *        </ul>
 *     </div>
 *     </div>
 *     </div>
 *   </file>
 *   <file name="script.js">
 *  angular.module('BB').directive('bbPaginationExample', function() {
*    return {
*      restrict: 'AE',
*      controller: function(BBModel, DataService) {
*       $scope.pagination = new BBModel.Pagination({
*         page_size: 10,
*         max_size: 5,
*         request_page_size: 10
*       });
*       $scope.getData = function(params, options) {
*         if (options == null) {
*           options = {};
*         }
*          $scope.params = {
*            per_page: $scope.pagination.request_page_size,
*           page: params.page || 1
*         };
*         return DataService.query($scope.params).then(function(result) {
*            if (options.add) {
*              return $scope.pagination.add(params.page, result.items);
*           } else {
*             return $scope.pagination.initialise(result.items, result.total_entries);
*           }
*         });
*       };
*        return $scope.pageChanged = function() {
*         var items_present, page_to_load, ref;
*         ref = $scope.pagination.update(), items_present = ref[0], page_to_load = ref[1];
*         if (!items_present) {
*            $scope.params.page = page_to_load;
*            return $scope.getData($scope.params, {
*              add: true
*           });
*         }
*       };
*     }
*   };
* });
 *       </file>
 *  </example>
 *
 */
angular.module('BB.Models').factory("PaginationModel", function ($translate) {
  return function () {

    /***
     * @ngdoc method
     * @name constructor
     * @methodOf BB.Models:Service
     * @description
     * Constructor method
     *
     * @param {object} Options hash used to set page_size and max_size
     */
    function Pagination(options) {
      _classCallCheck(this, Pagination);

      this.current_page = 1;
      this.page_size = options.page_size || 10;
      this.request_page_size = options.request_page_size || this.page_size;
      this.max_size = options.max_size || 5;
      this.num_pages = null;
      this.num_items = null;
      this.items = [];
    }

    /***
     * @ngdoc method
     * @name initialise
     * @methodOf BB.Models:Service
     * @description
     * Initiailises the pagination instance when first page has been retrieved
     *
     * @param {array} The first page of items returned by the API
     * @param {integer} The total number of items
     */


    Pagination.prototype.initialise = function initialise(items, total_items) {
      this.current_page = 1;
      this.items = items || [];
      this.num_items = total_items || 0;
      return this.update();
    };

    /***
     * @ngdoc method
     * @name update
     * @methodOf BB.Models:Service
     * @description
     * Updates the pagination summary when the page changes
     *
     * @returns {boolean} Flag to indicate if items in current page are present
     * @returns {integer} The page to load based on
     */


    Pagination.prototype.update = function update() {
      var start = (this.current_page - 1) * this.page_size + 1;
      var end = this.current_page * this.page_size;
      end = this.num_items < end ? this.num_items : end;
      var total = end >= 100 ? "100+" : end;
      this.summary = $translate.instant('CORE.PAGINATION.SUMMARY', { start: start, end: end, total: total });

      var page_to_load = Math.ceil(this.current_page * this.page_size / this.request_page_size);

      return [this.items[start - 1] != null, page_to_load];
    };

    /***
     * @ngdoc method
     * @name add
     * @methodOf BB.Models:Service
     * @description
     * Appends additional items (from subsequent data requests) to items array
     *
     * @param {integer} The page number of the data request
     * @param {array} The new items
     *
     */


    Pagination.prototype.add = function add(request_page, new_items) {
      var _this = this;

      var start = (request_page - 1) * this.request_page_size;
      return Array.from(new_items).map(function (item, index) {
        return _this.items[start + index] = item;
      });
    };

    return Pagination;
  }();
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:PaymentCallbacks
 *
 * @description
 * Representation of an PaymentCallbacks Object
 */ //


angular.module('BB.Models').factory("PaymentCallbacksModel", function ($q, $filter, BBModel, BaseModel) {
    return function (_BaseModel) {
        _inherits(PaymentCallbacks, _BaseModel);

        function PaymentCallbacks(data) {
            _classCallCheck(this, PaymentCallbacks);

            return _possibleConstructorReturn(this, _BaseModel.call(this, data));
        }

        return PaymentCallbacks;
    }(BaseModel);
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:Person
 *
 * @description
 * Representation of an Person Object
 *
 * @property {integer} id Person id
 * @property {string} name Person name
 * @property {string} description Person description
 * @property {hash} extra Any extra custom business information
 * @property {boolean} deleted Verify if person is deleted or not
 * @property {boolean} disabled Verify if person is disabled or not
 * @property {integer} order The person order
 */ //


angular.module('BB.Models').factory("PersonModel", function ($q, BBModel, BaseModel, PersonService) {
    return function (_BaseModel) {
        _inherits(Person, _BaseModel);

        function Person() {
            _classCallCheck(this, Person);

            return _possibleConstructorReturn(this, _BaseModel.apply(this, arguments));
        }

        /***
         * @ngdoc method
         * @name $query
         * @methodOf BB.Models:Person
         * @description
         * Static function that loads an array of people from a company object
         *
         * @returns {promise} A returned promise
         */
        Person.$query = function $query(company) {
            return PersonService.query(company);
        };

        return Person;
    }(BaseModel);
});
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:PrePaidBooking
 *
 * @description
 * Representation of an PrePaidBooking Object
 */ //


angular.module('BB.Models').factory("PrePaidBookingModel", function ($q, BBModel, BaseModel) {
    return function (_BaseModel) {
        _inherits(PrePaidBooking, _BaseModel);

        function PrePaidBooking(data) {
            _classCallCheck(this, PrePaidBooking);

            var _this = _possibleConstructorReturn(this, _BaseModel.call(this, data));

            if (_this.book_by) {
                _this.book_by = moment(_this.book_by);
            }
            if (_this.use_by) {
                _this.use_by = moment(_this.use_by);
            }
            if (_this.use_from) {
                _this.use_from = moment(_this.use_from);
            }
            // TODO remove once api updated to not return expired prepaid bookings
            _this.expired = _this.book_by && moment().isAfter(_this.book_by, 'day') || _this.use_by && moment().isAfter(_this.use_by, 'day') || false;
            return _this;
        }

        PrePaidBooking.prototype.checkValidity = function checkValidity(item) {
            if (this.service_id && item.service_id && this.service_id !== item.service_id) {
                return false;
            } else if (this.resource_id && item.resource_id && this.resource_id !== item.resource_id) {
                return false;
            } else if (this.person_id && item.person_id && this.person_id !== item.person_id) {
                return false;
            } else {
                return true;
            }
        };

        return PrePaidBooking;
    }(BaseModel);
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

angular.module('BB.Models').factory("ProductModel", function ($q, BBModel, BaseModel) {
  return function (_BaseModel) {
    _inherits(Product, _BaseModel);

    function Product() {
      _classCallCheck(this, Product);

      return _possibleConstructorReturn(this, _BaseModel.apply(this, arguments));
    }

    return Product;
  }(BaseModel);
});
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:PurchaseItem
 *
 * @description
 * Representation of an PurchaseItem Object
 *
 * @property {float} price Price of the purchase item
 * @property {float} paid Purchase item paid
 */ //


angular.module('BB.Models').factory("PurchaseItemModel", function ($q, BBModel, BaseModel) {
    return function (_BaseModel) {
        _inherits(PurchaseItem, _BaseModel);

        function PurchaseItem(data) {
            _classCallCheck(this, PurchaseItem);

            var _this = _possibleConstructorReturn(this, _BaseModel.call(this, data));

            _this.parts_links = {};
            if (data) {
                if (data.$has('service')) {
                    _this.parts_links.service = data.$href('service');
                }
                if (data.$has('resource')) {
                    _this.parts_links.resource = data.$href('resource');
                }
                if (data.$has('person')) {
                    _this.parts_links.person = data.$href('person');
                }
                if (data.$has('company')) {
                    _this.parts_links.company = data.$href('company');
                }
            }
            return _this;
        }

        /***
         * @ngdoc method
         * @name describe
         * @methodOf BB.Models:PurchaseItem
         * @description
         * Describe the item for purchase
         *
         * @returns {object} The returned describe
         */


        PurchaseItem.prototype.describe = function describe() {
            return this.get('describe');
        };

        /***
         * @ngdoc method
         * @name full_describe
         * @methodOf BB.Models:PurchaseItem
         * @description
         * Full description of the item purchase
         *
         * @returns {object} The returned full describe
         */


        PurchaseItem.prototype.full_describe = function full_describe() {
            return this.get('full_describe');
        };

        /***
         * @ngdoc method
         * @name hasPrice
         * @methodOf BB.Models:PurchaseItem
         * @description
         * Checks if the item for purchase have a price
         *
         * @returns {boolean} If the item for purchase have a price
         */


        PurchaseItem.prototype.hasPrice = function hasPrice() {
            return this.price && this.price > 0;
        };

        return PurchaseItem;
    }(BaseModel);
});
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:PurchaseTotal
 *
 * @description
 * Representation of an PurchaseTotal Object
 *
 * @property {float} total_price The total price of items
 * @property {float} price Price of items
 * @property {float} tax_payable_on_price The tax payable on price of the item
 * @property {float} due_now The due now
 */ //


angular.module('BB.Models').factory("PurchaseTotalModel", function ($q, BBModel, BaseModel, PurchaseService) {
    return function (_BaseModel) {
        _inherits(PurchaseTotal, _BaseModel);

        function PurchaseTotal(data) {
            _classCallCheck(this, PurchaseTotal);

            var _this = _possibleConstructorReturn(this, _BaseModel.call(this, data));

            _this.promise = _this._data.$get('purchase_items');
            _this.purchase_items = [];
            _this.promise.then(function (items) {
                return Array.from(items).map(function (item) {
                    return _this.purchase_items.push(new BBModel.PurchaseItem(item));
                });
            });
            if (_this._data.$has('client')) {
                var cprom = data.$get('client');
                cprom.then(function (client) {
                    return _this.client = new BBModel.Client(client);
                });
            }
            _this.created_at = moment.parseZone(_this.created_at);
            if (_this.time_zone) {
                _this.created_at.tz(_this.time_zone);
            }
            return _this;
        }

        /***
         * @ngdoc method
         * @name icalLink
         * @methodOf BB.Models:PurchaseTotal
         * @description
         * Get the icalLink
         *
         * @returns {object} The returned icalLink
         */


        PurchaseTotal.prototype.icalLink = function icalLink() {
            return this._data.$href('ical');
        };

        /***
         * @ngdoc method
         * @name webcalLink
         * @methodOf BB.Models:PurchaseTotal
         * @description
         * Get webcalLink
         *
         * @returns {object} The returned webcalLink
         */


        PurchaseTotal.prototype.webcalLink = function webcalLink() {
            return this._data.$href('ical');
        };

        /***
         * @ngdoc method
         * @name gcalLink
         * @methodOf BB.Models:PurchaseTotal
         * @description
         * Get the gcalLink
         *
         * @returns {object} The returned gcalLink
         */


        PurchaseTotal.prototype.gcalLink = function gcalLink() {
            return this._data.$href('gcal');
        };

        /***
         * @ngdoc method
         * @name id
         * @methodOf BB.Models:PurchaseTotal
         * @description
         * Get the id
         *
         * @returns {object} The returned id
         */


        PurchaseTotal.prototype.id = function id() {
            return this.get('id');
        };

        PurchaseTotal.$query = function $query(params) {
            return PurchaseService.query(params);
        };

        PurchaseTotal.$bookingRefQuery = function $bookingRefQuery(params) {
            return PurchaseService.query(params);
        };

        return PurchaseTotal;
    }(BaseModel);
});
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:Question
 *
 * @description
 * Representation of an Question Object
 *
 * @property {integer} company_id The company id
 * @property {array} question An array with questions
 */ //


angular.module('BB.Models').factory("QuestionModel", function ($q, $filter, BBModel, BaseModel, QuestionService) {
    return function (_BaseModel) {
        _inherits(Question, _BaseModel);

        function Question(data) {
            _classCallCheck(this, Question);

            var _this = _possibleConstructorReturn(this, _BaseModel.call(this, data));
            // weirdly quesiton is  not currently initited as a hal object


            if (_this.price) {
                _this.price = parseFloat(_this.price);
            }
            if (_this._data.default) {
                _this.answer = _this._data.default;
            }
            if (_this._data.options) {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Array.from(_this._data.options)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var option = _step.value;

                        if (option.is_default) {
                            _this.answer = option.name;
                        }
                        if (_this.hasPrice()) {
                            option.price = parseFloat(option.price);
                            var currency = data.currency_code ? data.currency_code : 'GBP';
                            option.display_name = option.name + ' (' + $filter('currency')(option.price, currency) + ')';
                        } else {
                            option.display_name = option.name;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
            if (_this._data.detail_type === "check" || _this._data.detail_type === "check-price") {
                _this.answer = _this._data.default && _this._data.default === "1";
            }

            _this.currentlyShown = true;
            return _this;
        }

        /***
         * @ngdoc method
         * @name hasPrice
         * @methodOf BB.Models:Question
         * @description
         * Check if it contains one of the following: "check-price", "select-price", "radio-price"
         *
         * @returns {boolean} If this contains detail_type
         */


        Question.prototype.hasPrice = function hasPrice() {
            return this.detail_type === "check-price" || this.detail_type === "select-price" || this.detail_type === "radio-price";
        };

        /***
         * @ngdoc method
         * @name selectedPrice
         * @methodOf BB.Models:Question
         * @description
         * Select price if detail type si equal with check-price
         *
         * @returns {float} The returned selected price
         */


        Question.prototype.selectedPrice = function selectedPrice() {
            if (!this.hasPrice()) {
                return 0;
            }
            if (this.detail_type === "check-price") {
                return this.answer ? this.price : 0;
            }
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = Array.from(this._data.options)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var option = _step2.value;

                    if (this.answer === option.name) {
                        return option.price;
                    }
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            return 0;
        };

        /***
         * @ngdoc method
         * @name selectedPriceQty
         * @methodOf BB.Models:Question
         * @description
         * Select price quantity if selected price has been selected
         *
         * @returns {object} The returned selected price quantity
         */


        Question.prototype.selectedPriceQty = function selectedPriceQty(qty) {
            if (!qty) {
                qty = 1;
            }
            var p = this.selectedPrice();
            if (this.price_per_booking) {
                p = p * qty;
            }
            return p;
        };

        /***
         * @ngdoc method
         * @name getAnswerId
         * @methodOf BB.Models:Question
         * @description
         * Get answer id
         *
         * @returns {object} The returned answer id
         */


        Question.prototype.getAnswerId = function getAnswerId() {
            if (!this.answer || !this.options || this.options.length === 0) {
                return null;
            }
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = Array.from(this.options)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var o = _step3.value;

                    if (this.answer === o.name) {
                        return o.id;
                    }
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }

            return null;
        };

        /***
         * @ngdoc method
         * @name showElement
         * @methodOf BB.Models:Question
         * @description
         * Show element
         *
         * @returns {boolean} If element is displayed
         */


        Question.prototype.showElement = function showElement() {
            return this.currentlyShown = true;
        };

        /***
         * @ngdoc hideElement
         * @name showElement
         * @methodOf BB.Models:Question
         * @description
         * Hide element
         *
         * @returns {boolean} If element is hidden
         */


        Question.prototype.hideElement = function hideElement() {
            return this.currentlyShown = false;
        };

        /***
         * @ngdoc hideElement
         * @name getPostData
         * @methodOf BB.Models:Question
         * @description
         * Get post data
         *
         * @returns {object} The returned post data
         */


        Question.prototype.getPostData = function getPostData() {
            var x = {};
            x.id = this.id;
            x.answer = this.answer;
            if (this.detail_type === "date" && this.answer) {
                x.answer = moment(this.answer).toISODate();
            }
            var p = this.selectedPrice();
            if (p) {
                x.price = p;
            }
            return x;
        };

        Question.$addAnswersByName = function $addAnswersByName(obj, keys) {
            return QuestionService.addAnswersByName(obj, keys);
        };

        Question.$addDynamicAnswersByName = function $addDynamicAnswersByName(questions) {
            return QuestionService.addDynamicAnswersByName(questions);
        };

        Question.$addAnswersFromDefaults = function $addAnswersFromDefaults(questions, answers) {
            return QuestionService.addAnswersFromDefaults(questions, answers);
        };

        Question.$checkConditionalQuestions = function $checkConditionalQuestions(questions) {
            return QuestionService.checkConditionalQuestions(questions);
        };

        return Question;
    }(BaseModel);
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

angular.module('BB.Models').factory("ReasonModel", function ($q, BBModel, BaseModel) {
  return function (_BaseModel) {
    _inherits(Reason, _BaseModel);

    function Reason() {
      _classCallCheck(this, Reason);

      return _possibleConstructorReturn(this, _BaseModel.apply(this, arguments));
    }

    return Reason;
  }(BaseModel);
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:Resource
 *
 * @description
 * Representation of an Resource Object
 *
 * @property {integer} id The resources id
 * @property {string} name Name of the resource
 * @property {string} description Description of the resource
 * @property {string} type Type of the resource
 * @property {hash} extra Any extra custom business information
 * @property {boolean} deleted Verify if resources is deleted or not
 * @property {boolean} disabled Verify if resources is disabled or not
 */ //


angular.module('BB.Models').factory("ResourceModel", function ($q, BBModel, BaseModel, ResourceService) {
    return function (_BaseModel) {
        _inherits(Resource, _BaseModel);

        function Resource() {
            _classCallCheck(this, Resource);

            return _possibleConstructorReturn(this, _BaseModel.apply(this, arguments));
        }

        /***
         * @ngdoc method
         * @name $query
         * @methodOf BB.Models:Resource
         * @description
         * Static function that loads an array of resources from a company object
         *
         * @returns {promise} A returned promise
         */
        Resource.$query = function $query(company) {
            return ResourceService.query(company);
        };

        return Resource;
    }(BaseModel);
});
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:Service
 *
 * @description
 * Representation of an Service Object
 *
 * @property {integer} id Id of the service
 * @property {string} name The name of service
 * @property {date} duration Duration of the service
 * @property {float} prices The prices of the service
 * @property {integer} detail_group_id The detail group id
 * @property {date} booking_time_step The time step of the booking
 * @property {integer} min_bookings The minimum number of bookings
 * @property {integer} max_booings The maximum number of bookings
 */

angular.module('BB.Models').factory("ServiceModel", function ($q, BBModel, BaseModel, ServiceService) {
    return function (_BaseModel) {
        _inherits(Service, _BaseModel);

        function Service(data) {
            _classCallCheck(this, Service);

            var _this = _possibleConstructorReturn(this, _BaseModel.apply(this, arguments));

            if (_this.prices && _this.prices.length > 0) {
                _this.price = _this.prices[0];
            }
            if (_this.durations && _this.durations.length > 0) {
                _this.duration = _this.durations[0];
            }
            if (!_this.listed_durations) {
                _this.listed_durations = _this.durations;
            }
            if (_this.listed_durations && _this.listed_durations.length > 0) {
                _this.listed_duration = _this.listed_durations[0];
            }

            _this.min_advance_datetime = moment().add(_this.min_advance_period, 'seconds');
            _this.max_advance_datetime = moment().add(_this.max_advance_period, 'seconds');
            return _this;
        }

        /***
         * @ngdoc method
         * @name getPriceByDuration
         * @methodOf BB.Models:Service
         * @description
         * Get price by duration in function of duration
         *
         * @returns {object} The returning price by duration
         */


        Service.prototype.getPriceByDuration = function getPriceByDuration(dur) {
            for (var i = 0; i < this.durations.length; i++) {
                var d = this.durations[i];
                if (d === dur) {
                    return this.prices[i];
                }
            }
        };

        // return price

        /***
         * @ngdoc method
         * @name $getCategory
         * @methodOf BB.Models:Service
         * @description
         * Get category promise
         *
         * @returns {object} The returning category promise
         */


        Service.prototype.$getCategory = function $getCategory() {
            var _this2 = this;

            if (!this.$has('category')) {
                return null;
            }
            var prom = this.$get('category');
            prom.then(function (cat) {
                return _this2.category = new BBModel.Category(cat);
            });
            return prom;
        };

        /***
         * @ngdoc method
         * @name days_array
         * @methodOf BB.Models:Service
         * @description
         * Put days in array
         *
         * @returns {array} The returning days array
         */


        Service.prototype.days_array = function days_array() {
            var arr = [];
            for (var x = this.min_bookings, end = this.max_bookings, asc = this.min_bookings <= end; asc ? x <= end : x >= end; asc ? x++ : x--) {
                var str = x + ' day';
                if (x > 1) {
                    str += "s";
                }
                arr.push({ name: str, val: x });
            }
            return arr;
        };

        /***
         * @ngdoc method
         * @name $query
         * @methodOf BB.Models:Service
         * @description
         * Static function that loads an array of services from a company object
         *
         * @returns {promise} A returned promise
         */


        Service.$query = function $query(company) {
            return ServiceService.query(company);
        };

        return Service;
    }(BaseModel);
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:Slot
 *
 * @description
 * Representation of an Slot Object
 *
 * @property {integer} total_entries The The total entries of the slot
 * @property {array} slots An array with slots
 */

angular.module('BB.Models').factory("SlotModel", function ($q, BBModel, BaseModel, SlotService) {
    return function (_BaseModel) {
        _inherits(Slot, _BaseModel);

        function Slot(data) {
            _classCallCheck(this, Slot);

            var _this = _possibleConstructorReturn(this, _BaseModel.call(this, data));

            _this.datetime = moment(data.datetime);
            return _this;
        }

        Slot.$query = function $query(company, params) {
            return SlotService.query(company, params);
        };

        return Slot;
    }(BaseModel);
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:Space
 *
 * @description
 * Representation of an Space Object
 */

angular.module('BB.Models').factory("SpaceModel", function ($q, BBModel, BaseModel, SpaceService) {
    return function (_BaseModel) {
        _inherits(Space, _BaseModel);

        function Space() {
            _classCallCheck(this, Space);

            return _possibleConstructorReturn(this, _BaseModel.apply(this, arguments));
        }

        Space.prototype.$query = function $query(company) {
            return SpaceService.query(company);
        };

        return Space;
    }(BaseModel);
});
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:SurveyQuestion
 *
 * @description
 * Representation of an SurveyQuestion Object
 *
 * @property {integer} company_id The company id
 * @property {array} questions An array with questions
 */

angular.module('BB.Models').factory("SurveyQuestionModel", function ($q, $window, BBModel, BaseModel, QuestionModel) {
  return function (_QuestionModel) {
    _inherits(SurveyQuestion, _QuestionModel);

    function SurveyQuestion() {
      _classCallCheck(this, SurveyQuestion);

      return _possibleConstructorReturn(this, _QuestionModel.apply(this, arguments));
    }

    return SurveyQuestion;
  }(QuestionModel);
});
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/***
 * @ngdoc service
 * @name BB.Models:TimeSlot
 *
 * @description
 * Representation of an TimeSlot Object
 *
 * @property {number} avail Indicates if the slot is available
 * @property {moment} datetime Moment representation of the time slot
 * @property {number} event_id The event id assoicated to the time slot
 * @property {number} price The price assoicated to the time slot
 * @property {object} service The service assoicataed to the time slot

 * @property {boolean} selected Indicates if the slot is selected
 */

angular.module('BB.Models').factory("TimeSlotModel", function ($q, $window, BBModel, BaseModel, TimeService, DateTimeUtilitiesService) {
    return function (_BaseModel) {
        _inherits(TimeSlot, _BaseModel);

        function TimeSlot(data, service) {
            _classCallCheck(this, TimeSlot);

            var _this = _possibleConstructorReturn(this, _BaseModel.call(this, data));

            _this.service = service;

            if (!_this.datetime && data.time && moment.isMoment(data.date)) {
                _this.datetime = DateTimeUtilitiesService.convertTimeToMoment(data.date, data.time);
            } else {
                _this.datetime = moment.parseZone(_this.datetime);
            }
            return _this;
        }

        /***
         * @ngdoc method
         * @name endDateTime
         * @methodOf BB.Models:TimeSlot
         * @description
         * Calculates the end datetime using the provided duration or the duration from the service.
         *
         * @param {number} Optional duration
         * @returns {moment} End datetime
         */


        TimeSlot.prototype.endDateTime = function endDateTime(dur) {
            var duration = void 0;
            if (!dur) {
                duration = this.service.listed_durations[0];
            }
            return this.datetime.clone().add(duration, 'minutes');
        };

        /***
         * @ngdoc method
         * @name availability
         * @methodOf BB.Models:TimeSlot
         * @description
         * Get availability
         *
         * @returns {number} Availability (> 0 means the slot is available)
         */


        TimeSlot.prototype.availability = function availability() {
            return this.avail;
        };

        /***
         * @ngdoc method
         * @name select
         * @methodOf BB.Models:TimeSlot
         * @description
         * Select the time slot
         *
         * @returns {boolean} Selected status
         */


        TimeSlot.prototype.select = function select() {
            return this.selected = true;
        };

        /***
         * @ngdoc method
         * @name unselect
         * @methodOf BB.Models:TimeSlot
         * @description
         * Unselect time slot
         *
         */


        TimeSlot.prototype.unselect = function unselect() {
            if (this.selected) {
                return delete this.selected;
            }
        };

        /***
         * @ngdoc method
         * @name disable
         * @methodOf BB.Models:TimeSlot
         * @description
         * Disable time slot by reason
         *
         */


        TimeSlot.prototype.disable = function disable(reason) {
            this.disabled = true;
            return this.disabled_reason = reason;
        };

        /***
         * @ngdoc method
         * @name enable
         * @methodOf BB.Models:TimeSlot
         * @description
         * Enable time slot
         *
         */


        TimeSlot.prototype.enable = function enable() {
            if (this.disabled) {
                delete this.disabled;
            }
            if (this.disabled_reason) {
                return delete this.disabled_reason;
            }
        };

        /***
         * @ngdoc method
         * @name status
         * @methodOf BB.Models:TimeSlot
         * @description
         * Get the status of the time slot
         *
         * @returns {string} Status of the time slot
         */


        TimeSlot.prototype.status = function status() {
            if (this.selected) {
                return "selected";
            }
            if (this.disabled) {
                return "disabled";
            }
            if (this.availability() > 0) {
                return "enabled";
            }
            return "disabled";
        };

        TimeSlot.$query = function $query(params) {
            return TimeService.query(params);
        };

        return TimeSlot;
    }(BaseModel);
});
"use strict";

angular.module('BB.Services').factory("AddressListService", function ($q, $window, halClient, UriTemplate) {

    return {
        query: function query(prms) {
            var deferred = $q.defer();
            var href = "/api/v1/company/{company_id}/addresses/{post_code}";
            var uri = new UriTemplate(href).fillFromObject({ company_id: prms.company.id, post_code: prms.post_code });
            halClient.$get(uri, {}).then(function (addressList) {
                return deferred.resolve(addressList);
            }, function (err) {
                return deferred.reject(err);
            });
            return deferred.promise;
        },
        getAddress: function getAddress(prms) {
            var deferred = $q.defer();
            var href = "/api/v1/company/{company_id}/addresses/address/{id}";
            var uri = new UriTemplate(href).fillFromObject({ company_id: prms.company.id, id: prms.id });
            halClient.$get(uri, {}).then(function (customerAddress) {
                return deferred.resolve(customerAddress);
            }, function (err) {
                return deferred.reject(err);
            });
            return deferred.promise;
        }
    };
});
'use strict';

/***
 * @ngdoc service
 * @name BB.Services:Airbrake
 *
 * @description
 * JavaScript notifier for capturing errors in web browsers and reporting them to Airbrake.
 *
 */ //

angular.module('BB.Services').factory('$exceptionHandler', function ($log, AirbrakeConfig) {

    var airbrake = new airbrakeJs.Client({
        projectId: AirbrakeConfig.projectId,
        projectKey: AirbrakeConfig.projectKey
    });

    airbrake.addFilter(function (notice) {
        if (AirbrakeConfig.environment === 'development' || !notice.params.from_sdk) {
            return false;
        }

        notice.context.environment = 'production';
        return notice;
    });

    return function (exception, cause, sdkError) {
        $log.error(exception);
        airbrake.notify({
            error: exception,
            params: {
                angular_cause: cause, from_sdk: sdkError
            }
        });
    };
});
'use strict';

(function () {

    angular.module('BB.Services').factory('AlertService', AlertService);

    function AlertService($rootScope, ErrorService, $timeout, $translate) {

        $rootScope.alerts = [];

        /***
         * @ngdoc method
         * @name titleLookup
         * @methodOf BB.Services:Alert
         * @description
         * Title look up in according of type and title parameters
         *
         * @returns {boolean} The returned title
         */
        var titleLookup = function titleLookup(type, title) {
            if (title) {
                return title;
            }
            switch (type) {
                case "error":
                case "danger":
                    title = $translate.instant('CORE.ERROR_HEADING');
                    break;
                default:
                    title = null;
            }
            return title;
        };

        var add = function add(type, _ref) {
            var title = _ref.title,
                msg = _ref.msg,
                persist = _ref.persist;

            if (persist == null) {
                persist = true;
            }
            $rootScope.alerts = [];
            var alert = {
                type: type,
                title: titleLookup(type, title),
                msg: msg,
                close: function close() {
                    return alertService.closeAlert(this);
                }
            };
            $rootScope.alerts.push(alert);
            if (!persist) {
                $timeout(function () {
                    return $rootScope.alerts.splice($rootScope.alerts.indexOf(alert), 1);
                }, 3000);
            }
            return $rootScope.$broadcast("alert:raised");
        };

        /***
         * @ngdoc method
         * @name closeAlert
         * @methodOf BB.Services:Alert
         * @description
         * Close alert
         *
         * @returns {boolean}  close alert
         */
        var closeAlert = function closeAlert(alert) {
            return closeAlertIdx($rootScope.alerts.indexOf(alert));
        };

        /***
         * @ngdoc method
         * @name closeAlertIdx
         * @methodOf BB.Services:Alert
         * @description
         * Close alert index
         *
         * @returns {boolean}  The returned close alert index
         */
        var closeAlertIdx = function closeAlertIdx(index) {
            return $rootScope.alerts.splice(index, 1);
        };

        /***
         * @ngdoc method
         * @name clear
         * @methodOf BB.Services:Alert
         * @description
         * Clear alert message
         *
         * @returns {array} Newly clear array of the alert messages
         */
        var clear = function clear() {
            return $rootScope.alerts = [];
        };

        /***
         * @ngdoc error
         * @name clear
         * @methodOf BB.Services:Alert
         * @description
         * Error alert
         *
         * @returns {array} The returned error alert
         */
        var error = function error(alert) {
            if (!alert) {
                return;
            }
            return add('error', { title: alert.title, msg: alert.msg, persist: alert.persist });
        };

        /***
         * @ngdoc error
         * @name danger
         * @methodOf BB.Services:Alert
         * @description
         * Danger alert
         *
         * @returns {array} The returned danger alert
         */
        var danger = function danger(alert) {
            if (!alert) {
                return;
            }
            return add('danger', { title: alert.title, msg: alert.msg, persist: alert.persist });
        };

        /***
         * @ngdoc error
         * @name info
         * @methodOf BB.Services:Alert
         * @description
         * Info alert
         *
         * @returns {array} The returned info alert
         */
        var info = function info(alert) {
            if (!alert) {
                return;
            }
            return add('info', { title: alert.title, msg: alert.msg, persist: alert.persist });
        };

        /***
         * @ngdoc error
         * @name warning
         * @methodOf BB.Services:Alert
         * @description
         * Warning alert
         *
         * @returns {array} The returned warning alert
         */
        var warning = function warning(alert) {
            if (!alert) {
                return;
            }
            return add('warning', { title: alert.title, msg: alert.msg, persist: alert.persist });
        };

        /***
         * @ngdoc error
         * @name success
         * @methodOf BB.Services:Alert
         * @description
         * Success alert
         *
         * @returns {array} The returned warning alert
         */
        var success = function success(alert) {
            if (!alert) {
                return;
            }
            return add('success', { title: alert.title, msg: alert.msg, persist: alert.persist });
        };

        /***
         * @ngdoc error
         * @name raise
         * @methodOf BB.Services:Alert
         * @description
         * Raise alert
         *
         * @returns {array} The returned raise alert
         */
        var raise = function raise(key, translationValue) {
            if (!key) return;
            var alert = ErrorService.getAlert(key, translationValue);
            if (alert) {
                return add(alert.type, { title: alert.title, msg: alert.msg, persist: alert.persist });
            }
        };

        return {
            add: add,
            closeAlert: closeAlert,
            closeAlertIdx: closeAlertIdx,
            clear: clear,
            error: error,
            danger: danger,
            info: info,
            warning: warning,
            success: success,
            raise: raise
        };
    }
})();
'use strict';

(function () {

	angular.module('BB.Services').factory('AppService', AppService);

	function AppService($uibModalStack) {
		var isModalOpen = function isModalOpen() {
			return !!$uibModalStack.getTop();
		};

		return {
			isModalOpen: isModalOpen
		};
	}
})();
"use strict";

angular.module('BB.Services').factory("BasketService", function ($q, $rootScope, BBModel, MutexService) {

    return {
        addItem: function addItem(company, params) {
            var deferred = $q.defer();
            var lnk = params.item.book_link;
            var data = params.item.getPostData();
            if (!lnk) {
                deferred.reject("rel book not found for event");
            } else {
                MutexService.getLock().then(function (mutex) {
                    return lnk.$post('book', params, data).then(function (basket) {
                        MutexService.unlock(mutex);
                        company.$flush('basket');
                        var mbasket = new BBModel.Basket(basket, params.bb);
                        return basket.$get('items').then(function (items) {
                            var promises = [];
                            var _iteratorNormalCompletion = true;
                            var _didIteratorError = false;
                            var _iteratorError = undefined;

                            try {
                                for (var _iterator = Array.from(items)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                    var i = _step.value;

                                    var item = new BBModel.BasketItem(i, params.bb);
                                    mbasket.addItem(item);
                                    // keep an eye on if this item needs any promises resolved to be valid
                                    promises = promises.concat(item.promises);
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return) {
                                        _iterator.return();
                                    }
                                } finally {
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }

                            if (promises.length > 0) {
                                return $q.all(promises).then(function () {
                                    return deferred.resolve(mbasket);
                                });
                            } else {
                                return deferred.resolve(mbasket);
                            }
                        }, function (err) {
                            return deferred.reject(err);
                        });
                    }, function (err) {
                        MutexService.unlock(mutex);
                        return deferred.reject(err);
                    });
                });
            }
            return deferred.promise;
        },
        applyCoupon: function applyCoupon(company, params) {
            var deferred = $q.defer();

            MutexService.getLock().then(function (mutex) {
                return company.$post('coupon', {}, { coupon: params.coupon }).then(function (basket) {
                    MutexService.unlock(mutex);
                    company.$flush('basket');
                    var mbasket = new BBModel.Basket(basket, params.bb);
                    return basket.$get('items').then(function (items) {
                        var promises = [];
                        var _iteratorNormalCompletion2 = true;
                        var _didIteratorError2 = false;
                        var _iteratorError2 = undefined;

                        try {
                            for (var _iterator2 = Array.from(items)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                var i = _step2.value;

                                var item = new BBModel.BasketItem(i, params.bb);
                                mbasket.addItem(item);
                                // keep an eye on if this item needs any promises resolved to be valid
                                promises = promises.concat(item.promises);
                            }
                        } catch (err) {
                            _didIteratorError2 = true;
                            _iteratorError2 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                    _iterator2.return();
                                }
                            } finally {
                                if (_didIteratorError2) {
                                    throw _iteratorError2;
                                }
                            }
                        }

                        if (promises.length > 0) {
                            return $q.all(promises).then(function () {
                                return deferred.resolve(mbasket);
                            });
                        } else {
                            return deferred.resolve(mbasket);
                        }
                    }, function (err) {
                        return deferred.reject(err);
                    });
                }, function (err) {
                    MutexService.unlock(mutex);
                    return deferred.reject(err);
                });
            });
            return deferred.promise;
        },


        // add several items at onece - params should have an array of items:
        updateBasket: function updateBasket(company, params) {
            var lnk = void 0;
            var deferred = $q.defer();

            var data = { entire_basket: true, items: [] };

            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = Array.from(params.items)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var item = _step3.value;

                    if (item.book_link) {
                        lnk = item.book_link;
                    }
                    var xdata = item.getPostData();
                    // force the date into utc
                    //      d = item.date.date._a
                    //      date = new Date(Date.UTC(d[0], d[1], d[2]))
                    //      xdata.date = date
                    data.items.push(xdata);
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }

            if (!lnk) {
                deferred.reject("rel book not found for event");
                return deferred.promise;
            }
            MutexService.getLock().then(function (mutex) {
                return lnk.$post('book', params, data).then(function (basket) {
                    MutexService.unlock(mutex);
                    company.$flush('basket');
                    var mbasket = new BBModel.Basket(basket, params.bb);
                    return basket.$get('items').then(function (items) {
                        var promises = [];
                        var _iteratorNormalCompletion4 = true;
                        var _didIteratorError4 = false;
                        var _iteratorError4 = undefined;

                        try {
                            for (var _iterator4 = Array.from(items)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                                var i = _step4.value;

                                item = new BBModel.BasketItem(i, params.bb);
                                mbasket.addItem(item);
                                // keep an eye on if this item needs any promises resolved to be valid
                                promises = promises.concat(item.promises);
                            }
                        } catch (err) {
                            _didIteratorError4 = true;
                            _iteratorError4 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion4 && _iterator4.return) {
                                    _iterator4.return();
                                }
                            } finally {
                                if (_didIteratorError4) {
                                    throw _iteratorError4;
                                }
                            }
                        }

                        if (promises.length > 0) {
                            return $q.all(promises).then(function () {
                                $rootScope.$broadcast("basket:updated", mbasket);
                                return deferred.resolve(mbasket);
                            });
                        } else {
                            $rootScope.$broadcast("basket:updated", mbasket);
                            return deferred.resolve(mbasket);
                        }
                    }, function (err) {
                        return deferred.reject(err);
                    });
                }, function (err) {
                    MutexService.unlock(mutex);
                    return deferred.reject(err);
                });
            });

            return deferred.promise;
        },
        checkPrePaid: function checkPrePaid(item, pre_paid_bookings) {
            var valid_pre_paid = null;
            var _iteratorNormalCompletion5 = true;
            var _didIteratorError5 = false;
            var _iteratorError5 = undefined;

            try {
                for (var _iterator5 = Array.from(pre_paid_bookings)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                    var booking = _step5.value;

                    if (booking.checkValidity(item)) {
                        valid_pre_paid = booking;
                        break;
                    }
                }
            } catch (err) {
                _didIteratorError5 = true;
                _iteratorError5 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion5 && _iterator5.return) {
                        _iterator5.return();
                    }
                } finally {
                    if (_didIteratorError5) {
                        throw _iteratorError5;
                    }
                }
            }

            return valid_pre_paid;
        },
        query: function query(company, params) {
            var deferred = $q.defer();
            if (!company.$has('basket')) {
                deferred.reject("rel basket not found for company");
            } else {
                company.$get('basket').then(function (basket) {
                    basket = new BBModel.Basket(basket, params.bb);
                    if (basket.$has('items')) {
                        basket.$get('items').then(function (items) {
                            return Array.from(items).map(function (item) {
                                return basket.addItem(new BBModel.BasketItem(item, params.bb));
                            });
                        });
                    }
                    return deferred.resolve(basket);
                }, function (err) {
                    return deferred.reject(err);
                });
            }
            return deferred.promise;
        },
        deleteItem: function deleteItem(item, company, params) {
            if (!params) {
                params = {};
            }
            if (params.basket) {
                params.basket.clearItem(item);
            }
            var deferred = $q.defer();
            if (!item.$has('self')) {
                deferred.reject("rel self not found for item");
            } else {
                MutexService.getLock().then(function (mutex) {
                    return item.$del('self', params).then(function (basket) {
                        MutexService.unlock(mutex);
                        company.$flush('basket');
                        basket = new BBModel.Basket(basket, params.bb);
                        if (basket.$has('items')) {
                            basket.$get('items').then(function (items) {
                                return function () {
                                    var result = [];
                                    var _iteratorNormalCompletion6 = true;
                                    var _didIteratorError6 = false;
                                    var _iteratorError6 = undefined;

                                    try {
                                        for (var _iterator6 = Array.from(items)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                                            item = _step6.value;

                                            result.push(basket.addItem(new BBModel.BasketItem(item, params.bb)));
                                        }
                                    } catch (err) {
                                        _didIteratorError6 = true;
                                        _iteratorError6 = err;
                                    } finally {
                                        try {
                                            if (!_iteratorNormalCompletion6 && _iterator6.return) {
                                                _iterator6.return();
                                            }
                                        } finally {
                                            if (_didIteratorError6) {
                                                throw _iteratorError6;
                                            }
                                        }
                                    }

                                    return result;
                                }();
                            });
                        }
                        return deferred.resolve(basket);
                    }, function (err) {
                        return deferred.reject(err);
                    });
                }, function (err) {
                    MutexService.unlock(mutex);
                    return deferred.reject(err);
                });
            }

            return deferred.promise;
        },
        checkout: function checkout(company, basket, params) {
            var deferred = $q.defer();
            if (!basket.$has('checkout')) {
                deferred.reject("rel checkout not found for basket");
            } else {
                var data = basket.getPostData();
                if (params.bb.qudini_booking_id) {
                    data.qudini_booking_id = params.bb.qudini_booking_id;
                }
                if (params.bb.booking_settings) {
                    data.booking_settings = params.bb.booking_settings;
                }
                if (params.bb.no_notifications) {
                    data.no_notifications = params.bb.no_notifications;
                }
                if (params.bb.email_config) {
                    data.email_config = params.bb.email_config;
                }
                data.affiliate_id = $rootScope.affiliate_id || params.affiliate_id;
                basket.waiting_for_checkout = true;
                MutexService.getLock().then(function (mutex) {
                    return basket.$post('checkout', params, data).then(function (total) {
                        MutexService.unlock(mutex);
                        $rootScope.$broadcast('updateBookings');
                        var tot = new BBModel.Purchase.Total(total);
                        $rootScope.$broadcast('newCheckout', tot);
                        basket.clear();
                        basket.waiting_for_checkout = false;
                        return deferred.resolve(tot);
                    }, function (err) {
                        basket.waiting_for_checkout = false;
                        return deferred.reject(err);
                    });
                }, function (err) {
                    basket.waiting_for_checkout = false;
                    MutexService.unlock(mutex);
                    return deferred.reject(err);
                });
            }
            return deferred.promise;
        },
        empty: function empty(bb) {
            var deferred = $q.defer();
            MutexService.getLock().then(function (mutex) {
                return bb.company.$del('basket').then(function (basket) {
                    MutexService.unlock(mutex);
                    bb.company.$flush('basket');
                    return deferred.resolve(new BBModel.Basket(basket, bb));
                }, function (err) {
                    return deferred.reject(err);
                });
            }, function (err) {
                MutexService.unlock(mutex);
                return deferred.reject(err);
            });
            return deferred.promise;
        },
        memberCheckout: function memberCheckout(basket, params) {
            var deferred = $q.defer();
            if (!basket.$has('checkout')) {
                deferred.reject("rel checkout not found for basket");
            } else if ($rootScope.member === null) {
                deferred.reject("member not set");
            } else {
                basket._data.setOption('auth_token', $rootScope.member._data.getOption('auth_token'));
                var data = { items: Array.from(basket.items).map(function (item) {
                        return item._data;
                    }) };
                basket.$post('checkout', params, data).then(function (total) {
                    if (total.$has('member')) {
                        total.$get('member').then(function (member) {
                            $rootScope.member.flushBookings();
                            return $rootScope.member = new BBModel.Member.Member(member);
                        });
                    }
                    return deferred.resolve(total);
                }, function (err) {
                    return deferred.reject(err);
                });
            }
            return deferred.promise;
        },
        applyDeal: function applyDeal(company, params) {
            var deferred = $q.defer();

            MutexService.getLock().then(function (mutex) {
                return params.bb.basket.$post('deal', {}, { deal_code: params.deal_code }).then(function (basket) {
                    MutexService.unlock(mutex);
                    company.$flush('basket');
                    var mbasket = new BBModel.Basket(basket, params.bb);
                    return basket.$get('items').then(function (items) {
                        var promises = [];
                        var _iteratorNormalCompletion7 = true;
                        var _didIteratorError7 = false;
                        var _iteratorError7 = undefined;

                        try {
                            for (var _iterator7 = Array.from(items)[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                                var i = _step7.value;

                                var item = new BBModel.BasketItem(i, params.bb);
                                mbasket.addItem(item);
                                // keep an eye on if this item needs any promises resolved to be valid
                                promises = promises.concat(item.promises);
                            }
                        } catch (err) {
                            _didIteratorError7 = true;
                            _iteratorError7 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion7 && _iterator7.return) {
                                    _iterator7.return();
                                }
                            } finally {
                                if (_didIteratorError7) {
                                    throw _iteratorError7;
                                }
                            }
                        }

                        if (promises.length > 0) {
                            return $q.all(promises).then(function () {
                                return deferred.resolve(mbasket);
                            });
                        } else {
                            return deferred.resolve(mbasket);
                        }
                    }, function (err) {
                        return deferred.reject(err);
                    });
                }, function (err) {
                    MutexService.unlock(mutex);
                    return deferred.reject(err);
                });
            });
            return deferred.promise;
        },
        removeDeal: function removeDeal(company, params) {
            if (!params) {
                params = {};
            }
            var deferred = $q.defer();
            if (!params.bb.basket.$has('deal')) {
                return deferred.reject("No Remove Deal link found");
            } else {
                MutexService.getLock().then(function (mutex) {
                    return params.bb.basket.$put('deal', {}, { deal_code_id: params.deal_code_id.toString() }).then(function (basket) {
                        MutexService.unlock(mutex);
                        company.$flush('basket');
                        basket = new BBModel.Basket(basket, params.bb);
                        if (basket.$has('items')) {
                            return basket.$get('items').then(function (items) {
                                var _iteratorNormalCompletion8 = true;
                                var _didIteratorError8 = false;
                                var _iteratorError8 = undefined;

                                try {
                                    for (var _iterator8 = Array.from(items)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                                        var item = _step8.value;

                                        basket.addItem(new BBModel.BasketItem(item, params.bb));
                                    }
                                } catch (err) {
                                    _didIteratorError8 = true;
                                    _iteratorError8 = err;
                                } finally {
                                    try {
                                        if (!_iteratorNormalCompletion8 && _iterator8.return) {
                                            _iterator8.return();
                                        }
                                    } finally {
                                        if (_didIteratorError8) {
                                            throw _iteratorError8;
                                        }
                                    }
                                }

                                return deferred.resolve(basket);
                            }, function (err) {
                                return deferred.reject(err);
                            });
                        }
                    }, function (err) {
                        MutexService.unlock(mutex);
                        return deferred.reject(err);
                    });
                });
                return deferred.promise;
            }
        }
    };
});
"use strict";

angular.module('BB.Services').factory("BreadcrumbService", function () {

    var current_step = 1;

    return {
        setCurrentStep: function setCurrentStep(step) {
            return current_step = step;
        },
        getCurrentStep: function getCurrentStep() {
            return current_step;
        }
    };
});
'use strict';

angular.module('BB.Services').factory("BulkPurchaseService", function ($q, BBModel) {

    return {
        query: function query(company) {
            var deferred = $q.defer();
            if (!company.$has('bulk_purchases')) {
                deferred.reject("No bulk purchases found");
            } else {
                company.$get('bulk_purchases').then(function (resource) {
                    return resource.$get('bulk_purchases').then(function (bulk_purchases) {
                        return deferred.resolve(Array.from(bulk_purchases).map(function (i) {
                            return new BBModel.BulkPurchase(i);
                        }));
                    });
                }, function (err) {
                    return deferred.reject(err);
                });
            }
            return deferred.promise;
        }
    };
});
'use strict';

angular.module('BB.Services').factory("CategoryService", function ($q, BBModel) {

    return {
        query: function query(company) {
            var deferred = $q.defer();
            if (!company.$has('categories')) {
                deferred.reject("No categories found");
            } else {
                company.$get('named_categories').then(function (resource) {
                    return resource.$get('categories').then(function (items) {
                        var categories = [];
                        for (var _i = 0; _i < items.length; _i++) {
                            var i = items[_i];
                            var cat = new BBModel.Category(i);
                            if (!cat.order) {
                                cat.order = _i;
                            }
                            categories.push(cat);
                        }
                        return deferred.resolve(categories);
                    });
                }, function (err) {
                    return deferred.reject(err);
                });
            }
            return deferred.promise;
        }
    };
});
'use strict';

angular.module('BB.Services').factory("ClientService", function ($q, BBModel, MutexService) {

    var setDefaultCompanyId = function setDefaultCompanyId(company, client) {
        // set the default_company_id on the client so that we can filter search results by child company if AdminBookingOptions.use_default_company_id is set
        client.default_company_id = company.id;
    };

    return {
        create: function create(company, client) {
            var deferred = $q.defer();
            if (!company.$has('client')) {
                deferred.reject("Cannot create new people for this company");
            } else {
                MutexService.getLock().then(function (mutex) {
                    setDefaultCompanyId(company, client);
                    return company.$post('client', {}, client.getPostData()).then(function (cl) {
                        deferred.resolve(new BBModel.Client(cl));
                        return MutexService.unlock(mutex);
                    }, function (err) {
                        deferred.reject(err);
                        return MutexService.unlock(mutex);
                    });
                });
            }
            return deferred.promise;
        },
        update: function update(company, client) {
            var deferred = $q.defer();
            MutexService.getLock().then(function (mutex) {
                setDefaultCompanyId(company, client);
                return client.$put('self', {}, client.getPostData()).then(function (cl) {
                    deferred.resolve(new BBModel.Client(cl));
                    return MutexService.unlock(mutex);
                }, function (err) {
                    deferred.reject(err);
                    return MutexService.unlock(mutex);
                });
            });
            return deferred.promise;
        },
        create_or_update: function create_or_update(company, client) {
            if (client.$has('self')) {
                return this.update(company, client);
            } else {
                return this.create(company, client);
            }
        },
        query_by_email: function query_by_email(company, email) {
            var deferred = $q.defer();
            if (company != null && email != null) {
                company.$get("client_by_email", { email: email }).then(function (client) {
                    if (client != null) {
                        return deferred.resolve(new BBModel.Client(client));
                    } else {
                        return deferred.resolve({});
                    }
                }, function (err) {
                    return deferred.reject(err);
                });
            } else {
                deferred.reject("No company or email defined");
            }
            return deferred.promise;
        }
    };
});
'use strict';

angular.module('BB.Services').factory("ClientDetailsService", function ($q, BBModel) {

    return {
        query: function query(company) {
            var deferred = $q.defer();
            if (!company.$has('client_details')) {
                deferred.reject("No client_details found");
            } else {
                company.$get('client_details').then(function (details) {
                    return deferred.resolve(new BBModel.ClientDetails(details));
                }, function (err) {
                    return deferred.reject(err);
                });
            }
            return deferred.promise;
        }
    };
});
'use strict';

angular.module('BB.Services').factory('ClinicService', function ($q, BBModel, $window) {

    return {
        query: function query(params) {
            var company = params.company;

            var defer = $q.defer();
            if (params.id) {
                // request for a single one
                company.$get('clinics', params).then(function (clinic) {
                    clinic = new BBModel.Clinic(clinic);
                    return defer.resolve(clinic);
                }, function (err) {
                    return defer.reject(err);
                });
            } else {
                company.$get('clinics', params).then(function (collection) {
                    return collection.$get('clinics').then(function (clinics) {
                        clinics = Array.from(clinics).map(function (s) {
                            return new BBModel.Clinic(s);
                        });
                        return defer.resolve(clinics);
                    }, function (err) {
                        return defer.reject(err);
                    });
                }, function (err) {
                    return defer.reject(err);
                });
            }
            return defer.promise;
        }
    };
});
'use strict';

angular.module('BB.Services').factory("CompanyService", function ($q, halClient, BBModel) {

    return {
        query: function query(company_id, options) {
            if (!options['root']) {
                options['root'] = "";
            }
            var url = options['root'] + "/api/v1/company/" + company_id;
            var deferred = $q.defer();
            halClient.$get(url, options).then(function (company) {
                return deferred.resolve(company);
            }, function (err) {
                return deferred.reject(err);
            });
            return deferred.promise;
        },
        queryChildren: function queryChildren(company) {
            var deferred = $q.defer();
            if (!company.$has('companies')) {
                deferred.reject("No child companies found");
            } else {
                company.$get('companies').then(function (resource) {
                    return resource.$get('companies').then(function (items) {
                        var companies = [];
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = Array.from(items)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var i = _step.value;

                                companies.push(new BBModel.Company(i));
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return) {
                                    _iterator.return();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }

                        return deferred.resolve(companies);
                    });
                }, function (err) {
                    return deferred.reject(err);
                });
            }
            return deferred.promise;
        }
    };
});
'use strict';

angular.module('BB.Services').factory('CompanyStoreService', function () {

    return {
        country_code: null,
        currency_code: null,
        time_zone: null,
        settings: null
    };
});
'use strict';

angular.module('BB.Services').factory("CustomTextService", function ($q, BBModel) {

    return {
        BookingText: function BookingText(company, basketItem) {
            var deferred = $q.defer();
            company.$get('booking_text').then(function (emb) {
                return emb.$get('booking_text').then(function (details) {
                    var msgs = [];
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = Array.from(details)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var detail = _step.value;

                            if (detail.message_type === "Booking") {
                                for (var name in basketItem.parts_links) {
                                    var link = basketItem.parts_links[name];
                                    if (detail.$href('item') === link) {
                                        if (msgs.indexOf(detail.message) === -1) {
                                            msgs.push(detail.message);
                                        }
                                    }
                                }
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }

                    return deferred.resolve(msgs);
                });
            }, function (err) {
                return deferred.reject(err);
            });
            return deferred.promise;
        },
        confirmationText: function confirmationText(company, total) {
            var deferred = $q.defer();
            company.$get('booking_text').then(function (emb) {
                return emb.$get('booking_text').then(function (details) {
                    return total.getMessages(details, "Confirm").then(function (msgs) {
                        return deferred.resolve(msgs);
                    });
                });
            }, function (err) {
                return deferred.reject(err);
            });
            return deferred.promise;
        }
    };
});
"use strict";

/***
 * @ngdoc service
 * @name BB.Services:DateTimeUtilities
 *
 * @description
 * Service for manipulating datetime objects
 *
 */ //

angular.module('BB.Services').factory("DateTimeUtilitiesService", function (GeneralOptions, CompanyStoreService, bbTimeZone) {

    /***
     * @ngdoc method
     * @name checkPerson
     * @methodOf BB.Services:DateTimeUtilities
     * @description
     * Checks if basket_item has default person
     * @param {Object} basket_item The basket item object
     * @param {Object} item_defaults The item defaults object
     *
     * @returns {boolean} Whether the basket item has a default person.
     */
    var checkPerson = function checkPerson(basket_item, item_defaults) {
        return basket_item.defaults.person && basket_item.defaults.person.self === basket_item.person.self || _.isBoolean(basket_item.person) || item_defaults.merge_people;
    };

    /***
     * @ngdoc method
     * @name checkResource
     * @methodOf BB.Services:DateTimeUtilities
     * @description
     * Checks if basket_item has default resource
     * @param {Object} basket_item The basket item object
     * @param {Object} item_defaults The item defaults object
     *
     * @returns {boolean} Whether the basket item has a default resource.
     */
    var checkResource = function checkResource(basket_item, item_defaults) {
        return basket_item.defaults.resource && basket_item.defaults.resource.self === basket_item.resource.self || _.isBoolean(basket_item.resource) || item_defaults.merge_resources;
    };

    return {
        /***
         * @ngdoc method
         * @name convertTimeToMoment
         * @methodOf BB.Services:DateTimeUtilities
         * @description
         * Converts date and time to valid moment object
         * @param {Moment} date The date object to convert
         * @param {integer} time The time integer to convert
         *
         * @returns {object} Moment object converted from date/time
         */
        convertTimeToMoment: function convertTimeToMoment(date, time) {
            if (!date || !moment.isMoment(date) || !angular.isNumber(time)) {
                return;
            }
            var datetime = moment();
            // if user timezone different than company timezone
            /*if (bbTimeZone.isCustomTimeZone()) {
                datetime = datetime.tz(CompanyStoreService.time_zone);
            }*/ ///TODO double check

            datetime = bbTimeZone.convertToCompany(datetime);

            var val = parseInt(time);
            var hours = parseInt(val / 60);
            var mins = val % 60;
            datetime.hour(hours);
            datetime.minutes(mins);
            datetime.seconds(0);
            datetime.date(date.date());
            datetime.month(date.month());
            datetime.year(date.year());

            return datetime;
        },


        /***
         * @ngdoc method
         * @name convertMomentToTime
         * @methodOf BB.Services:DateTimeUtilities
         * @description
         * Converts moment object to time
         * @param {Moment} datetime the datetime object to convert
         *
         * @returns {integer} Datetime integer converted from moment object
         */
        convertMomentToTime: function convertMomentToTime(datetime) {
            return datetime.minutes() + datetime.hours() * 60;
        },


        /***
         * @ngdoc method
         * @name checkDefaultTime
         * @methodOf BB.Services:DateTimeUtilities
         * @description
         *  Checks if basket_item default time exists
         * @param {Moment} date The date object
         * @param {Array} time_slots An array of time slots
         * @param {Object} basket_item The basket item object
         * @param {Object} item_defaults The item defaults object
         * @returns {Object} object describing matching slot
         */
        checkDefaultTime: function checkDefaultTime(date, time_slots, basket_item, item_defaults) {
            var match = void 0,
                slot = void 0;
            if (!basket_item.defaults.time) {
                match = null;
            } else if (checkPerson(basket_item, item_defaults) && checkResource(basket_item, item_defaults)) {
                match = "full";
            } else {
                match = "partial";
            }

            var found_time_slot = null;

            if (basket_item.defaults.time && (basket_item.defaults.date && date.isSame(basket_item.defaults.date, 'day') || !basket_item.defaults.date)) {

                var time = basket_item.time ? basket_item.time.time : basket_item.defaults.time;

                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Array.from(time_slots)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        slot = _step.value;

                        if (time && time === slot.time && slot.avail === 1) {
                            found_time_slot = slot;
                            break;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }

            return {
                match: match,
                slot: found_time_slot
            };
        }
    };
});
'use strict';

angular.module('BB.Services').factory("DayService", function ($q, BBModel) {

    return {
        query: function query(prms) {

            var deferred = $q.defer();

            if (prms.cItem.days_link) {

                var extra = {};
                extra.month = prms.month;
                extra.date = prms.date;
                extra.edate = prms.edate;
                if (prms.people_ids) {
                    extra.people_ids = prms.people_ids;
                }
                if (prms.resource_ids) {
                    extra.resource_ids = prms.resource_ids;
                }
                if (prms.person_group_id) {
                    extra.person_group_id = prms.person_group_id;
                }

                prms.cItem.days_link.$get('days', extra).then(function (found) {

                    var afound = found.days;
                    var days = [];

                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = Array.from(afound)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var i = _step.value;


                            if (i.type === prms.item) {
                                days.push(new BBModel.Day(i));
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }

                    return deferred.resolve(days);
                }, function (err) {
                    return deferred.reject(err);
                });
            } else {

                deferred.reject("No Days Link found");
            }

            return deferred.promise;
        }
    };
});
'use strict';

angular.module('BB.Services').factory("DealService", function ($q, BBModel) {

    return {
        query: function query(company) {
            var deferred = $q.defer();
            if (!company.$has('deals')) {
                deferred.reject("No Deals found");
            } else {
                company.$get('deals').then(function (resource) {
                    return resource.$get('deals').then(function (deals) {
                        deals = Array.from(deals).map(function (deal) {
                            return new BBModel.Deal(deal);
                        });
                        return deferred.resolve(deals);
                    });
                }, function (err) {
                    return deferred.reject(err);
                });
            }
            return deferred.promise;
        }
    };
});
'use strict';

angular.module('BB').config(function ($logProvider, $injector) {
    return $logProvider.debugEnabled(true);
});

angular.module('BB.Services').factory("DebugUtilsService", function ($rootScope, $location, $window, $log, BBModel, $bbug) {
    // logs a scopes key names and values
    var logObjectKeys = function logObjectKeys(obj, showValue) {
        for (var key in obj) {
            // dont show angular scope methods
            var value = obj[key];
            if (obj.hasOwnProperty(key) && !_.isFunction(value) && !/^\$\$/.test(key)) {
                console.log(key);
                if (showValue) {
                    console.log('\t', value, '\n');
                }
            }
        }
    };

    var showScopeChain = function showScopeChain() {
        var $root = $('[ng-app]');
        var data = $root.data();

        if (data && data.$scope) {
            var f = function f(scope) {
                console.log(scope.$id);
                console.log(scope);

                if (scope.$$nextSibling) {
                    return f(scope.$$nextSibling);
                } else {
                    if (scope.$$childHead) {
                        return f(scope.$$childHead);
                    }
                }
            };

            f(data.$scope);
        }
    };

    (function () {
        if (($location.host() === 'localhost' || $location.host() === '127.0.0.1') && $location.port() === 3000) {
            return window.setTimeout(function () {
                var scope = $rootScope;
                // look for BBCtrl scope object and store it in memory
                while (scope) {
                    if (scope.cid === 'BBCtrl') {
                        break;
                    }
                    scope = scope.$$childHead;
                }

                // display the element, scope and controller for the selected element
                $bbug($window).on('dblclick', function (e) {
                    var controllerName = void 0;
                    scope = angular.element(e.target).scope();
                    var controller = scope.hasOwnProperty('controller');
                    var pscope = scope;

                    if (controller) {
                        controllerName = scope.controller;
                    }

                    while (!controller) {
                        pscope = pscope.$parent;
                        controllerName = pscope.controller;
                        controller = pscope.hasOwnProperty('controller');
                    }

                    $window.bbScope = scope;
                    $log.log(e.target);
                    $log.log($window.bbScope);
                    return $log.log('Controller ->', controllerName);
                });

                // displays the key names on the BBCtrl scope. handy to see what's been
                // stuck on the scope. if 'prop' is true it will also display properties
                $window.bbBBCtrlScopeKeyNames = function (prop) {
                    return logObjectKeys(scope, prop);
                };

                // displays the BBCtrl scope object
                $window.bbBBCtrlScope = function () {
                    return scope;
                };

                $window.bbCurrentItem = function () {
                    return scope.bb.current_item;
                };

                // displays the currentItem Object
                return $window.bbShowScopeChain = showScopeChain;
            }, 10);
        }
    })();

    return {
        logObjectKeys: logObjectKeys
    };
});
'use strict';

angular.module('BB.Services').factory('Dialog', function ($uibModal, $log, $document) {

    var controller = function controller($scope, $uibModalInstance, model, title, success, fail, body) {

        $scope.body = body;
        $scope.title = title;

        $scope.ok = function () {
            return $uibModalInstance.close(model);
        };

        $scope.cancel = function () {
            event.preventDefault();
            event.stopPropagation();
            return $uibModalInstance.dismiss('cancel');
        };

        return $uibModalInstance.result.then(function () {
            if (success) {
                return success(model);
            }
        }, function () {
            if (fail) {
                return fail();
            }
        });
    };

    return {
        confirm: function confirm(config) {
            var templateUrl = void 0;
            if (config.templateUrl) {
                templateUrl = config.templateUrl;
            }
            if (!templateUrl) {
                templateUrl = 'dialog.html';
            }
            return $uibModal.open({
                templateUrl: templateUrl,
                controller: controller,
                size: config.size || 'sm',
                resolve: {
                    model: function model() {
                        return config.model;
                    },
                    title: function title() {
                        return config.title;
                    },
                    success: function success() {
                        return config.success;
                    },
                    fail: function fail() {
                        return config.fail;
                    },
                    body: function body() {
                        return config.body;
                    }
                }
            });
        }
    };
});
'use strict';

(function () {

    angular.module('BB.Services').factory('ErrorService', ErrorService);

    function ErrorService($translate, BBAlerts) {
        /**
         * @param {String} msg
         * @returns {{msg: String}}
         */
        var createCustomError = function createCustomError(msg) {
            return { msg: msg };
        };

        /***
         * @ngdoc method
         * @name getError
         * @methodOf BB.Directives.bbServices
         * @description
         * Returns error, always setting persist to true. Returns generic error if error with given key is not found.
         */
        var getError = function getError(key) {
            var error = getAlert(key);
            // return generic error if we can't find the key
            if (!error) {
                error = getAlert('GENERIC');
            }
            error.persist = true;
            return error;
        };

        /***
         * @ngdoc method
         * @name getAlert
         * @methodOf BB.Directives.bbServices
         * @description
         * Returns alert by given key
         */
        var getAlert = function getAlert(key, translationValue) {
            var alert = _.findWhere(BBAlerts, { key: key });

            if (alert) {
                alert.msg = $translate.instant('CORE.ALERTS.' + key, { value: translationValue });
                return alert;
            } else {
                return null;
            }
        };

        return {
            createCustomError: createCustomError,
            getAlert: getAlert,
            getError: getError
        };
    }
})();
'use strict';

angular.module('BB.Services').factory("EventService", function ($q, BBModel) {

    return {
        query: function query(company, params) {
            var deferred = $q.defer();
            if (!company.$has('events')) {
                deferred.resolve([]);
            } else {
                if (params.item) {
                    if (params.item.event_group) {
                        params.event_group_id = params.item.event_group.id;
                    }
                    if (params.item.event_chain) {
                        params.event_chain_id = params.item.event_chain.id;
                    }
                    if (params.item.resource) {
                        params.resource_id = params.item.resource.id;
                    }
                    if (params.item.person) {
                        params.person_id = params.item.person.id;
                    }
                }
                params.no_cache = true;
                company.$get('events', params).then(function (resource) {
                    params.no_cache = false;
                    return resource.$get('events', params).then(function (events) {
                        events = Array.from(events).map(function (event) {
                            return new BBModel.Event(event);
                        });
                        return deferred.resolve(events);
                    });
                }, function (err) {
                    return deferred.reject(err);
                });
            }
            return deferred.promise;
        },
        summary: function summary(company, params) {
            var deferred = $q.defer();
            if (!company.$has('events')) {
                deferred.resolve([]);
            } else {
                if (params.item) {
                    if (params.item.event_group) {
                        params.event_group_id = params.item.event_group.id;
                    }
                    if (params.item.event_chain) {
                        params.event_chain_id = params.item.event_chain.id;
                    }
                    if (params.item.resource) {
                        params.resource_id = params.item.resource.id;
                    }
                    if (params.item.person) {
                        params.person_id = params.item.person.id;
                    }
                }
                params.summary = true;
                company.$get('events', params).then(function (resource) {
                    return deferred.resolve(resource.events);
                }, function (err) {
                    return deferred.reject(err);
                });
            }
            return deferred.promise;
        },
        queryEventCollection: function queryEventCollection(company, params) {
            var deferred = $q.defer();
            if (!company.$has('events')) {
                deferred.resolve([]);
            } else {
                if (params.item) {
                    if (params.item.event_group) {
                        params.event_group_id = params.item.event_group.id;
                    }
                    if (params.item.event_chain) {
                        params.event_chain_id = params.item.event_chain.id;
                    }
                    if (params.item.resource) {
                        params.resource_id = params.item.resource.id;
                    }
                    if (params.item.person) {
                        params.person_id = params.item.person.id;
                    }
                }
                company.$get('events', params).then(function (resource) {
                    var collection = new BBModel.BBCollection(resource);
                    return deferred.resolve(collection);
                }, function (err) {
                    return deferred.reject(err);
                });
            }
            return deferred.promise;
        }
    };
});
'use strict';

angular.module('BB.Services').factory("EventChainService", function ($q, BBModel) {

    return {
        query: function query(company, params) {
            var deferred = $q.defer();
            if (!company.$has('event_chains')) {
                deferred.reject("company does not have event_chains");
            } else {
                company.$get('event_chains', params).then(function (resource) {
                    return resource.$get('event_chains', params).then(function (event_chains) {
                        event_chains = Array.from(event_chains).map(function (event_chain) {
                            return new BBModel.EventChain(event_chain);
                        });
                        return deferred.resolve(event_chains);
                    });
                }, function (err) {
                    return deferred.reject(err);
                });
            }
            return deferred.promise;
        },
        queryEventChainCollection: function queryEventChainCollection(company, params) {
            var deferred = $q.defer();
            if (!company.$has('event_chains')) {
                deferred.resolve([]);
            } else {
                company.$get('event_chains', params).then(function (resource) {
                    var collection = new BBModel.BBCollection(resource);
                    return deferred.resolve(collection);
                }, function (err) {
                    return deferred.reject(err);
                });
            }
            return deferred.promise;
        }
    };
});
'use strict';

angular.module('BB.Services').factory("EventGroupService", function ($q, BBModel) {

    return {
        query: function query(company, params) {
            var deferred = $q.defer();
            if (!company.$has('event_groups')) {
                deferred.reject("company does not have event_groups");
            } else {
                company.$get('event_groups', params).then(function (resource) {
                    return resource.$get('event_groups', params).then(function (event_groups) {
                        event_groups = Array.from(event_groups).map(function (event_group) {
                            return new BBModel.EventGroup(event_group);
                        });
                        return deferred.resolve(event_groups);
                    });
                }, function (err) {
                    return deferred.reject(err);
                });
            }
            return deferred.promise;
        }
    };
});
'use strict';

angular.module('BB.Services').factory("EventSequenceService", function ($q, BBModel) {

    return {
        query: function query(company, params) {
            var deferred = $q.defer();
            if (!company.$has('event_sequences')) {
                deferred.reject("company does not have event_sequences");
            } else {
                company.$get('event_sequences', params).then(function (resource) {
                    return resource.$get('event_sequences', params).then(function (event_sequences) {
                        event_sequences = Array.from(event_sequences).map(function (event_sequence) {
                            return new BBModel.EventSequence(event_sequence);
                        });
                        return deferred.resolve(event_sequences);
                    });
                }, function (err) {
                    return deferred.reject(err);
                });
            }
            return deferred.promise;
        }
    };
});
'use strict';

// Filters
angular.module('BB.Services').factory('FormDataStoreService', function ($rootScope, $window, $log, $parse) {

    var registeredWidgetArr = [];
    var dataStore = {};
    var toId = 0; // timeout id
    var div = '___';

    // enabale this to see datastore log info
    var log = function log() {};
    //  $log.debug.apply(this, arguments)

    // displays datastore info. only handy for development purposes
    var showInfo = function showInfo() {
        return log(dataStore);
    };
    // log registeredWidgetArr

    // utility to set values on the scope if they are undefined. avoids issue if
    // value is false.
    var setIfUndefined = function setIfUndefined(keyName, val) {
        var scope = this;
        var getter = $parse(keyName);

        if (typeof getter(scope) === 'undefined') {
            return getter.assign(scope, val);
        }
    };

    // resets the scope values. when the clear method is called it removes the
    // values from the datastore but it doesn't reset the values on the scope,
    // which means the values on the scope are added back into the datastore on the
    // next digest. so we have to reset them as well.
    var resetValuesOnScope = function resetValuesOnScope(scope, props) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = Array.from(props)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var prop = _step.value;

                prop = $parse(prop);
                var setter = prop.assign;
                setter(scope, null);
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    };

    // clear all form data stored in dataStore if scope is passed in. if datastore
    // key is passed in then just delete that instance. 'keepScopeValues' stops the
    // values on the scope object being reset. so the datastore is cleared but not
    // the scope. this is really only necessary when the destroy method is called.
    var clear = function clear(scope, keepScopeValues) {
        var data = void 0;
        if (!scope) {
            throw new Error('Missing scope object. Cannot clear form data without scope');
        }

        // check for datastore key first
        if (_.isString(scope)) {
            data = dataStore[scope];
            if (!keepScopeValues) {
                resetValuesOnScope(data[0], data[1]);
            }
            delete dataStore[scope];
            return;
        }

        scope = getParentScope(scope);
        // destroy all data
        if (scope && scope.bb) {
            var widgetId = scope.bb.uid;
            removeWidget(scope);

            for (var key in dataStore) {
                data = dataStore[key];
                if (key.indexOf(widgetId) !== -1) {
                    // remove any event handlers if the have been set in setListeners().
                    if (data[3]) {
                        _.each(data[3], function (func) {
                            // angular returns a function when setting listeners, which when
                            // called removes the listener.
                            if (_.isFunction(func)) {
                                return func();
                            }
                        });
                    }
                    // remove the stored data
                    if (!keepScopeValues) {
                        resetValuesOnScope(data[0], data[1]);
                    }
                    delete dataStore[key];
                }
            }
        }
    };

    // called after digest loop finishes. loop through the properties on the scope
    // and store the values if they are registered
    var storeFormData = function storeFormData() {
        log('formDataStore ->', dataStore);
        for (var key in dataStore) {
            var step = dataStore[key];
            log('\t', key);
            var scope = step[0]; // scope object
            var props = step[1]; // array of key names
            var ndata = step[2]; // object containing stored values, matching names in props

            if (!ndata) {
                ndata = step[2] = {};
            }

            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = Array.from(props)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var prop = _step2.value;

                    var val = ndata[prop];
                    // destroy the data here
                    if (val === 'data:destroyed') {
                        ndata[prop] = null;
                    } else {
                        val = angular.copy(scope.$eval(prop));
                        ndata[prop] = val;
                    }
                    log('\t\t', prop, val);
                }
                // log 1, step
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            log('\n');
        }
    };

    // put the stored values back onto the scope object.
    var setValuesOnScope = function setValuesOnScope(currentPage, scope) {
        var cpage = dataStore[currentPage];
        var storedValues = cpage[2];
        log('Decorating scope ->', currentPage, storedValues);

        if (_.isObject(storedValues)) {
            _.each(_.keys(storedValues), function (keyName) {
                if (typeof storedValues[keyName] !== 'undefined' && storedValues[keyName] !== 'data:destroyed') {
                    // parse the keyname as it might be stored as using dot notation i.e.
                    // {"admin.person.age" : someval} needs to be parsed unless the value
                    // will be stored on the scope as "admin.person.age" and not a nested
                    // object as it should be
                    var getter = $parse(keyName);
                    return getter.assign(scope, storedValues[keyName]);
                }
            });
        }

        cpage[0] = scope;
        log(scope);
        log('\n');
    };

    // returns the BBCtrl scope from the supplied scope by walking up the scope
    // chain looking for it's controller id
    var getParentScope = function getParentScope(scope) {
        while (scope) {
            // find the controller's rootscope
            if (scope.hasOwnProperty('cid') && scope.cid === 'BBCtrl') {
                return scope;
            }
            scope = scope.$parent;
        }
    };

    // the scope argument belongs to the controller which is requesting data to be
    // stored. we check if it's parent widget (BBCtrl) has been registered to store
    // data. BBCtrl is the root scope for all booking journeys.
    var checkRegisteredWidgets = function checkRegisteredWidgets(scope) {
        var isRegistered = false;
        scope = getParentScope(scope);

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
            for (var _iterator3 = Array.from(registeredWidgetArr)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var rscope = _step3.value;

                if (rscope === scope) {
                    isRegistered = true;
                }
            }
        } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                    _iterator3.return();
                }
            } finally {
                if (_didIteratorError3) {
                    throw _iteratorError3;
                }
            }
        }

        return isRegistered;
    };

    // generates an array of listeners and normalises the properties to be stored
    // i.e. 'bb.stacked_items->change:storeLocation' becomes
    // ['bb.stacked_items'] ['change:storeLocation']
    var checkForListeners = function checkForListeners(propsArr) {
        var watchArr = [];
        _.each(propsArr, function (propName, index) {
            var split = propName.split('->');
            if (split.length === 2) {
                watchArr.push(split);
                return propsArr[index] = split[0];
            }
        });

        return watchArr;
    };

    // creates the listeners for any items that require them and then destroy their
    // data if the eventhandler is called. i.e. registering the following
    // 'bb.stacked_items->change:storeLocation'
    // means the data on '$scope.bb.stack_items' will be stored unless the event
    // 'change:storeLocation', at which point the data will be cleared
    var setListeners = function setListeners(scope, listenerArr, currentPage) {
        if (listenerArr.length) {
            var cpage = dataStore[currentPage];
            var listenersArr = cpage[3] || [];

            _.each(listenerArr, function (item, index) {
                var func = $rootScope.$on(item[1], function () {
                    // because of the async nature of events we can't just null the data
                    // here as it could be restored in the storeFormData() method, which
                    // runs after the digest loop has finished. so we mark it as destroyed
                    try {
                        return cpage[2][item[0]] = 'data:destroyed';
                    } catch (e) {
                        return log(e);
                    }
                });
                // store the registered listeners so we can remove when the widget is
                // destroyed
                return listenersArr.push(func);
            });
            // store the listeners along with the other widget information
            return cpage[3] = listenersArr;
        }
    };

    // uid is used along with the 'current_page' property and widget uid to create
    // an individual keyname to store the values. we do this as there can be
    // multiple widgets containing multiple controllers on a single page. the
    // 'propsArr' array contains a list of key names on the scope which are to  be
    // stored i.e. ['name', 'email', 'address1']
    var init = function init(uid, scope, propsArr) {
        if (checkRegisteredWidgets(scope)) {
            var currentPage = scope.bb.uid + div + scope.bb.current_page + div + uid;
            currentPage = currentPage.toLowerCase();
            var watchArr = checkForListeners(propsArr);
            // return a function which has the current page as a closure. the
            // controller which is initalising the form data can call this at any point
            // to clear the data for it's controller .i.e $scope.clearStoredData()
            scope.clearStoredData = function (currentPage) {
                return function () {
                    clear(currentPage);
                };
            }(currentPage);

            if (!currentPage) {
                throw new Error("Missing current step");
            }

            // if the step exists return the values as the form has been there before.
            if (dataStore[currentPage]) {
                setValuesOnScope(currentPage, scope);
                return;
            }

            log('Controller registered ->', currentPage, scope, '\n\n');
            dataStore[currentPage] = [scope, propsArr];
            setListeners(scope, watchArr, currentPage);
            return;
        }
    };

    // remove any registered scopes from the array when they are destroyed
    var removeWidget = function removeWidget(scope) {
        registeredWidgetArr = _.without(registeredWidgetArr, scope);
    };

    // the service will only store data for widgets which have registered
    // themselves with the store. the scope object should always be BBCtrl's scope
    // object which is always the root scope for all widgets
    var register = function register(scope) {
        var registered = false;
        // go up the scope chain to find the app's rootscope, which will be the scope
        // with the bbctrl property

        // step down a scope first - just in case this is on the same as the widget and iot's isloated!
        if (scope && scope.$$childHead) {
            scope = scope.$$childHead;
        }

        while (!_.has(scope, 'cid')) {
            scope = scope.$parent;
        }

        if (!scope) {
            return;
        }

        if (scope.cid !== 'BBCtrl') {
            throw new Error("This directive can only be used with the BBCtrl");
        }
        // check to make sure scope isn't already registered.
        _.each(registeredWidgetArr, function (stored) {
            if (scope === stored) {
                return registered = true;
            }
        });

        if (!registered) {
            log('Scope registered ->', scope);
            scope.$on('destroy', removeWidget);
            return registeredWidgetArr.push(scope);
        }
    };

    // when digest loop is triggered wait until after the last loop is run and then
    // store the values
    $rootScope.$watch(function () {
        $window.clearTimeout(toId);
        toId = setTimeout(storeFormData, 300);
    });

    $rootScope.$on('save:formData', storeFormData);
    $rootScope.$on('clear:formData', clear);

    return {
        init: init,
        destroy: function destroy(scope) {
            return clear(scope, true);
        },

        showInfo: showInfo,
        register: register,
        setIfUndefined: setIfUndefined
    };
});
'use strict';

angular.module('BB.Services').provider('FormTransform', function () {

    var options = { new: {}, edit: {} };

    this.getTransform = function (type, model) {
        return options[type][model];
    };

    this.setTransform = function (type, model, fn) {
        return options[type][model] = fn;
    };

    this.$get = function () {
        return options;
    };
});
'use strict';

/**
 * @ngdoc service
 * @module BB.Services
 * @name GeneralOptions
 *
 * @description
 * Returns a set of General configuration options
 */

/**
 * @ngdoc service
 * @module BB.Services
 * @name GeneralOptionsProvider
 *
 * @description
 * Provider
 *
 * @example
 <pre module='BB.Services.GeneralOptionsProvider'>
     angular.module('ExampleModule').config ['GeneralOptionsProvider', (GeneralOptionsProvider) ->
     GeneralOptionsProvider.setOption('twelve_hour_format', true)
     ]
 </pre>
 */
angular.module('BB.Services').provider('GeneralOptions', function () {

    var options = {
        twelve_hour_format: false,
        calendar_minute_step: 5,
        calendar_slot_duration: 5,
        update_document_title: false,
        scroll_offset: 0,
        map_marker_icon: null,
        mapActiveMarkerIcon: null,
        map_layout: 'default',
        companyHasExternalBookings: false,
        mapMarkerHasLabel: true,
        maxAdvanceDatetimeDays: null,
        calendarDaysByScreenWidth: { lg: 7, md: 5, sm: 3, xs: 1 }
    };

    this.setOption = function (option, value) {
        if (options.hasOwnProperty(option)) {
            options[option] = value;
        }
    };

    this.$get = function () {
        return options;
    };
});
'use strict';

angular.module('BB.Services').factory('GeolocationService', function ($q) {

    return {
        haversine: function haversine(position1, position2) {
            var pi = Math.PI;
            var R = 6371; //equatorial radius

            var lat1 = position1.lat;
            var lon1 = position1.long;

            var lat2 = position2.lat;
            var lon2 = position2.long;

            var chLat = lat2 - lat1;
            var chLon = lon2 - lon1;

            var dLat = chLat * (pi / 180);
            var dLon = chLon * (pi / 180);

            var rLat1 = lat1 * (pi / 180);
            var rLat2 = lat2 * (pi / 180);

            var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(rLat1) * Math.cos(rLat2);
            var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            var d = R * c;

            return d;
        },
        geocode: function geocode(address, prms) {

            if (prms == null) {
                prms = {};
            }
            var deferred = $q.defer();
            var request = { address: address };
            if (prms.region) {
                request.region = prms.region;
            }
            if (prms.componentRestrictions) {
                request.componentRestrictions = prms.componentRestrictions;
            }

            if (prms.bounds) {
                var sw = new google.maps.LatLng(prms.bounds.sw.x, prms.bounds.sw.y);
                var ne = new google.maps.LatLng(prms.bounds.ne.x, prms.bounds.ne.y);
                request.bounds = new google.maps.LatLngBounds(sw, ne);
            }

            new google.maps.Geocoder().geocode(request, function (results, status) {
                if (results && status === 'OK') {
                    return deferred.resolve({ results: results, status: status });
                } else {
                    return deferred.reject(status);
                }
            });

            return deferred.promise;
        }
    };
});
'use strict';

angular.module('BB.Services').factory("ItemService", function ($q, BBModel) {
    return {
        query: function query(prms) {
            var _this = this;

            var deferred = $q.defer();
            if (prms.cItem.service && prms.item !== 'service') {
                if (!prms.cItem.service.$has('items')) {
                    prms.cItem.service.$get('item').then(function (base_item) {
                        return _this.build_items(base_item.$get('items'), prms, deferred);
                    });
                } else {
                    this.build_items(prms.cItem.service.$get('items'), prms, deferred);
                }
            } else if (prms.cItem.resource && !prms.cItem.anyResource() && prms.item !== 'resource') {
                if (!prms.cItem.resource.$has('items')) {
                    prms.cItem.resource.$get('item').then(function (base_item) {
                        return _this.build_items(base_item.$get('items'), prms, deferred);
                    });
                } else {
                    this.build_items(prms.cItem.resource.$get('items'), prms, deferred);
                }
            } else if (prms.cItem.person && !prms.cItem.anyPerson() && prms.item !== 'person') {
                if (!prms.cItem.person.$has('items')) {
                    prms.cItem.person.$get('item').then(function (base_item) {
                        return _this.build_items(base_item.$get('items'), prms, deferred);
                    });
                } else {
                    this.build_items(prms.cItem.person.$get('items'), prms, deferred);
                }
            } else {
                deferred.reject("No service link found");
            }

            return deferred.promise;
        },
        build_items: function build_items(base_items, prms, deferred) {
            var wait_items = [base_items];
            if (prms.wait) {
                wait_items.push(prms.wait);
            }
            return $q.all(wait_items).then(function (resources) {
                var resource = resources[0]; // the first one was my own data
                return resource.$get('items').then(function (found) {
                    var matching = [];
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = Array.from(found)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var v = _step.value;

                            if (v.type === prms.item) {
                                matching.push(new BBModel.BookableItem(v));
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }

                    return $q.all(Array.from(matching).map(function (m) {
                        return m.ready.promise;
                    })).then(function () {
                        return deferred.resolve(matching);
                    });
                });
            });
        }
    };
});
'use strict';

angular.module('BB.Services').factory("ItemDetailsService", function ($q, BBModel) {

    return {
        query: function query(prms) {
            var deferred = $q.defer();
            if (prms.cItem.service) {
                if (!prms.cItem.service.$has('questions')) {
                    deferred.resolve(new BBModel.ItemDetails());
                } else {
                    prms.cItem.service.$get('questions').then(function (details) {
                        return deferred.resolve(new BBModel.ItemDetails(details));
                    }, function (err) {
                        return deferred.reject(err);
                    });
                }
            } else if (prms.cItem.event_chain) {
                if (!prms.cItem.event_chain.$has('questions')) {
                    deferred.resolve(new BBModel.ItemDetails());
                } else {
                    prms.cItem.event_chain.$get('questions').then(function (details) {
                        return deferred.resolve(new BBModel.ItemDetails(details));
                    }, function (err) {
                        return deferred.reject(err);
                    });
                }
            } else if (prms.cItem.deal) {
                if (!prms.cItem.deal.$has('questions')) {
                    deferred.resolve(new BBModel.ItemDetails());
                } else {
                    prms.cItem.deal.$get('questions').then(function (details) {
                        return deferred.resolve(new BBModel.ItemDetails(details));
                    }, function (err) {
                        return deferred.reject(err);
                    });
                }
            } else {
                deferred.resolve();
            }
            return deferred.promise;
        }
    };
});
'use strict';

angular.module('BB.Services').factory('LoadingService', function ($q, $window, $log, $rootScope, AlertService, ErrorService) {

    // create a trackable loader - this in theory allows multiple trackable loading objects in a scope - meaning we're not tied to a per-scope faction
    // currently it's still just using the scope to store the status, but we're encapsulating it away so that we can change it later
    return {
        $loader: function $loader(scope) {

            var lservice = this;
            var item = {
                scope: scope,
                setLoaded: function setLoaded() {
                    return lservice.setLoaded(scope);
                },
                setLoadedAndShowError: function setLoadedAndShowError(err, error_string) {
                    return lservice.setLoadedAndShowError(scope, err, error_string);
                },
                notLoaded: function notLoaded() {
                    lservice.notLoaded(scope);
                    return this; // return self, so you can create at set not loaded in a single line
                }
            };
            return item;
        },


        // called from the scopes
        setLoaded: function setLoaded(cscope) {
            cscope.$emit('hide:loader', cscope);
            // set the scope loaded to true...
            cscope.isLoaded = true;
            // then walk up the scope chain looking for the 'loading' scope...
            var loadingFinished = true;

            while (cscope) {
                if (cscope.hasOwnProperty('scopeLoaded')) {
                    // then check all the scope objects looking to see if any scopes are
                    // still loading
                    if (this.areScopesLoaded(cscope)) {
                        cscope.scopeLoaded = true;
                    } else {
                        loadingFinished = false;
                    }
                }
                cscope = cscope.$parent;
            }

            if (loadingFinished) {
                $rootScope.$broadcast('loading:finished');
            }
        },
        setLoadedAndShowError: function setLoadedAndShowError(scope, err, error_string) {
            $log.warn(err, error_string);
            scope.setLoaded(scope);
            if (err && err.status === 409) {
                return AlertService.danger(ErrorService.getError('ITEM_NO_LONGER_AVAILABLE'));
            } else if (err.data && err.data.error === "Number of Bookings exceeds the maximum") {
                return AlertService.danger(ErrorService.getError('MAXIMUM_TICKETS'));
            } else if (err.status === 404) {
                // display an error message if it's set via backend, otherwise use the default one
                return AlertService.danger(err.data.error ? { msg: err.data.error } : ErrorService.getError('GENERIC'));
            } else {
                return AlertService.danger(ErrorService.getError('GENERIC'));
            }
        },


        // go around schild scopes - return false if *any* child scope is marked as
        // isLoaded = false
        areScopesLoaded: function areScopesLoaded(cscope) {
            if (cscope.hasOwnProperty('isLoaded') && !cscope.isLoaded) {
                return false;
            } else {
                var child = cscope.$$childHead;
                while (child) {
                    if (!this.areScopesLoaded(child)) {
                        return false;
                    }
                    child = child.$$nextSibling;
                }
                return true;
            }
        },


        //set scope not loaded...
        notLoaded: function notLoaded(cscope) {
            cscope.$emit('show:loader', cscope);
            cscope.isLoaded = false;
            // then look through all the scopes for the 'loading' scope, which is the
            // scope which has a 'scopeLoaded' property and set it to false, which makes
            // the ladoing gif show
            while (cscope) {
                if (cscope.hasOwnProperty('scopeLoaded')) {
                    cscope.scopeLoaded = false;
                }
                cscope = cscope.$parent;
            }
        }
    };
});
'use strict';

angular.module('BB.Services').factory("LoginService", function ($q, halClient, $rootScope, BBModel, $sessionStorage, $localStorage) {
    return {
        companyLogin: function companyLogin(company, params, form) {
            var _this = this;

            var deferred = $q.defer();
            company.$post('login', params, form).then(function (login) {
                return login.$get('member').then(function (member) {
                    _this.setLogin(member);
                    return deferred.resolve(member);
                }, function (err) {
                    return deferred.reject(err);
                });
            }, function (err) {
                return deferred.reject(err);
            });
            return deferred.promise;
        },
        login: function login(form, options) {
            var _this2 = this;

            var deferred = $q.defer();
            if (!options['root']) {
                options['root'] = "";
            }
            var url = options['root'] + "/api/v1/login";
            halClient.$post(url, options, form).then(function (login) {
                return login.$get('member').then(function (member) {
                    _this2.setLogin(member);
                    return deferred.resolve(member);
                });
            }, function (err) {
                return deferred.reject(err);
            });
            return deferred.promise;
        },
        FBLogin: function FBLogin(company, prms) {
            var _this3 = this;

            var deferred = $q.defer();
            company.$post('facebook_login', {}, prms).then(function (login) {
                return login.$get('member').then(function (member) {
                    member = new BBModel.Member.Member(member);
                    $sessionStorage.setItem("fb_user", true);
                    _this3.setLogin(member);
                    return deferred.resolve(member);
                }, function (err) {
                    return deferred.reject(err);
                });
            }, function (err) {
                return deferred.reject(err);
            });
            return deferred.promise;
        },


        companyQuery: function companyQuery(id) {
            if (id) {
                var comp_promise = halClient.$get(location.protocol + '//' + location.host + '/api/v1/company/' + id);
                return comp_promise.then(function (company) {
                    return company = new BBModel.Company(company);
                });
            }
        },

        memberQuery: function memberQuery(params) {
            if (params.member_id && params.company_id) {
                var member_promise = halClient.$get(location.protocol + '//' + location.host + ('/api/v1/' + params.company_id + '/') + "members/" + params.member_id);
                return member_promise.then(function (member) {
                    return member = new BBModel.Member.Member(member);
                });
            }
        },

        ssoLogin: function ssoLogin(options, data) {
            var _this4 = this;

            var deferred = $q.defer();
            if (!options['root']) {
                options['root'] = "";
            }
            var url = options['root'] + "/api/v1/login/sso/" + options['company_id'];
            halClient.$post(url, {}, data).then(function (login) {
                return login.$get('member').then(function (member) {
                    member = new BBModel.Member.Member(member);
                    _this4.setLogin(member, true);
                    return deferred.resolve(member);
                });
            }, function (err) {
                return deferred.reject(err);
            });
            return deferred.promise;
        },


        // check if we're logged in as a member - but not an admin
        isLoggedIn: function isLoggedIn() {

            this.checkLogin();
            return $rootScope.member && (!$rootScope.user || $rootScope.user === undefined);
        },
        setLogin: function setLogin(member, persist) {
            var auth_token = member.getOption('auth_token');

            member = new BBModel.Member.Member(member);
            $sessionStorage.setItem("login", member.$toStore());
            $sessionStorage.setItem("auth_token", auth_token);
            $rootScope.member = member;
            if (persist) {
                // save both auth_token and login to re-use them
                $localStorage.setItem("auth_token", auth_token);
                $localStorage.setItem("login", member.$toStore());
            }

            return member;
        },
        member: function member() {
            this.checkLogin();
            return $rootScope.member;
        },
        checkLogin: function checkLogin() {

            if ($rootScope.member) {
                return true;
            }

            // check if the user is logged in persistently or is logged in for this session only
            var member = $localStorage.getItem("login") || $sessionStorage.getItem("login");

            if (member) {
                member = halClient.createResource(member);
                $rootScope.member = new BBModel.Member.Member(member);
                return true;
            } else {
                return false;
            }
        },
        logout: function logout(options) {
            $rootScope.member = null;

            var deferred = $q.defer();

            if (!options) {
                options = {};
            }
            if (!options['root']) {
                options['root'] = "";
            }
            var url = options['root'] + "/api/v1/logout";

            $sessionStorage.clear();
            $localStorage.clear();

            halClient.$del(url, options, {}).then(function (logout) {
                $sessionStorage.clear();
                $localStorage.clear();
                return deferred.resolve(true);
            }, function (err) {
                return deferred.reject(err);
            });
            return deferred.promise;
        },
        FBLogout: function FBLogout(options) {
            $sessionStorage.removeItem("fb_user");
            return this.logout(options);
        },
        sendPasswordReset: function sendPasswordReset(company, params) {
            var deferred = $q.defer();
            company.$post('email_password_reset', {}, params).then(function () {
                return deferred.resolve(true);
            }, function (err) {
                return deferred.reject(err);
            });
            return deferred.promise;
        },
        updatePassword: function updatePassword(member, params) {
            var _this5 = this;

            params.auth_token = member.getOption('auth_token');
            if (member && params['new_password'] && params['confirm_new_password']) {
                var deferred = $q.defer();
                member.$post('update_password', {}, params).then(function (login) {
                    return login.$get('member').then(function (member) {
                        _this5.setLogin(member, params.persist_login);
                        return deferred.resolve(member);
                    }, function (err) {
                        return deferred.reject(err);
                    });
                }, function (err) {
                    return deferred.reject(err);
                });
                return deferred.promise;
            }
        }
    };
});
"use strict";

angular.module('BB.Services').factory("MembershipLevelsService", function ($q, BBModel) {

    return {
        getMembershipLevels: function getMembershipLevels(company) {
            var deferred = $q.defer();
            company.$get("member_levels").then(function (resource) {
                return resource.$get('membership_levels').then(function (membership_levels) {
                    var levels = Array.from(membership_levels).map(function (level) {
                        return new BBModel.MembershipLevel(level);
                    });
                    return deferred.resolve(levels);
                });
            }, function (err) {
                return deferred.reject(err);
            });
            return deferred.promise;
        }
    };
});
'use strict';

(function () {

    var newFormCtrl = function newFormCtrl($scope, $uibModalInstance, company, title, new_rel, post_rel, successFn, failFn, $document, $log) {
        $scope.loading = true;
        $scope.title = title;
        $scope.company = company;
        if ($scope.company.$has(new_rel)) {
            $scope.company.$get(new_rel).then(function (schema) {
                $scope.form = _.reject(schema.form, function (x) {
                    return x.type === 'submit';
                });
                $scope.schema = checkSchema(schema.schema);
                $scope.form_model = {};
                return $scope.loading = false;
            });
        } else {
            $log.warn('company does not have \'' + new_rel + '\' rel');
        }

        $scope.submit = function (form) {
            $scope.$broadcast('schemaFormValidate');
            $scope.loading = true;
            return $scope.company.$post(post_rel, {}, $scope.form_model).then(function (model) {
                $scope.loading = false;
                $uibModalInstance.close(model);
                if (successFn) {
                    return successFn(model);
                }
            }, function (err) {
                $scope.loading = false;
                $uibModalInstance.close(err);
                $log.error('Failed to create');
                if (failFn) {
                    return failFn(err);
                }
            });
        };

        return $scope.cancel = function (event) {
            event.preventDefault();
            event.stopPropagation();
            return $uibModalInstance.dismiss('cancel');
        };
    };

    // THIS IS CRUFTY AND SHOULD BE REMOVE WITH AN API UPDATE THAT TIDIES UP THE SCEMA RESPONE
    // fix the issues we have with the the sub client and question blocks being in doted notation, and not in child objects
    var checkSchema = function checkSchema(schema) {
        for (var k in schema.properties) {
            var v = schema.properties[k];
            var vals = k.split(".");
            if (vals[0] === "questions" && vals.length > 1) {
                if (!schema.properties.questions) {
                    schema.properties.questions = { type: "object", properties: {} };
                }
                if (!schema.properties.questions.properties[vals[1]]) {
                    schema.properties.questions.properties[vals[1]] = { type: "object", properties: { answer: v } };
                }
            }
            if (vals[0] === "client" && vals.length > 2) {
                if (!schema.properties.client) {
                    schema.properties.client = { type: "object", properties: { q: { type: "object", properties: {} } } };
                }
                if (schema.properties.client.properties) {
                    if (!schema.properties.client.properties.q.properties[vals[2]]) {
                        schema.properties.client.properties.q.properties[vals[2]] = {
                            type: "object",
                            properties: { answer: v }
                        };
                    }
                }
            }
        }
        return schema;
    };

    var editFormCtrl = function editFormCtrl($scope, $uibModal, $uibModalInstance, model, title, successFn, failFn, params, $document, $log, Dialog, FormTransform, $translate, bbTimeZone, CompanyStoreService) {
        $scope.loading = true;
        $scope.title = title;
        $scope.model = model;
        if (!params) {
            params = {};
        }
        if ($scope.model.$has('edit')) {
            $scope.model.$get('edit', params).then(function (schema) {
                $scope.form = _.reject(schema.form, function (x) {
                    return x.type === 'submit';
                });
                var model_type = functionName(model.constructor);
                if (model_type === 'Object' && model.type) {
                    model_type = model.type;
                }
                if (FormTransform['edit'][model_type]) {
                    $scope.form = FormTransform['edit'][model_type]($scope.form, schema.schema, $scope.model);
                }
                $scope.schema = checkSchema(schema.schema);
                $scope.form_model = $scope.model;
                return $scope.loading = false;
            });
        } else {
            $log.warn("model does not have 'edit' rel");
        }

        var functionName = function functionName(func) {
            var result = /^function\s+([\w\$]+)\s*\(/.exec(func.toString());
            if (result) {
                return result[1];
            } else {
                return '';
            }
        };

        $scope.submit = function (form) {
            $scope.$broadcast('schemaFormValidate');
            $scope.loading = true;

            if ($scope.model.$update) {

                /*if(bbTimeZone.isCustomTimeZone()){
                    $scope.form_model.datetime = moment($scope.form_model.datetime).tz(CompanyStoreService.time_zone);
                }*/ //TODO double check

                $scope.form_model.datetime = bbTimeZone.convertToCompany($scope.form_model.datetime);

                $scope.model.$update($scope.form_model).then(function () {

                    $scope.loading = false;
                    $uibModalInstance.close($scope.model);
                    if (successFn) {
                        return successFn($scope.model);
                    }
                }, function (err) {
                    $scope.loading = false;
                    $uibModalInstance.close(err);
                    $log.error('Failed to create');
                    if (failFn) {
                        return failFn();
                    }
                });
            } else {
                return $scope.model.$put('self', {}, $scope.form_model).then(function (model) {
                    $scope.loading = false;
                    $uibModalInstance.close(model);
                    if (successFn) {
                        return successFn(model);
                    }
                }, function (err) {
                    $scope.loading = false;
                    $uibModalInstance.close(err);
                    $log.error('Failed to create');
                    if (failFn) {
                        return failFn();
                    }
                });
            }
        };

        $scope.cancel = function (event) {
            event.preventDefault();
            event.stopPropagation();
            return $uibModalInstance.dismiss('cancel');
        };

        $scope.success = function (response) {
            event.preventDefault();
            event.stopPropagation();
            $uibModalInstance.close();
            if (successFn) {
                return successFn(response);
            }
        };

        return $scope.cancelEvent = function (event, type) {
            if (type == null) {
                type = 'booking';
            }
            event.preventDefault();
            event.stopPropagation();
            $uibModalInstance.close();
            if (type === 'booking') {
                var modal_instance = $uibModal.open({

                    templateUrl: 'cancel_booking_modal_form.html',
                    controller: function controller($scope, booking) {
                        $scope.booking = booking;
                        return $scope.model = {
                            notify: false,
                            cancel_reason: null
                        };
                    },

                    resolve: {
                        booking: function booking() {
                            return model;
                        }
                    }
                });
                return modal_instance.result.then(function (params) {
                    return model.$post('cancel', params).then(function (booking) {
                        if (successFn) {
                            return successFn(booking);
                        }
                    });
                });
            } else {
                var question = null;
                question = $translate.instant('CORE.MODAL.CANCEL_BOOKING.QUESTION', { type: type });

                return Dialog.confirm({
                    model: model,
                    title: $translate.instant('CORE.MODAL.CANCEL_BOOKING.HEADER'),
                    body: question,
                    success: function success(model) {
                        return model.$del('self').then(function (response) {
                            if (successFn) {
                                return successFn(response);
                            }
                        });
                    }
                });
            }
        };
    };

    var bookFormCtrl = function bookFormCtrl($scope, $uibModalInstance, model, company, title, successFn, $document, $log) {
        $scope.loading = true;
        $scope.title = title;
        $scope.model = model;
        $scope.company = company;
        if ($scope.model.$has('new_booking')) {
            $scope.model.$get('new_booking').then(function (schema) {
                $scope.form = _.reject(schema.form, function (x) {
                    return x.type === 'submit';
                });
                $scope.schema = checkSchema(schema.schema);
                $scope.form_model = {};
                return $scope.loading = false;
            });
        } else {
            $log.warn("model does not have 'new_booking' rel");
        }

        $scope.submit = function (form) {
            $scope.$broadcast('schemaFormValidate');
            if (form.$valid) {
                $scope.loading = true;
                return $scope.company.$post('bookings', {}, $scope.form_model).then(function (booking) {
                    $scope.loading = false;
                    $uibModalInstance.close(booking);
                    if (successFn) {
                        return successFn(booking);
                    }
                }, function (err) {
                    $scope.loading = false;
                    $uibModalInstance.close(err);
                    $log.error('Failed to create');
                    if (fail) {
                        return fail();
                    }
                });
            } else {
                return $log.warn('Invalid form');
            }
        };

        return $scope.cancel = function (event) {
            event.preventDefault();
            event.stopPropagation();
            return $uibModalInstance.dismiss('cancel');
        };
    };

    angular.module('BB.Services').factory('ModalForm', function ($uibModal) {

        return {
            new: function _new(config) {
                var templateUrl = void 0;
                if (config.templateUrl) {
                    templateUrl = config.templateUrl;
                }
                if (!templateUrl) {
                    templateUrl = 'modal_form.html';
                }
                return $uibModal.open({
                    templateUrl: templateUrl,
                    controller: newFormCtrl,
                    size: config.size,
                    resolve: {
                        company: function company() {
                            return config.company;
                        },
                        title: function title() {
                            return config.title;
                        },
                        new_rel: function new_rel() {
                            return config.new_rel;
                        },
                        post_rel: function post_rel() {
                            return config.post_rel;
                        },
                        successFn: function successFn() {
                            return config.success;
                        },
                        failFn: function failFn() {
                            return config.fail;
                        }
                    }
                });
            },
            edit: function edit(config) {
                var templateUrl = void 0;
                if (config.templateUrl) {
                    templateUrl = config.templateUrl;
                }
                if (!templateUrl) {
                    templateUrl = 'modal_form.html';
                }
                return $uibModal.open({
                    templateUrl: templateUrl,
                    controller: editFormCtrl,
                    size: config.size,
                    resolve: {
                        model: function model() {
                            return config.model;
                        },
                        title: function title() {
                            return config.title;
                        },
                        successFn: function successFn() {
                            return config.success;
                        },
                        failFn: function failFn() {
                            return config.fail;
                        },
                        params: function params() {
                            return config.params || {};
                        }
                    }
                });
            },
            book: function book(config) {
                var templateUrl = void 0;
                if (config.templateUrl) {
                    templateUrl = config.templateUrl;
                }
                if (!templateUrl) {
                    templateUrl = 'modal_form.html';
                }
                return $uibModal.open({
                    templateUrl: templateUrl,
                    controller: bookFormCtrl,
                    size: config.size,
                    resolve: {
                        model: function model() {
                            return config.model;
                        },
                        company: function company() {
                            return config.company;
                        },
                        title: function title() {
                            return config.title;
                        },
                        successFn: function successFn() {
                            return config.success;
                        },
                        failFn: function failFn() {
                            return config.fail;
                        }
                    }
                });
            }
        };
    });
})();
"use strict";

angular.module('BB.Services').factory("MutexService", function ($q, $window, $rootScope) {

    return {
        getLock: function getLock(prms) {
            // create 2 local promises - one to pass back, to the link on
            var mprom = $q.defer();
            var iprom = $q.defer();

            mprom.promise.then(function () {
                // pop the next mutex
                $rootScope.mutexes.shift();
                if ($rootScope.mutexes.length > 0) {
                    var next_mux = $rootScope.mutexes[0];
                    return next_mux.iprom.resolve(next_mux.mprom);
                }
            });

            if (!$rootScope.mutexes || $rootScope.mutexes.length === 0) {
                // create a queue of mutexes that are waiting to be re
                $rootScope.mutexes = [{ mprom: mprom, iprom: iprom }];
                iprom.resolve(mprom);
                return iprom.promise;
            } else {
                // push the new promise and resolve
                $rootScope.mutexes.push({ mprom: mprom, iprom: iprom });
                return iprom.promise;
            }
        },
        unlock: function unlock(mutex) {
            // remove this mutex and resolve the next
            return mutex.resolve();
        }
    };
});
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

(function (angular) {
    angular.module('BB.Services').provider('bbOptions', function () {
        'ngInject';

        function isObjectProperty(prop) {
            return (typeof prop === 'undefined' ? 'undefined' : _typeof(prop)) === 'object' && !Array.isArray(prop) && prop !== null;
        }

        function setOption(options, option, value) {
            guardNonExistingProperty(options, option);

            if (value === undefined) return Object.assign({}, options);

            if (!isObjectProperty(options[option])) {
                guardNonObjectProps(options, option, value);

                return angular.merge({}, options, _defineProperty({}, option, value));
            }

            guardNonObjectValue(options, value);

            var guardedVal = Object.assign({}, options[option]);
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = Object.entries(value)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var _step$value = _slicedToArray(_step.value, 1),
                        key = _step$value[0];

                    guardedVal = setOption(guardedVal, key, value[key]);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return angular.merge({}, options, _defineProperty({}, option, guardedVal));
        }

        function guardNonExistingProperty(options, option) {
            if (!options.hasOwnProperty(option)) throw new Error('no option named:' + option);
        }

        function guardNonObjectProps(options, option, value) {
            if (_typeof(options[option]) !== (typeof value === 'undefined' ? 'undefined' : _typeof(value)) || Array.isArray(options[option]) !== Array.isArray(value)) {
                throw new Error('option "' + option + '" required type is "' + (Array.isArray(options[option]) ? 'array' : _typeof(options[option])) + '"');
            }
        }

        function guardNonObjectValue(option, value) {
            if (!isObjectProperty(value)) throw new Error('option "' + option + '" must be an object');
        }

        this.setOption = setOption;

        this.$get = function () {
            return {
                setOption: setOption
            };
        };
    });
})(angular);
'use strict';

angular.module('BB.Services').factory("PackageItemService", function ($q, BBModel) {

    return {
        query: function query(company) {
            var deferred = $q.defer();
            if (!company.$has('packages')) {
                deferred.reject("No packages found");
            } else {
                company.$get('packages').then(function (resource) {
                    return resource.$get('packages').then(function (package_items) {
                        return deferred.resolve(Array.from(package_items).map(function (i) {
                            return new BBModel.PackageItem(i);
                        }));
                    });
                }, function (err) {
                    return deferred.reject(err);
                });
            }
            return deferred.promise;
        },
        getPackageServices: function getPackageServices(package_item) {
            var deferred = $q.defer();
            if (!package_item.$has('services')) {
                deferred.reject("No services found");
            } else {
                package_item.$get('services').then(function (services) {
                    return deferred.resolve(Array.from(services).map(function (s) {
                        return new BBModel.Service(s);
                    }));
                }, function (err) {
                    return deferred.reject(err);
                });
            }
            return deferred.promise;
        }
    };
});
'use strict';

angular.module('BB.Services').factory("PaginationService", function ($translate) {

    return {
        initialise: function initialise(options) {
            if (!options) {
                return;
            }
            var paginator = {
                current_page: 1,
                page_size: options.page_size,
                num_pages: null,
                max_size: options.max_size,
                num_items: null
            };
            return paginator;
        },
        update: function update(paginator, length) {
            if (!paginator || length == null) {
                return;
            }
            paginator.num_items = length;
            var start = (paginator.page_size - 1) * paginator.current_page - (paginator.page_size - 1 - paginator.current_page);
            var end = paginator.current_page * paginator.page_size;
            var total = end < paginator.page_size ? end : length;
            end = end > total ? total : end;
            return paginator.summary = $translate.instant('CORE.PAGINATION.SUMMARY', { start: start, end: end, total: total });
        },
        checkItems: function checkItems(paginator, items_loaded) {

            // determine if we need to load more items from the API

            var items_traversed = paginator.page_size * (paginator.current_page - 1);
            var remaining_items = paginator.num_items - items_loaded;

            return items_loaded < items_traversed + paginator.page_size && remaining_items > 0;
        }
    };
});
'use strict';

/***
 * @ngdoc service
 * @name BB.Services:PathHelper
 *
 * @description
 * Helper service for retrieving params from $location.path
 *
 */

angular.module('BB.Services').factory('PathHelper', function ($urlMatcherFactory, $location) {

    return {
        /***
         * @ngdoc method
         * @name matchRouteToPath
         * @methodOf BB.Services:PathHelper
         * @description
         * Get the email pattern
         * @param {string} the route format
         * @param {string} optional argument specifying the param to return from the path if matched, e.g. 'page'
         *
         * @returns {Object} the match object or matched param
         */
        matchRouteToPath: function matchRouteToPath(route_format, param) {

            if (!$location.path() || !route_format) {
                return false;
            }

            var parts = route_format.split("/");
            var match = null;

            while (parts.length > 0 && !match) {
                var match_test = parts.join("/");
                var pattern = $urlMatcherFactory.compile(match_test);
                match = pattern.exec($location.path());
                parts.pop();
            }

            if (match[param]) {
                return match[param];
            } else {
                return match;
            }
        }
    };
});
'use strict';

var service = function service($sce, AppConfig) {
    'ngInject';

    /*
     @param {String} fileName
     @returns {Object}
     */

    var directivePartial = function directivePartial(fileName) {
        if (AppConfig.partial_url) {
            var partialUrl = AppConfig.partial_url;
            return $sce.trustAsResourceUrl(partialUrl + '/' + fileName + '.html');
        } else {
            return $sce.trustAsResourceUrl(fileName + '.html');
        }
    };

    return {
        directivePartial: directivePartial
    };
};

angular.module('BB.Services').service('PathSvc', service);
'use strict';

angular.module('BB.Services').factory("PersonService", function ($q, BBModel) {

    return {
        query: function query(company) {
            var deferred = $q.defer();
            if (!company.$has('people')) {
                deferred.reject("No people found");
            } else {
                company.$get('people').then(function (resource) {
                    return resource.$get('people').then(function (items) {
                        var people = [];
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = Array.from(items)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var i = _step.value;

                                people.push(new BBModel.Person(i));
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return) {
                                    _iterator.return();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }

                        return deferred.resolve(people);
                    });
                }, function (err) {
                    return deferred.reject(err);
                });
            }
            return deferred.promise;
        }
    };
});
"use strict";

angular.module('BB.Services').factory("ProductService", function ($q, $window, halClient, UriTemplate, BBModel, $log, $rootScope) {

    return {
        getProduct: function getProduct(prms) {
            var href = void 0,
                uri = void 0;
            var deferred = $q.defer();

            if (prms.id) {
                href = $rootScope.bb.api_url + "/api/v1/{company_id}/products/{id}";
                uri = new UriTemplate(href).fillFromObject({ company_id: prms.company_id, id: prms.product_id });
            } else if (prms.sku) {
                href = $rootScope.bb.api_url + "/api/v1/{company_id}/products/find_by_sku/{sku}";
                uri = new UriTemplate(href).fillFromObject({ company_id: prms.company_id, sku: prms.sku });
            } else {
                $log.warn("id or sku is required");
                deferred.reject();
            }

            halClient.$get(uri, {}).then(function (product) {
                return deferred.resolve(new BBModel.Product(product));
            }, function (err) {
                return deferred.reject(err);
            });

            return deferred.promise;
        },
        query: function query(company) {
            var deferred = $q.defer();
            if (!company.$has('products')) {
                deferred.reject("No products found");
            } else {
                company.$get('products').then(function (resource) {
                    return resource.$get('products').then(function (items) {
                        var resources = [];
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = Array.from(items)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var i = _step.value;

                                resources.push(new BBModel.Product(i));
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return) {
                                    _iterator.return();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }

                        return deferred.resolve(resources);
                    });
                }, function (err) {
                    return deferred.reject(err);
                });
            }
            return deferred.promise;
        }
    };
});
'use strict';

angular.module('BB.Services').factory("PurchaseTotalService", function ($q, BBModel) {

    return {
        query: function query(prms) {
            var deferred = $q.defer();
            if (!prms.company.$has('total')) {
                deferred.reject("No Total link found");
            } else {
                prms.company.$get('total', { total_id: prms.total_id }).then(function (total) {
                    return deferred.resolve(new BBModel.PurchaseTotal(total));
                }, function (err) {
                    return deferred.reject(err);
                });
            }
            return deferred.promise;
        }
    };
});
'use strict';

// returns a object literal version of the querystring. you can pass in a key
// name and it will return a value i.e. QueryStringService('ref')
angular.module('BB.Services').factory('QueryStringService', function ($window) {
    return function (keyName) {
        var varObj = {};
        var href = $window.location.href;


        if (href.indexOf('?') < 0) {
            return;
        }

        var hashes = href.slice(href.indexOf('?') + 1).split(/[#&]/);

        //  check query string value is a number
        var isNum = function isNum(num) {
            // if num is not defined
            if (num == null) {
                return;
            }
            // starts with 0
            if (num.substr(0, 1) === '0') {
                return;
            }
            // contains chars
            if (/[a-zA-Z\-\_\+\.\#\%\*\,]/.test(num)) {
                return;
            }
            // is not a number
            if (window.isNaN(window.parseInt(num, 10))) {
                return;
            }
            return true;
        };

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = Array.from(hashes)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var hash = _step.value;

                hash = hash.split('=');
                // convert to number
                var val = hash[1];

                // if it's not a number - or that the number length is different!
                if (isNum(val)) {
                    val = window.parseInt(val, 10);
                } else {
                    // is boolean true
                    if (val === 'true') {
                        val = true;
                        // is boolean false
                    } else if (val === 'false') {
                        val = false;
                    } else {
                        val = window.decodeURIComponent(val);
                    }
                }
                // Removed date check as it attempts to convert strings like '0027' to a date
                // It should be on the onus of the user of the QueryStringService to attempt to instantinate
                // as a moment object
                // check if date
                //if window.moment(val).isValid()
                //  val = moment(val)._d


                varObj[hash[0]] = val;
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        if (keyName) {
            return varObj[keyName];
        }
        return varObj;
    };
});
'use strict';

angular.module('BB.Services').factory('QuestionService', function ($window, QueryStringService, $bbug) {

    // grab url params
    var defaults = QueryStringService() || {};

    var convertDates = function convertDates(obj) {
        return _.each(obj, function (val, key) {
            var date = $window.moment(obj[key]);
            if (_.isString(obj[key]) && date.isValid()) {
                return obj[key] = date;
            }
        });
    };

    //  store any values from $window.bb_setup if it exists
    if ($window.bb_setup) {
        convertDates($window.bb_setup);
        angular.extend(defaults, $window.bb_setup);
    }

    // adds an answer property to a question object if the id of the question
    // matches the id of the values stored in the defaults object. this would
    // almost defintiely be used to get values from the querystring i.e.
    // ?14393=Wedding&14392=true
    var addAnswersById = function addAnswersById(questions) {
        if (!questions) {
            return;
        }

        if (angular.isArray(questions)) {
            return _.each(questions, function (question) {
                var id = question.id + '';

                if (!question.answer && defaults[id]) {
                    return question.answer = defaults[id];
                }
            });
        } else {

            if (defaults[questions.id + '']) {
                return questions.answer = defaults[questions.id + ''];
            }
        }
    };

    // converts a string to a clean, snake case string. it's used to convert
    // question names into snake case so they can be accessed using the object dot
    // notation and match any values set using $window.bb_set_up
    var convertToSnakeCase = function convertToSnakeCase(str) {
        str = str.toLowerCase();
        str = $.trim(str);
        // replace all punctuation and special chars
        str = str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|'’!<>;:,.~`=+-@£&%"]/g, '');
        // replace any double or more spaces
        str = str.replace(/\s{2,}/g, ' ');
        // convert to sanke case
        str = str.replace(/\s/g, '_');
        return str;
    };

    // takes an array of questions objects. loops through the questions gettting
    // the obj.name value and converting it into snake case. then loop through the
    // stored value key name and see if there is whole or partial match.
    var addDynamicAnswersByName = function addDynamicAnswersByName(questions) {
        if (angular.isArray(questions)) {
            var keys = _.keys(defaults);

            return _.each(questions, function (question) {
                var name = convertToSnakeCase(question.name);
                return _.each(keys, function (key) {
                    if (name.indexOf('_' + key) >= 0 || name.indexOf('_' + key + '_') >= 0 || name.indexOf(key + '_') >= 0) {
                        if (defaults[key] && !question.answer) {
                            question.answer = defaults[key];
                            delete defaults[key];
                        }
                    }
                });
            });
        }
    };

    // takes an object and array of key names. it loops through key names and if
    // they match the key names in the stored values, then the values are added to
    // calling obj.
    var addAnswersByName = function addAnswersByName(obj, keys) {
        var type = Object.prototype.toString.call(obj).slice(8, -1);

        if (type === 'Object' && angular.isArray(keys)) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = Array.from(keys)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var key = _step.value;

                    // only add property to calling object if it doesn't have a property
                    if (defaults[key] && !obj[key]) {
                        obj[key] = defaults[key];
                        // remove it once it's set otherwise there could be a lot of issues
                        delete defaults[key];
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return;
        }
    };

    // takes an array of questions and an answers hash which then matches answers either
    // by thier key name and the questions help_text value or by question id
    var addAnswersFromDefaults = function addAnswersFromDefaults(questions, answers) {
        return function () {
            var result = [];
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = Array.from(questions)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var question = _step2.value;

                    var item = void 0;
                    var name = question.help_text;
                    if (answers[name]) {
                        question.answer = answers[name];
                    }
                    if (answers[question.id + '']) {
                        item = question.answer = answers[question.id + ''];
                    }
                    result.push(item);
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            return result;
        }();
    };

    var storeDefaults = function storeDefaults(obj) {
        return angular.extend(defaults, obj.bb_setup || {});
    };

    var checkConditionalQuestions = function checkConditionalQuestions(questions) {
        return function () {
            var result = [];
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = Array.from(questions)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var q = _step3.value;

                    var item = void 0;
                    if (q.settings && q.settings.conditional_question) {
                        var cond = findByQuestionId(questions, parseInt(q.settings.conditional_question));
                        if (cond) {
                            // check if the question has an answer which means "show"
                            var ans = cond.getAnswerId();
                            var found = false;
                            if ($bbug.isEmptyObject(q.settings.conditional_answers) && cond.detail_type === "check" && !cond.answer) {
                                // this is messy - we're showing the question when we ahve a checkbox conditional, based on it being unticked
                                found = true;
                            }

                            for (var a in q.settings.conditional_answers) {
                                var v = q.settings.conditional_answers[a];
                                if (a[0] === 'c' && parseInt(v) === 1 && cond.answer) {
                                    found = true;
                                } else if (parseInt(a) === ans && parseInt(v) === 1) {
                                    found = true;
                                }
                            }
                            if (found) {
                                item = q.showElement();
                            } else {
                                item = q.hideElement();
                            }
                        }
                    }
                    result.push(item);
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }

            return result;
        }();
    };

    var findByQuestionId = function findByQuestionId(questions, qid) {
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
            for (var _iterator4 = Array.from(questions)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var q = _step4.value;

                if (q.id === qid) {
                    return q;
                }
            }
        } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion4 && _iterator4.return) {
                    _iterator4.return();
                }
            } finally {
                if (_didIteratorError4) {
                    throw _iteratorError4;
                }
            }
        }

        return null;
    };

    return {
        getStoredData: function getStoredData() {
            return defaults;
        },


        storeDefaults: storeDefaults,
        addAnswersById: addAnswersById,
        addAnswersByName: addAnswersByName,
        addDynamicAnswersByName: addDynamicAnswersByName,
        addAnswersFromDefaults: addAnswersFromDefaults,
        convertToSnakeCase: convertToSnakeCase,
        checkConditionalQuestions: checkConditionalQuestions
    };
});
'use strict';

angular.module('BB.Services').factory("ReasonService", function ($q, BBModel) {
    return {
        query: function query(company) {
            var deferred = $q.defer();
            if (!company.$has('reasons')) {
                deferred.reject("Reasons not turned on for this Company.");
            } else {
                company.$get('reasons').then(function (resource) {
                    return resource.$get('reasons').then(function (items) {
                        var reasons = [];
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = Array.from(items)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var i = _step.value;

                                var reason = new BBModel.Reason(i);
                                reasons.push(reason);
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return) {
                                    _iterator.return();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }

                        return deferred.resolve(reasons);
                    });
                }, function (err) {
                    return deferred.reject(err);
                });
            }

            return deferred.promise;
        }
    };
});
"use strict";

angular.module("BB.Services").factory("RecaptchaService", function ($q, halClient, UriTemplate) {

    return {
        validateResponse: function validateResponse(params) {
            var deferred = $q.defer();
            var href = params.api_url + "/api/v1/recaptcha";
            var uri = new UriTemplate(href);
            var prms = {};
            prms.response = params.response;
            halClient.$post(uri, {}, prms).then(function (response) {
                return deferred.resolve(response);
            }, function (err) {
                return deferred.reject(err);
            });
            return deferred.promise;
        }
    };
});
'use strict';

angular.module('BB.Services').factory("ResourceService", function ($q, BBModel) {

    return {
        query: function query(company) {
            var deferred = $q.defer();
            if (!company.$has('resources')) {
                deferred.reject("No resource found");
            } else {
                company.$get('resources').then(function (resource) {
                    return resource.$get('resources').then(function (items) {
                        var resources = [];
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = Array.from(items)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var i = _step.value;

                                resources.push(new BBModel.Resource(i));
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return) {
                                    _iterator.return();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }

                        return deferred.resolve(resources);
                    });
                }, function (err) {
                    return deferred.reject(err);
                });
            }
            return deferred.promise;
        }
    };
});
'use strict';

/**
 * @ngdoc service
 * @name BB.Services:scrollIntercepter
 *
 * @description
 * Accepts requests to scroll the viewport, depending on the type the request is either fullfilled or rejected.
 *
 */

angular.module('BB.Services').factory('scrollIntercepter', function ($bbug, $window, GeneralOptions, AppService, $timeout) {

    var currentlyScrolling = false;

    var scrollToElement = function scrollToElement(element, transitionTime, type) {

        if (type === "alert:raised") {
            //Alerts have precedence over other scroll events and can intercept
            currentlyScrolling = false;
        }

        if (!currentlyScrolling) {
            currentlyScrolling = true;

            // if theres a modal open, scrolling to it takes the higest precedence
            if (AppService.isModalOpen()) {
                $bbug('[uib-modal-window]').animate({
                    scrollTop: element.offset().top - GeneralOptions.scroll_offset
                }, transitionTime);
            } else if ('parentIFrame' in $window) {
                parentIFrame.scrollToOffset(0, element.offset().top - GeneralOptions.scroll_offset);
            } else {
                $bbug("html, body").animate({
                    scrollTop: element.offset().top - GeneralOptions.scroll_offset
                }, transitionTime);
            }
            $timeout(function () {
                return (
                    //make sure the scroll is not interupted, unless it is an alert
                    currentlyScrolling = false
                );
            }, transitionTime);
        } else {
            return;
        }
    };
    return {
        scrollToElement: scrollToElement
    };
});
'use strict';

angular.module('BB.Services').factory("ServiceService", function ($q, BBModel) {

    return {
        query: function query(company) {
            var deferred = $q.defer();
            if (!company.$has('services')) {
                deferred.reject("No services found");
            } else {
                company.$get('services').then(function (resource) {
                    return resource.$get('services').then(function (items) {
                        var services = [];
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = Array.from(items)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var i = _step.value;

                                services.push(new BBModel.Service(i));
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return) {
                                    _iterator.return();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }

                        return deferred.resolve(services);
                    });
                }, function (err) {
                    return deferred.reject(err);
                });
            }
            return deferred.promise;
        }
    };
});
'use strict';

angular.module('BB.Services').factory("SlotService", function ($q, BBModel) {

    return {
        query: function query(company, params) {
            var deferred = $q.defer();
            if (!company.$has('slots')) {
                deferred.resolve([]);
            } else {
                if (params.item) {
                    if (params.item.resource) {
                        params.resource_id = params.item.resource.id;
                    }
                    if (params.item.person) {
                        params.person_id = params.item.person.id;
                    }
                }
                company.$get('slots', params).then(function (resource) {
                    return resource.$get('slots', params).then(function (slots) {
                        slots = Array.from(slots).map(function (slot) {
                            return new BBModel.Slot(slot);
                        });
                        return deferred.resolve(slots);
                    });
                }, function (err) {
                    return deferred.reject(err);
                });
            }
            return deferred.promise;
        }
    };
});
'use strict';

/**
 * @ngdoc service
 * @name BB.Services.service:SlotDates
 *
 * @description
 * checks for the first date with available spaces
 */
angular.module('BB.Services').factory('SlotDates', function ($q, DayService) {
    var cached = {
        firstSlotDate: null,
        timesQueried: 0
    };

    var getFirstDayWithSlots = function getFirstDayWithSlots(cItem, selected_day) {
        var deferred = $q.defer();

        if (cached.firstSlotDate != null) {
            deferred.resolve(cached.firstSlotDate);
            return deferred.promise;
        }

        var endDate = selected_day.clone().add(3, 'month');

        DayService.query({
            cItem: cItem,
            date: selected_day.format('YYYY-MM-DD'),
            edate: endDate.format('YYYY-MM-DD')
        }).then(function (days) {
            cached.timesQueried++;

            var firstAvailableSlots = _.find(days, function (day) {
                return day.spaces > 0;
            });
            if (firstAvailableSlots) {
                cached.firstSlotDate = firstAvailableSlots.date;
                return deferred.resolve(cached.firstSlotDate);
            } else {
                if (cached.timesQueried <= 4) {
                    return getFirstDayWithSlots(cItem, endDate).then(function (day) {
                        return deferred.resolve(cached.firstSlotDate);
                    }, function (err) {
                        return deferred.reject(err);
                    });
                } else {
                    return deferred.reject(new Error('ERROR.NO_SLOT_AVAILABLE'));
                }
            }
        }, function (err) {
            return deferred.reject(new Error('ERROR.COULDNT_GET_AVAILABLE_DATES'));
        });

        return deferred.promise;
    };

    return { getFirstDayWithSlots: getFirstDayWithSlots };
});
'use strict';

angular.module('BB.Services').config(function ($provide) {
    return $provide.decorator('$sniffer', function ($delegate) {

        var regexp = /Safari\/([\d.]+)/;
        var result = regexp.exec(navigator.userAgent);
        var webkit_version = result ? parseFloat(result[1]) : null;

        _.extend($delegate, { webkit: webkit_version });

        return $delegate;
    });
});
'use strict';

angular.module('BB.Services').factory("SpaceService", function ($q, BBModel) {

    return {
        query: function query(company) {
            var deferred = $q.defer();
            if (!company.$has('spaces')) {
                deferred.reject("No spaces found");
            } else {
                company.$get('spaces').then(function (resource) {
                    return resource.$get('spaces').then(function (items) {
                        var spaces = [];
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = Array.from(items)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var i = _step.value;

                                spaces.push(new BBModel.Space(i));
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return) {
                                    _iterator.return();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }

                        return deferred.resolve(spaces);
                    });
                }, function (err) {
                    return deferred.reject(err);
                });
            }
            return deferred.promise;
        }
    };
});
"use strict";

angular.module('BB.Services').factory("SSOService", function ($q, $rootScope, halClient, LoginService) {

    return {
        memberLogin: function memberLogin(options) {
            var deferred = $q.defer();
            if (!options.root) {
                options.root = "";
            }
            var url = options.root + "/api/v1/login/sso/" + options.company_id;
            var data = { token: options.member_sso };
            halClient.$post(url, {}, data).then(function (login) {
                return login.$get('member').then(function (member) {
                    member = LoginService.setLogin(member);
                    return deferred.resolve(member);
                });
            }, function (err) {
                return deferred.reject(err);
            });
            return deferred.promise;
        },
        adminLogin: function adminLogin(options) {
            var deferred = $q.defer();
            if (!options.root) {
                options.root = "";
            }
            var url = options.root + "/api/v1/login/admin_sso/" + options.company_id;
            var data = { token: options.admin_sso };
            halClient.$post(url, {}, data).then(function (login) {
                return login.$get('administrator').then(function (admin) {
                    return deferred.resolve(admin);
                });
            }, function (err) {
                return deferred.reject(err);
            });
            return deferred.promise;
        }
    };
});
'use strict';

// Service for loading templates and partials. return rasterized dom elements
angular.module('BB.Services').factory("TemplateSvc", function ($q, $http, $templateCache, BBModel) {

    return {
        get: function get(path) {
            var deferred = $q.defer();
            var cacheTmpl = $templateCache.get(path);

            if (cacheTmpl) {
                deferred.resolve(angular.element(cacheTmpl));
            } else {
                $http({
                    method: 'GET',
                    url: path
                }).success(function (tmpl, status) {
                    $templateCache.put(path, tmpl);
                    return deferred.resolve(angular.element(tmpl));
                }).error(function (data, status) {
                    return deferred.reject(data);
                });
            }
            return deferred.promise;
        }
    };
});
'use strict';

(function (angular) {

    angular.module('BB.Services').factory('TimeService', TimeService);

    function TimeService($q, BBModel, halClient, CompanyStoreService, DateTimeUtilitiesService, bbTimeZone) {

        return {
            query: query,
            queryItems: queryItems,
            merge_times: merge_times,
            checkCurrentItem: checkCurrentItem
        };

        function query(prms) {
            var _this = this;

            var deferred = $q.defer();

            var start_date = null;
            var end_date = null;

            if (prms.date) {
                prms.start_date = prms.date;
            } else if (prms.cItem.date) {
                prms.start_date = prms.cItem.date.date;
            } else {
                deferred.reject("No date set");
                return deferred.promise;
            }

            start_date = prms.start_date;


            if (prms.end_date) {
                end_date = prms.end_date;
            } else {
                prms.end_date = prms.start_date.clone();
                end_date = prms.end_date.clone();
            }

            // Adjust time range based on UTC offset between company time zone and display time zone
            if (bbTimeZone.getDisplay() != null && bbTimeZone.getDisplay() !== CompanyStoreService.time_zone) {

                if (bbTimeZone.getCompanyUTCOffset() < bbTimeZone.getDisplayUTCOffset()) {
                    start_date = prms.start_date.clone().subtract(1, 'day');
                } else if (bbTimeZone.getCompanyUTCOffset() > bbTimeZone.getDisplayUTCOffset() && prms.end_date) {
                    end_date = prms.end_date.clone().add(1, 'day');
                }

                prms.time_zone = bbTimeZone.getDisplay();
            }

            // If there was no duration passed in get the default duration off the
            // current item
            if (prms.duration == null) {
                if (prms.cItem && prms.cItem.duration) {
                    prms.duration = prms.cItem.duration;
                }
            }

            var item_link = prms.item_link;


            if (prms.cItem && prms.cItem.days_link && !item_link) {
                item_link = prms.cItem.days_link;
            }

            if (item_link) {

                var extra = {};
                extra.date = start_date.toISODate();
                if (prms.location) {
                    extra.location = prms.location;
                }
                if (prms.cItem.event_id) {
                    extra.event_id = prms.cItem.event_id;
                }
                if (prms.cItem.person && !prms.cItem.anyPerson() && !item_link.event_id && !extra.event_id) {
                    extra.person_id = prms.cItem.person.id;
                }
                if (prms.cItem.resource && !prms.cItem.anyResource() && !item_link.event_id && !extra.event_id) {
                    extra.resource_id = prms.cItem.resource.id;
                }
                if (end_date) {
                    extra.end_date = end_date.toISODate();
                }
                extra.duration = prms.duration;
                extra.person_group_id = prms.cItem.person_group_id;
                extra.num_resources = prms.num_resources;
                if (prms.time_zone) {
                    extra.time_zone = prms.time_zone;
                }
                if (prms.cItem.id) {
                    extra.ignore_booking = prms.cItem.id;
                }
                if (prms.people_ids) {
                    extra.people_ids = prms.people_ids;
                }
                if (prms.resource_ids) {
                    extra.resource_ids = prms.resource_ids;
                }

                if (extra.event_id) {
                    item_link = prms.company;
                } // if we have an event - the the company link - so we don't add in extra params

                item_link.$get('times', extra).then(function (results) {

                    var times = void 0;

                    if (results.$has('date_links')) {

                        // it's a date range - we're expecting several dates - lets build up a hash of dates
                        return results.$get('date_links').then(function (all_days) {

                            var all_days_def = [];

                            var _iteratorNormalCompletion = true;
                            var _didIteratorError = false;
                            var _iteratorError = undefined;

                            try {
                                for (var _iterator = Array.from(all_days)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                    var day = _step.value;


                                    (function (day) {

                                        // there's several days - get them all
                                        day.elink = $q.defer();
                                        all_days_def.push(day.elink.promise);

                                        if (day.$has('event_links')) {

                                            return day.$get('event_links').then(function (all_events) {
                                                times = _this.merge_times(all_events, prms.cItem.service, prms.cItem, day.date);
                                                if (prms.available) {
                                                    times = _.filter(times, function (t) {
                                                        return t.avail >= prms.available;
                                                    });
                                                }
                                                return day.elink.resolve(times);
                                            });
                                        } else if (day.times) {

                                            times = _this.merge_times([day], prms.cItem.service, prms.cItem, day.date);
                                            if (prms.available) {
                                                times = _.filter(times, function (t) {
                                                    return t.avail >= prms.available;
                                                });
                                            }
                                            return day.elink.resolve(times);
                                        }
                                    })(day);
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return) {
                                        _iterator.return();
                                    }
                                } finally {
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }

                            return $q.all(all_days_def).then(function (times) {

                                var date_times = {};

                                // build day/slot array ensuring slots are grouped by the display time zone
                                date_times = _.chain(times).flatten().sortBy(function (slot) {
                                    return slot.datetime.unix();
                                }).groupBy(function (slot) {
                                    return slot.datetime.toISODate();
                                }).value();

                                // add days back that don't have any availabiity and return originally requested range only
                                var newDateTimes = {};

                                var startDateClone = prms.start_date.clone();
                                while (startDateClone <= prms.end_date) {
                                    var dateISO = startDateClone.toISODate();
                                    newDateTimes[dateISO] = date_times[dateISO] ? date_times[dateISO] : [];
                                    startDateClone = startDateClone.clone().add(1, 'day');
                                }

                                if (prms.start_date.isSame(prms.end_date)) {
                                    var _dateISO = prms.start_date.toISODate();
                                    return deferred.resolve(newDateTimes[_dateISO]);
                                } else {
                                    return deferred.resolve(newDateTimes);
                                }
                            });
                        });
                    } else if (results.$has('event_links')) {

                        // single day - but a list of bookable events
                        return results.$get('event_links').then(function (all_events) {
                            times = _this.merge_times(all_events, prms.cItem.service, prms.cItem, prms.start_date);
                            if (prms.available) {
                                times = _.filter(times, function (t) {
                                    return t.avail >= prms.available;
                                });
                            }

                            // returns array of time slots
                            return deferred.resolve(times);
                        });
                    } else if (results.times) {
                        times = _this.merge_times([results], prms.cItem.service, prms.cItem, prms.start_date);
                        if (prms.available) {
                            times = _.filter(times, function (t) {
                                return t.avail >= prms.available;
                            });
                        }

                        // returns array of time slots
                        return deferred.resolve(times);
                    }
                }, function (err) {
                    return deferred.reject(err);
                });
            } else {
                deferred.reject("No day data");
            }

            return deferred.promise;
        }

        // query a set of basket items for the same time data
        function queryItems(prms) {

            var defer = $q.defer();

            var pslots = [];

            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = Array.from(prms.items)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var item = _step2.value;

                    pslots.push(this.query({
                        company: prms.company,
                        cItem: item,
                        date: prms.start_date,
                        end_date: prms.end_date,
                        client: prms.client,
                        available: 1
                    }));
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            $q.all(pslots).then(function (res) {
                return defer.resolve(res);
            }, function (err) {
                return defer.reject();
            });

            return defer.promise;
        }

        function merge_times(all_events, service, item, date) {

            var i = void 0;
            if (!all_events || all_events.length === 0) {
                return [];
            }

            all_events = _.shuffle(all_events);
            var sorted_times = [];
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = Array.from(all_events)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var ev = _step3.value;

                    if (ev.times) {
                        var _iteratorNormalCompletion5 = true;
                        var _didIteratorError5 = false;
                        var _iteratorError5 = undefined;

                        try {
                            for (var _iterator5 = Array.from(ev.times)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                                i = _step5.value;

                                // set it not set, currently unavailable, or randomly based on the number of events
                                if (!sorted_times[i.time] || sorted_times[i.time].avail === 0 || Math.floor(Math.random() * all_events.length) === 0 && i.avail > 0) {
                                    i.event_id = ev.event_id;
                                    sorted_times[i.time] = i;
                                }
                            }
                            // if we have an item - which an already booked item - make sure that it's the list of time slots we can select - i.e. that we can select the current slot
                        } catch (err) {
                            _didIteratorError5 = true;
                            _iteratorError5 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion5 && _iterator5.return) {
                                    _iterator5.return();
                                }
                            } finally {
                                if (_didIteratorError5) {
                                    throw _iteratorError5;
                                }
                            }
                        }

                        if (item.held) {
                            this.checkCurrentItem(item.held, sorted_times, ev);
                        }
                        this.checkCurrentItem(item, sorted_times, ev);
                    }
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }

            var times = [];

            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
                for (var _iterator4 = Array.from(sorted_times)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                    i = _step4.value;

                    if (i) {

                        // add datetime if not provided by the API (versions < 1.5.4-1 )
                        if (!i.datetime) {
                            i.datetime = DateTimeUtilitiesService.convertTimeToMoment(moment(date), i.time);
                        }

                        times.push(new BBModel.TimeSlot(i, service));
                    }
                }
            } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion4 && _iterator4.return) {
                        _iterator4.return();
                    }
                } finally {
                    if (_didIteratorError4) {
                        throw _iteratorError4;
                    }
                }
            }

            return times;
        }

        function checkCurrentItem(item, sorted_times, ev) {
            if (item && item.id && item.event_id === ev.event_id && item.time && !sorted_times[item.time.time] && item.date && item.date.date.toISODate() === ev.date) {
                // calculate the correct datetime for time slot
                item.time.datetime = DateTimeUtilitiesService.convertTimeToMoment(item.date.date, item.time.time);
                sorted_times[item.time.time] = item.time;
                // remote this entry from the cache - just in case - we know it has a held item in it so lets just not keep it in case that goes later!
                return halClient.clearCache(ev.$href("self"));
            } else if (item && item.id && item.event_id === ev.event_id && item.time && sorted_times[item.time.time] && item.date && item.date.date.toISODate() === ev.date) {
                return sorted_times[item.time.time].avail = 1;
            }
        }
    }
})(angular);
'use strict';

angular.module('BB.Services').factory('TimeSlotService', function ($q, BBModel) {

    return {
        query: function query(params) {
            var defer = $q.defer();
            var company = params.company;

            company.$get('slots', params).then(function (collection) {
                return collection.$get('slots').then(function (slots) {
                    slots = Array.from(slots).map(function (s) {
                        return new BBModel.TimeSlot(s);
                    });
                    return defer.resolve(slots);
                }, function (err) {
                    return defer.reject(err);
                });
            }, function (err) {
                return defer.reject(err);
            });
            return defer.promise;
        }
    };
});
'use strict';

angular.module('BB.Services').factory("UnwrapService", function ($q, BBModel) {
    return {
        unwrapCollection: function unwrapCollection(model, key, resource) {
            var models = void 0;
            var deferred = $q.defer();

            // if the resource is embedded, return the array of models
            if (angular.isArray(resource)) {

                models = Array.from(resource).map(function (service) {
                    return new model(service);
                });
                deferred.resolve(models);
            } else if (resource.$has(key)) {
                resource.$get(key).then(function (items) {
                    models = [];
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = Array.from(items)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var i = _step.value;

                            models.push(new model(i));
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }

                    return deferred.resolve(models);
                }, function (err) {
                    return deferred.reject(err);
                });
            } else {
                deferred.reject();
            }

            return deferred.promise;
        },
        unwrapResource: function unwrapResource(model, resource) {
            return new model(resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.address", function ($q, BBModel, UnwrapService) {
    return {
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapResource(BBModel.Address, resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.addresses", function ($q, BBModel, UnwrapService) {
    return {
        promise: true,
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapCollection(BBModel.Address, 'addresses', resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.person", function ($q, BBModel, UnwrapService) {
    return {
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapResource(BBModel.Person, resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.people", function ($q, BBModel, UnwrapService) {
    return {
        promise: true,
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapCollection(BBModel.Person, 'people', resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.resource", function ($q, BBModel, UnwrapService) {
    return {
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapResource(BBModel.Resource, resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.resources", function ($q, BBModel, UnwrapService) {
    return {
        promise: true,
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapCollection(BBModel.Resource, 'resources', resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.service", function ($q, BBModel, UnwrapService) {
    return {
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapResource(BBModel.Service, resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.services", function ($q, BBModel, UnwrapService) {
    return {
        promise: true,
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapCollection(BBModel.Service, 'services', resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.package_item", function ($q, BBModel, UnwrapService) {
    return {
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapResource(BBModel.PackageItem, resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.package_items", function ($q, BBModel, UnwrapService) {
    return {
        promise: true,
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapCollection(BBModel.PackageItem, 'package_items', resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.bulk_purchase", function ($q, BBModel, UnwrapService) {
    return {
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapResource(BBModel.BulkPurchase, resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.bulk_purchases", function ($q, BBModel, UnwrapService) {
    return {
        promise: true,
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapCollection(BBModel.BulkPurchase, 'bulk_purchases', resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.event_group", function ($q, BBModel, UnwrapService) {
    return {
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapResource(BBModel.EventGroup, resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.event_groups", function ($q, BBModel, UnwrapService) {
    return {
        promise: true,
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapCollection(BBModel.EventGroup, 'event_groups', resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.event_chain", function ($q, BBModel, UnwrapService) {
    return {
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapResource(BBModel.EventChain, resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.event_chains", function ($q, BBModel, UnwrapService) {
    return {
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapResource(BBModel.EventChain, resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.category", function ($q, BBModel, UnwrapService) {
    return {
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapResource(BBModel.Category, resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.categories", function ($q, BBModel, UnwrapService) {
    return {
        promise: true,
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapCollection(BBModel.Category, 'categories', resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.client", function ($q, BBModel, UnwrapService) {
    return {
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapResource(BBModel.Client, resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.child_clients", function ($q, BBModel, UnwrapService) {
    return {
        promise: true,
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapCollection(BBModel.Client, 'clients', resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.clients", function ($q, BBModel, UnwrapService) {
    return {
        promise: true,
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapCollection(BBModel.Client, 'clients', resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.questions", function ($q, BBModel, UnwrapService) {
    return {
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapCollection(BBModel.Question, 'questions', resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.question", function ($q, BBModel, UnwrapService) {
    return {
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapResource(BBModel.Question, resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.answers", function ($q, BBModel, UnwrapService) {
    return {
        promise: false,
        unwrap: function unwrap(items) {
            var models = [];
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = Array.from(items)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var i = _step2.value;

                    models.push(new BBModel.Answer(i));
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            var answers = {
                answers: models,

                getAnswer: function getAnswer(question) {
                    var _iteratorNormalCompletion3 = true;
                    var _didIteratorError3 = false;
                    var _iteratorError3 = undefined;

                    try {
                        for (var _iterator3 = Array.from(this.answers)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                            var a = _step3.value;

                            if (a.question_text === question || a.question_id === question) {
                                return a.value;
                            }
                        }
                    } catch (err) {
                        _didIteratorError3 = true;
                        _iteratorError3 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion3 && _iterator3.return) {
                                _iterator3.return();
                            }
                        } finally {
                            if (_didIteratorError3) {
                                throw _iteratorError3;
                            }
                        }
                    }
                }
            };

            return answers;
        }
    };
});

angular.module('BB.Services').factory("BB.Service.administrators", function ($q, BBModel, UnwrapService) {
    return {
        unwrap: function unwrap(items) {
            return Array.from(items).map(function (i) {
                return new BBModel.Admin.User(i);
            });
        }
    };
});

angular.module('BB.Services').factory("BB.Service.company", function ($q, BBModel, UnwrapService) {
    return {
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapResource(BBModel.Company, resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.parent", function ($q, BBModel, UnwrapService) {
    return {
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapResource(BBModel.Company, resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.company_questions", function ($q, BBModel, UnwrapService) {
    return {
        promise: true,
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapCollection(BBModel.BusinessQuestion, 'company_questions', resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.company_question", function ($q, BBModel, UnwrapService) {
    return {
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapResource(BBModel.BusinessQuestion, resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.images", function ($q, BBModel, UnwrapService) {
    return {
        promise: true,
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapCollection(BBModel.Image, 'images', resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.bookings", function ($q, BBModel, UnwrapService) {
    return {
        promise: true,
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapCollection(BBModel.Member.Booking, 'bookings', resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.wallet", function ($q, BBModel, UnwrapService) {
    return {
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapResource(BBModel.Member.Wallet, resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.product", function ($q, BBModel, UnwrapService) {
    return {
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapResource(BBModel.Product, resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.products", function ($q, BBModel, UnwrapService) {
    return {
        promise: true,
        unwrap: function unwrap(resource) {
            var deferred = $q.defer();
            resource.$get('products').then(function (items) {
                var models = [];
                for (var index = 0; index < items.length; index++) {
                    var i = items[index];
                    var cat = new BBModel.Product(i);
                    if (!cat.order) {
                        cat.order = index;
                    }
                    models.push(cat);
                }
                return deferred.resolve(models);
            }, function (err) {
                return deferred.reject(err);
            });

            return deferred.promise;
        }
    };
});

angular.module('BB.Services').factory("BB.Service.pre_paid_booking", function ($q, BBModel, UnwrapService) {
    return {
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapResource(BBModel.PrePaidBooking, resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.pre_paid_bookings", function ($q, BBModel, UnwrapService) {
    return {
        promise: true,
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapCollection(BBModel.PrePaidBooking, 'pre_paid_bookings', resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.external_purchase", function ($q, BBModel, UnwrapService) {
    return {
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapResource(BBModel.ExternalPurchase, resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.external_purchases", function ($q, BBModel, UnwrapService) {
    return {
        promise: true,
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapCollection(BBModel.ExternalPurchase, 'external_purchases', resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.purchase_item", function ($q, BBModel, UnwrapService) {
    return {
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapResource(BBModel.PurchaseItem, resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.purchase_items", function ($q, BBModel, UnwrapService) {
    return {
        promise: true,
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapCollection(BBModel.PurchaseItem, 'purchase_items', resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.payment_callbacks", function ($q, BBModel, UnwrapService) {
    return {
        promise: true,
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapCollection(BBModel.PaymentCallbacks, 'payment_callbacks', resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.events", function ($q, BBModel, UnwrapService) {
    return {
        promise: true,
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapCollection(BBModel.Event, 'events', resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.all_children", function ($q, BBModel, UnwrapService) {
    return {
        promise: true,
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapCollection(BBModel.Service, 'services', resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.child_services", function ($q, BBModel, UnwrapService) {
    return {
        promise: true,
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapCollection(BBModel.Service, 'child_services', resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.items", function ($q, BBModel, UnwrapService) {
    return {
        promise: true,
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapCollection(BBModel.Items, 'items', resource);
        }
    };
});

angular.module('BB.Services').factory("BB.Service.item", function ($q, BBModel, UnwrapService) {
    return {
        unwrap: function unwrap(resource) {
            return UnwrapService.unwrapResource(BBModel.Item, resource);
        }
    };
});
'use strict';

/***
 * @ngdoc service
 * @name BB.Services:Validator
 *
 * @description
 * Representation of an Validator Object
 *
 * @property {string} alpha Alpha pattern that accepts letters, hypens and spaces
 * @property {string} us_phone_number US phone number regex
 *
 */

angular.module('BB.Services').factory('ValidatorService', function ($rootScope, AlertService, CompanyStoreService, BBModel, $q, $bbug) {

    // Use http://regex101.com/ to test patterns

    // UK postcode regex (strict)
    // http://regexlib.com/REDetails.aspx?regexp_id=260
    // uk_postcode_regex = /^([A-PR-UWYZ0-9][A-HK-Y0-9][AEHMNPRTVXY0-9]?[ABEHMNPRVWXY0-9]? {1,2}[0-9][ABD-HJLN-UW-Z]{2}|GIR 0AA)$/i
    // let uk_postcode_regex = /^(((([A-PR-UWYZ][0-9][0-9A-HJKS-UW]?)|([A-PR-UWYZ][A-HK-Y][0-9][0-9ABEHMNPRV-Y]?))\s{0,1}[0-9]([ABD-HJLNP-UW-Z]{2}))|(GIR\s{0,2}0AA))$/i;

    // US postcode regex used for getMailingPattern
    var us_postcode_regex = /^\d{5}(?:[-\s]\d{4})?$/;

    // UK postcode regex (lenient) - this checks for a postcode like string
    // https://gist.github.com/simonwhitaker/5748487
    var uk_postcode_regex_lenient = /^[A-Z]{1,2}[0-9][0-9A-Z]?\s*[0-9][A-Z]{2}$/i;

    // number only regex
    var number_only_regex = /^\d+$/;

    // UK mobile number regex (strict)
    // ----------------------------------------------------------------------------------------------------------------------------------------
    // +44 or 0 followed by 7 followed by [45789] followed by \d{2} or 624 followed by \d{6} and can contain any number of spaces in between
    // ----------------------------------------------------------------------------------------------------------------------------------------
    var uk_mobile_regex_strict = /^((\+44|0)\s*7\s*([45789](\s*\d){2}|6\s*2\s*4)(\s*\d){6})$/;

    // mobile number regex (lenient)
    var mobile_regex_lenient = /^(0|\+)([\d \(\)]{9,19})$/;

    // UK landline regex (strict)
    // ----------------------------------------------------------------------------------------------------------------
    // Will accept numbers like: 0208 695 1232, 020 8695 1232, +44 208 695 1232, +44 1623 431 091
    // ----------------------------------------------------------------------------------------------------------------
    var uk_landline_regex_strict = /^(\+44|0)\s*[1-9]\s*\d{1,4}\s*\d{3,4}\s*\d{2,4}$/;

    // UK landline regex (lenient)
    var uk_landline_regex_lenient = /^(0|\+)([\d \(\)]{9,19})$/;

    // international number
    var international_number = /^(\+)([\d \(\)]{9,19})$/;

    var email_regex = /^$|^([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})$/i;

    // password requires minimum of 7 characters and 1 number
    var standard_password = /^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]{8,}$/;

    // alphanumeric
    var alphanumeric = /^[a-zA-Z0-9]*$/;

    var geocode_result = null;

    // letters, hyphens and spaces
    return {
        alpha: /^[a-zA-Z\s-]*$/,

        // https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9781449327453/ch04s02.html
        us_phone_number: /^\(?([0-9]{3})\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$/,

        /***
         * @ngdoc method
         * @name getEmailPattern
         * @methodOf BB.Services:Validator
         * @description
         * Returns a pattern for matching email addresses
         *
         * @returns {string} Email regex
         */
        getEmailPattern: function getEmailPattern() {
            return email_regex;
        },


        /***
         * @ngdoc method
         * @name getStandardPassword
         * @methodOf BB.Services:Validator
         * @description
         * Returns a password pattern enforcing at least 7 characters and 1 number
         *
         * @returns {string} Password regex
         */
        getStandardPassword: function getStandardPassword() {
            return standard_password;
        },


        /***
         * @ngdoc method
         * @name getUKPostcodePattern
         * @methodOf BB.Services:Validator
         * @description
         * Returns a pattern for matching UK postcodes
         *
         * @returns {string} UK Postcode regex
         */
        getUKPostcodePattern: function getUKPostcodePattern() {
            return uk_postcode_regex_lenient;
        },


        /***
         * @ngdoc method
         * @name getUKPostcodePattern
         * @methodOf BB.Services:Validator
         * @description
         * Returns a pattern for matching local mailing codes based on current companies country
         *
         * @returns {string} Mailing code regex
         */
        // We use the country code in favour of the locale given that it's more likley that a user will reside in the same place as the business
        getMailingPattern: function getMailingPattern() {
            var cc = CompanyStoreService.country_code;
            switch (cc) {
                case "us":
                    return us_postcode_regex;
                case "gb":
                    return uk_postcode_regex_lenient;
                default:
                    return null;
            }
        },


        /***
         * @ngdoc method
         * @name getNumberOnlyPattern
         * @methodOf BB.Services:Validator
         * @description
         * Returns a pattern for matching numbers only
         *
         * @returns {string} Number only regex
         */
        getNumberOnlyPattern: function getNumberOnlyPattern() {
            return number_only_regex;
        },


        /***
         * @ngdoc method
         * @name getAlphaNumbericPattern
         * @methodOf BB.Services:Validator
         * @description
         * Returns a pattern for matching alpha numeric strings
         *
         * @returns {string} The returned the alphanumeric regex
         */
        getAlphaNumbericPattern: function getAlphaNumbericPattern() {
            return alphanumeric;
        },


        /***
         * @ngdoc method
         * @name getUKMobilePattern
         * @methodOf BB.Services:Validator
         * @description
         * Returns a pattern for mathing number like strings between 9 and 19 characters.  If the strict flag is used, the pattern matches UK mobile numbers
         *
         * @param {boolean} strict Use strict validation. Defaults to false.
         * @returns {string} The returned the UK mobile regixt strict if this is strict else return mobile_regex_lenient
         */
        getUKMobilePattern: function getUKMobilePattern(strict) {
            if (strict == null) {
                strict = false;
            }
            if (strict) {
                return uk_mobile_regex_strict;
            }
            return mobile_regex_lenient;
        },


        /***
         * @ngdoc method
         * @name getMobilePattern
         * @methodOf BB.Services:Validator
         * @description
         * Returns a pattern for matching number like strings between 9 and 19 characters
         *
         * @returns {string} Mobile regex
         */
        getMobilePattern: function getMobilePattern() {
            return mobile_regex_lenient;
        },


        /***
         * @ngdoc method
         * @name getUKLandlinePattern
         * @methodOf BB.Services:Validator
         * @description
         * Returns a pattern for matching number like strinsg between 9 and 19 characters.  If the strict flag is used, the pattern matches UK landline numbers
         *
         * @param {boolean} strict Use strict validation. Defaults to false.
         * @returns {string} UK landline regex
         */
        getUKLandlinePattern: function getUKLandlinePattern(strict) {
            if (strict == null) {
                strict = false;
            }
            if (strict) {
                return uk_landline_regex_strict;
            }
            return uk_landline_regex_lenient;
        },


        /***
         * @ngdoc method
         * @name getIntPhonePattern
         * @methodOf BB.Services:Validator
         * @description
         * Returns a pattern for matching number like strings between 9 and 19 characters
         *
         * @returns {string} International number regex
         */
        getIntPhonePattern: function getIntPhonePattern() {
            return international_number;
        },


        /***
         * @ngdoc method
         * @name getGeocodeResult
         * @methodOf BB.Services:Validator
         * @description
         * Get the geocode result
         *
         * @returns {object} Geocoder result
         */
        getGeocodeResult: function getGeocodeResult() {
            if (geocode_result) {
                return geocode_result;
            }
        },


        /***
         * @ngdoc method
         * @name validatePostcode
         * @methodOf BB.Services:Validator
         * @description
         * Validates a postcode using the Google Maps API
         *
         * @returns {promise|boolean} A promise that resolves to indicate the postcodes valdiity after it has been verified using the Google Maps API or a boolean indicating if the postcode is missing or invalid
         */
        validatePostcode: function validatePostcode(form, prms) {

            AlertService.clear();

            if (!form || !form.postcode) {
                return false;
            }

            if (form.$error.required) {

                AlertService.raise('MISSING_POSTCODE');
                return false;
            } else if (form.$error.pattern) {

                AlertService.raise('POSTCODE_INVALID');
                return false;
            } else {

                var deferred = $q.defer();

                var postcode = form.postcode.$viewValue;

                var req = { address: postcode };
                if (prms.region) {
                    req.region = prms.region;
                }
                req.componentRestrictions = { 'postalCode': req.address };

                if (prms.bounds) {
                    var sw = new google.maps.LatLng(prms.bounds.sw.x, prms.bounds.sw.y);
                    var ne = new google.maps.LatLng(prms.bounds.ne.x, prms.bounds.ne.y);
                    req.bounds = new google.maps.LatLngBounds(sw, ne);
                }

                var geocoder = new google.maps.Geocoder();
                geocoder.geocode(req, function (results, status) {

                    if (results.length === 1 && status === 'OK') {

                        geocode_result = results[0];
                        return deferred.resolve(true);
                    } else {

                        AlertService.raise('POSTCODE_INVALID');
                        $rootScope.$apply();
                        return deferred.reject(false);
                    }
                });

                return deferred.promise;
            }
        },


        /***
         * @ngdoc method
         * @name validateForm
         * @methodOf BB.Services:Validator
         * @description
         * Validate a form
         *
         * @returns {boolean} Validity of form
         */
        validateForm: function validateForm(form) {

            if (!form) {
                return false;
            }

            form.submitted = true;
            $rootScope.$broadcast("form:validated", form);

            if (form.$invalid && form.raise_alerts && form.alert) {

                AlertService.danger(form.alert);
                return false;
            } else if (form.$invalid && form.raise_alerts) {

                AlertService.danger(ErrorService.getError('FORM_INVALID'));
                return false;
            } else if (form.$invalid) {

                return false;
            } else {

                return true;
            }
        },


        /***
         * @ngdoc method
         * @name resetForm
         * @methodOf BB.Services:Validator
         * @description
         * Set pristine state on a form
         *
         * @param {form} A single instance of a form controller
         */
        resetForm: function resetForm(form) {

            if (form) {
                form.submitted = false;
                return form.$setPristine();
            }
        },


        /***
         * @ngdoc method
         * @name resetForms
         * @methodOf BB.Services:Validator
         * @description
         * Set pristine state on given array of forms
         *
         * @param {array} Array of form controllers
         */
        resetForms: function resetForms(forms) {
            if (forms && $bbug.isArray(forms)) {
                return Array.from(forms).map(function (form) {
                    return form.submitted = false, form.$setPristine();
                });
            }
        }
    };
});
'use strict';

/**
 * @ngdoc service
 * @name BB.Services.service:viewportSize
 *
 * @description
 * Stores the current screen size breakpoint.
 */
angular.module('BB.Services').service('viewportSize', function ($window, $document, $rootScope) {

  /**
   * @description variable used to store current screen size
   */
  var viewportSize = null;

  /**
   * @description id prefix for span html elements used to determin screen size via bootstrap classes
   */
  var viewportElementIdPrefix = 'viewport_size_';

  /**
   * @description used to prevent multiple viewport elements being appended to dom
   */
  var isInitialised = false;

  /**
   * @description boolean check for screen sizes
   */
  var state = {
    isXS: false,
    isSM: false,
    isMD: false,
    isLG: false
  };

  /**
   * @description returns supported bootstrap screen sizes
   * @returns {String}
   */
  var getSupportedSizes = function getSupportedSizes() {
    return ['xs', 'sm', 'md', 'lg'];
  };

  /**
   * @description logic for getting element ids
   * @param {String} size
   * @returns {String}
   */
  var getElementId = function getElementId(size) {
    return viewportElementIdPrefix + size;
  };

  /**
   * @description constructs and returns the elements used to determine screen size
   * @returns {String}
   */
  var getViewportElementsToAppend = function getViewportElementsToAppend() {
    var viewportElementStrings = '<div id="viewport_size">';
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = Array.from(getSupportedSizes())[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var size = _step.value;

        var elementId = getElementId(size);
        viewportElementStrings += ' <span id="' + elementId + '"  class="visible-' + size + '">&nbsp;</span>';
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    viewportElementStrings += '</div>';
    return viewportElementStrings;
  };

  /**
   * @description appends elements to bb element for bootstrap to show or hide
   */
  var appendViewportElementsToBBElement = function appendViewportElementsToBBElement() {
    var viewportElements = getViewportElementsToAppend();
    var bb = $document.find('#bb');
    bb.append(viewportElements);
  };

  /**
   * @description grabs elements from document after being appended to determin which ones are visible
   * @returns {Array}
   */
  var getViewportElementsFromDocument = function getViewportElementsFromDocument() {
    var viewportElements = [];
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = Array.from(getSupportedSizes())[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var size = _step2.value;

        var viewportElementId = getElementId(size);
        var viewportElement = $document[0].querySelector('#' + viewportElementId);
        viewportElements.push(viewportElement);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return viewportElements;
  };

  /**
   * @description check if element is visible based on styling
   * @param {String} element
   * @returns {boolean}
   */
  var isElementVisible = function isElementVisible(element) {
    return angular.element(element).css('display') !== 'none';
  };

  /**
   * @description Gets the bootstrap size from the class name
   * @param {String} element
   * @returns {String}
   */
  var getSizeFromElement = function getSizeFromElement(element) {
    var className = element.className.match('(visible-[a-zA-Z]*)\\b')[0];
    var size = className.replace('visible-', '').trim();
    return size;
  };

  /**
   * @description determins the current size of the screen
   */
  var findVisibleElement = function findVisibleElement() {
    var viewportElements = getViewportElementsFromDocument();
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = Array.from(viewportElements)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var viewportElement = _step3.value;

        var elementSize = getSizeFromElement(viewportElement);
        if (isElementVisible(viewportElement)) {
          viewportSize = elementSize;
          state['is' + elementSize.toUpperCase()] = true;
        } else {
          state['is' + elementSize.toUpperCase()] = false;
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
  };

  /**
   * @description get screen size when window resize function has been called
   */
  var listenForResize = function listenForResize() {
    angular.element($window).resize(function () {
      var viewportSizeOld = viewportSize;
      findVisibleElement();
      if (viewportSizeOld !== viewportSize) {
        $rootScope.$broadcast('viewportSize:changed');
      }
    });
  };

  /**
   * @description initialise before utilising viewport service
   */
  var init = function init() {
    if (!isInitialised) {
      appendViewportElementsToBBElement();
      findVisibleElement();
      listenForResize();
      isInitialised = true;
    }
  };

  /**
   * @description using function to grab screensize so it cannot be altered outside service
   * @returns {String}
   */
  var getViewportSize = function getViewportSize() {
    return viewportSize;
  };

  /**
   * @description boolean check for XS screen size
   */
  var isXS = function isXS() {
    return state.isXS;
  };

  /**
   * @description boolean check for SM screen size
   */
  var isSM = function isSM() {
    return state.isSM;
  };

  /**
   * @description boolean check for MD screen size
   */
  var isMD = function isMD() {
    return state.isMD;
  };

  /**
   * @description boolean check for LG screen size
   */
  var isLG = function isLG() {
    return state.isLG;
  };

  return {
    init: init,
    getViewportSize: getViewportSize,
    isXS: isXS,
    isSM: isSM,
    isMD: isMD,
    isLG: isLG
  };
});
'use strict';

(function () {

    /**
     * @ngdoc service
     * @name BB.WidgetModalService
     *
     * @description
     * WidgetModalService handles opening and closing of $uibModal modals
     *
     */

    angular.module('BB').factory('WidgetModalService', WidgetModal);

    function WidgetModal($uibModal, $uibModalStack, AlertService) {
        return {
            /***
             * @ngdoc method
             * @name open
             * @methodOf BB:WidgetModalService
             * @description
             * Initialises $uibModal modal
             * @param {Object} config The config to initialise the modal with
             *
             * @returns {Promise} the promise returned by $uibModal
             */
            open: function open(_config) {
                var controller = function controller($scope, WidgetModalService, config) {
                    $scope.config = config;
                    $scope.cancel = function () {
                        return WidgetModalService.close();
                    };
                };

                var resolve = { config: function config() {
                        return _config;
                    } };
                var modalOptions = {
                    templateUrl: _config.templateUrl,
                    controller: controller,
                    resolve: resolve,
                    size: 'lg'
                };

                this.modal = $uibModal.open(modalOptions);
                return this.modal;
            },


            /***
             * @ngdoc method
             * @name close
             * @methodOf BB:WidgetModalService
             * @description
             * Closes $uibModal modal
             */
            close: function close() {
                AlertService.clear();
                var openModal = $uibModalStack.getTop();
                $uibModalStack.close(openModal.key);
            }
        };
    }
})();
'use strict';

angular.module('BB.Services').config(function ($translateProvider) {
    'ngInject';

    var translations = {
        CORE: {
            ALERTS: {
                ERROR_HEADING: "Error",
                ACCOUNT_DISABLED: "Your account appears to be disabled. Please contact the business you're booking with if the problem persists.",
                ALREADY_REGISTERED: "You have already registered with this email address. Please login or reset your password.",
                APPT_AT_SAME_TIME: "Your appointment is already booked for this time",
                ATTENDEES_CHANGED: "Your booking has been successfully updated",
                EMAIL_IN_USE: "There's already an account registered with this email. Use the search field to find the customer's account.",
                EMPTY_BASKET_FOR_CHECKOUT: "You need to add some items to the basket before you can checkout.",
                FB_LOGIN_NOT_A_MEMBER: "Sorry, we couldn't find a login associated with this Facebook account. You will need to sign up using Facebook first",
                FORM_INVALID: "Please complete all required fields",
                GENERIC: "Sorry, it appears that something went wrong. Please try again or call the business you're booking with if the problem persists.",
                GEOLOCATION_ERROR_FORBIDDEN: "Sorry, we could not determine your location as your browser does not allow websites to request your physical location. Please check your browser settings.",
                GEOLOCATION_ERROR: "Sorry, we could not determine your location. Please try searching instead.",
                GIFT_CERTIFICATE_REQUIRED: "A valid Gift Certificate is required to proceed with this booking",
                POSTCODE_INVALID: "@:COMMON.TERMINOLOGY.POSTCODE_INVALID",
                ITEM_NO_LONGER_AVAILABLE: "Sorry. The item you were trying to book is no longer available. Please try again.",
                NO_WAITLIST_SPACES_LEFT: "Sorry, the space has now been taken, you are still in the waitlist and we will notify you if more spaces become available",
                LOCATION_NOT_FOUND: "Sorry, we don't recognise that location",
                LOGIN_FAILED: "Sorry, your email or password was not recognised. Please try again or reset your password.",
                SSO_LOGIN_FAILED: "Something went wrong when trying to log you in. Please try again.",
                MAXIMUM_TICKETS: "Sorry, the maximum number of tickets per person has been reached.",
                MISSING_LOCATION: "Please enter your location",
                MISSING_POSTCODE: "Please enter a postcode",
                PASSWORD_INVALID: "Sorry, your password is invalid",
                PASSWORD_MISMATCH: "Your passwords don't match",
                PASSWORD_RESET_FAILED: "Sorry, we couldn't update your password. Please try again.",
                PASSWORD_RESET_REQ_FAILED: "Sorry, we didn't find an account registered with that email.",
                PASSWORD_RESET_REQ_SUCCESS: "We have sent you an email with instructions on how to reset your password.",
                PASSWORD_RESET_SUCESS: "Your password has been updated.",
                PAYMENT_FAILED: "We were unable to take payment. Please contact your card issuer or try again using a different card",
                PHONE_NUMBER_IN_USE: "There's already an account registered with this phone number. Use the search field to find the customer's account.",
                REQ_TIME_NOT_AVAIL: "The requested time slot is not available. Please choose a different time.",
                TIME_SLOT_NOT_SELECTED: "You need to select a time slot",
                STORE_NOT_SELECTED: "You need to select a store",
                TOPUP_FAILED: "Sorry, your topup failed. Please try again.",
                TOPUP_SUCCESS: "Your wallet has been topped up",
                UPDATE_FAILED: "Update failed. Please try again",
                UPDATE_SUCCESS: "Updated",
                WAITLIST_ACCEPTED: "Your booking is now confirmed!",
                BOOKING_CANCELLED: "Your booking has been cancelled.",
                NOT_BOOKABLE_PERSON: "Sorry, this person does not offer this service, please select another",
                NOT_BOOKABLE_RESOURCE: "Sorry, resource does not offer this service, pelase select another",
                SPEND_AT_LEAST: "You need to spend at least {{min_spend | pretty_price}} to make a booking.",
                COUPON_APPLY_FAILED: "Sorry, your coupon could not be applied. Please try again.",
                DEAL_APPLY_FAILED: "Sorry, your deal code could not be applied. Please try again.",
                DEAL_REMOVE_FAILED: "Sorry, we were unable to remove that deal. Please try again.",
                MOVE_BOOKING_SUCCESS: "Your booking has been moved to {{datetime | datetime: 'LLLL':true}}",
                MOVE_BOOKING_FAILED: "Failed to move booking. Please try again."
            },
            PAGINATION: {
                SUMMARY: "{{start}} - {{end}} of {{total}}"
            },
            MODAL: {
                CANCEL_BOOKING: {
                    HEADER: "Cancel",
                    QUESTION: "Are you sure you want to cancel this {{type}}?"
                },
                SCHEMA_FORM: {
                    OK_BTN: "@:COMMON.BTN.OK",
                    CANCEL_BTN: "@:COMMON.BTN.CANCEL"
                },
                CANCEL_BLOCK: "Cancel Block",
                SAVE_BLOCK: "Save Block",
                EDIT_BLOCK: "Edit Block",
                EDIT_BOOKING: "Edit Booking"
            },
            FILTERS: {
                DISTANCE: {
                    MILES: "miles",
                    KILOMETRES: "km"
                },
                CURRENCY: {
                    THOUSANDS_SEPARATOR: ",",
                    DECIMAL_SEPARATOR: ".",
                    CURRENCY_FORMAT: "%s%v"
                },
                PRETTY_PRICE: {
                    FREE: "@:COMMON.TERMINOLOGY.PRICE_FREE"
                },
                TIME_PERIOD: {
                    TIME_PERIOD: "{hours, plural, =0{} one{1 hour} other{# hours}}{show_seperator, plural, =0{} =1{, } other{}}{minutes, plural, =0{} one{1 minute} other{# minutes}}"
                }
            },
            EVENT: {
                SPACES_LEFT: "Only {N, plural, one{one space}, other{# spaces}} left",
                JOIN_WAITLIST: "Join waitlist"
            }
        },
        COMMON: {
            TERMINOLOGY: {
                CATEGORY: "Category",
                DURATION: "Duration",
                RESOURCE: "Resource",
                PERSON: "Person",
                SERVICE: "Service",
                WALLET: "Wallet",
                SESSION: "Session",
                EVENT: "Event",
                EVENTS: "Events",
                COURSE: "Course",
                COURSES: "Courses",
                DATE: "Date",
                TIME: "Time",
                DATE_TIME: "Date/Time",
                WHEN: "When",
                GIFT_CERTIFICATE: "Gift Certificate",
                GIFT_CERTIFICATES: "Gift Certificates",
                ITEM: "Item",
                FILTER: "Filter",
                ANY: "Any",
                RESET: "Reset",
                TOTAL: "Total",
                TOTAL_DUE_NOW: "Total Due Now",
                BOOKING_FEE: "Booking Fee",
                PRICE: "Price",
                PRICE_FREE: "Free",
                PRINT: "Print",
                AND: "and",
                APPOINTMENT: "Appointment",
                TICKETS: "Tickets",
                TYPE: "Type",
                EXPORT: "Export",
                RECIPIENT: "Recipient",
                BOOKING_REF: "Booking Reference",
                MORNING: "Morning",
                AFTERNOON: "Afternoon",
                EVENING: "Evening",
                AVAILABLE: "Available",
                UNAVAILABLE: "Unavailable",
                CALENDAR: "Calendar",
                QUESTIONS: "Questions",
                BOOKING: "Booking",
                ADMITTANCE: "Admittance",
                EDIT: "Edit",
                CONFIRMATION: "Confirmation",
                NAME: "Name",
                FIRST_NAME: "First Name",
                LAST_NAME: "Last Name",
                ADDRESS1: "Address",
                ADDRESS3: "Town",
                ADDRESS4: "County",
                POSTCODE: "Postcode",
                PHONE: "Phone",
                MOBILE: "Mobile",
                EMAIL: "Email",
                SCHEDULE: "Schedule",
                SEARCH: "Search",
                STAFF: "Staff",
                RESOURCES: "Resources"
            },
            FORM: {
                FIRST_NAME_REQUIRED: "Please enter your first name",
                LAST_NAME_REQUIRED: "Please enter your last name",
                ADDRESS_REQUIRED: "Please enter your address",
                POSTCODE_INVALID: "Please enter a valid postcode",
                PHONE_INVALID: "Please enter a valid phone number",
                MOBILE_INVALID: "Please enter a valid mobile number",
                EMAIL_REQUIRED: "Please enter your email",
                EMAIL_INVALID: "Please enter a valid email address",
                FIELD_REQUIRED: "This field is required",
                PASSWORD: "Password",
                PASSWORD_REQUIRED: "Please enter your password",
                CONFIRM_PASSWORD: "Confirm password",
                PASSWORD_MISMATCH: "Please ensure your passwords match",
                PASSWORD_LENGTH: "Password must be at least 7 characters",
                REQUIRED: "*Required",
                INVALID: "Invalid",
                TERMS_AND_CONDITIONS: "I agree to the terms and conditions",
                TERMS_AND_CONDITIONS_REQUIRED: "Please accept the terms and conditions"
            },
            BTN: {
                CANCEL: "Cancel",
                CLOSE: "Close",
                NO: "No",
                OK: "Ok",
                YES: "Yes",
                BACK: "Back",
                NEXT: "Continue",
                LOGIN: "Login",
                CONFIRM: "Confirm",
                SAVE: "Save",
                SELECT: "Select",
                BOOK: "Book",
                BOOK_EVENT: "Book Event",
                CANCEL_BOOKING: "Cancel Booking",
                MOVE_BOOKING: "Move Booking",
                SAVE_BOOKING: "Save Booking",
                EDIT_BOOKING: "Edit Booking",
                DO_NOT_CANCEL_BOOKING: "Do not cancel",
                APPLY: "Apply",
                CLEAR: "Clear",
                PAY: "Pay",
                CHECKOUT: "Checkout",
                TOP_UP: "Top Up",
                ADD: "Add",
                SUBMIT: "Submit",
                DETAILS: "Details",
                MORE: "More",
                LESS: "Less",
                DELETE: "Delete",
                BUY: "Buy",
                EDIT_CLIENT: "Edit Client"
            },
            LANGUAGE: {
                EN: "English",
                DE: "Deutsch",
                ES: "Español",
                FR: "Français"
            }
        }
    };

    $translateProvider.translations('en', translations);
});
'use strict';

(function (angular) {

    angular.module('BB.analytics').provider('bbAnalyticsPiwik', BBAnalyticsPiwikProvider);

    function BBAnalyticsPiwikProvider($analyticsProvider, $windowProvider) {
        'ngInject';

        var _this = this;

        var options = {
            firstPageView: false,
            virtualPageViews: false,
            enableLinkTracking: true,
            trackPageView: false,
            siteId: 1,
            trackerUrl: "https://analytics.bookingbug.com/piwik.php",
            scriptUrl: "https://analytics.bookingbug.com/piwik.js"
        };

        var $window = $windowProvider.$get();
        var enabled = false;

        this.isEnabled = function () {
            return enabled;
        };
        this.push = function (data) {
            if (!this.isEnabled()) return;
            // ---------------------------------------------------------------
            // we need to do this because the _paq object is not immediately
            // available after Piwik script is loaded
            // ---------------------------------------------------------------
            var _paq = [];
            if (!$window._paq) {
                $window._paq = _paq;
            } else {
                _paq = $window._paq;
            }
            _paq.push(data);
        };

        this.setOption = function (option, value) {
            if (!options.hasOwnProperty(option)) return;
            options[option] = value;
        };

        this.getOption = function (option) {
            if (!options.hasOwnProperty(option)) return null;
            return options[option];
        };

        this.enable = function () {
            enabled = true;

            $analyticsProvider.virtualPageviews(options.virtualPageViews);
            $analyticsProvider.firstPageview(options.firstPageView);

            if (options.trackPageView) _this.push(['trackPageView']);
            if (options.enableLinkTracking) _this.push(['enableLinkTracking']);

            _this.push(['setTrackerUrl', options.trackerUrl]);
            _this.push(['setSiteId', options.siteId]);

            var piwikScript = $window.document.createElement('script');
            piwikScript.type = 'text/javascript';
            piwikScript.async = true;
            piwikScript.defer = true;
            piwikScript.src = options.scriptUrl;

            var firstScript = $window.document.getElementsByTagName('script')[0];
            firstScript.parentNode.insertBefore(piwikScript, firstScript);
        };

        this.$get = function () {
            return {
                getOption: _this.getOption,
                isEnabled: _this.isEnabled,
                push: _this.push
            };
        };
    }
})(angular);
'use strict';

(function () {

    /**
     * @ngdoc directive
     * @name BB.bbMoveBooking
     *
     * @description
     * bbMoveBooking component enables changing time of bookings when widget is initialised in a modal via bbMoveBookingOpenMoveModal
     *
     <example module='BB.bbMoveBooking'>
        <bb-move-booking
          booking-to-move="bookings[0]"
          purchase="bb.purchase">
        </bb-move-booking>
      </example>
     */

    angular.module('BB').component('bbMoveBooking', {
        templateUrl: '_move_booking.html',
        bindings: {
            bookingToMove: '<',
            purchase: '<'
        },
        controller: bbMoveBookingCtrl,
        controllerAs: '$bbMoveBookingCtrl'
    });

    function bbMoveBookingCtrl($scope, $rootScope, $log, $translate, $timeout, AlertService, LoadingService, bbWidgetPage, PurchaseBookingService, PurchaseService, AppService, MoveBookingOptions, bbAnalyticsPiwik) {
        var _this = this;

        var setPiwik = function setPiwik() {
            if (bbAnalyticsPiwik.isEnabled()) {
                bbAnalyticsPiwik.push(['trackEvent', [bbWidgetPage.getCurrentPage], "Move Booking"]);
            }
        };

        var handleMovedBooking = function handleMovedBooking(movedBooking) {
            if (!_this.purchase) return getPurchaseTotal(movedBooking);
            var updatedPurchase = PurchaseService.updateBBPurchase(_this.purchase, movedBooking);
            routeToNextStep(updatedPurchase);
        };

        var getPurchaseTotal = function getPurchaseTotal(movedBooking) {
            PurchaseService.query({ url_root: $rootScope.bb.api_url, purchase_id: movedBooking.purchase_ref }).then(function (purchase) {
                routeToNextStep(purchase);
            }, function (err) {
                _this.loader.setLoaded();
                $log.info(err);
            });
        };

        var routeToNextStep = function routeToNextStep(updatedPurchase) {
            _this.loader.setLoaded();
            bbWidgetPage.decideNextPage(MoveBookingOptions.nextStepTemplate);
            $timeout(function () {
                $scope.$emit('booking:moved', updatedPurchase);
                $rootScope.$broadcast('booking:moved', updatedPurchase);
            });
        };

        this.$onInit = function () {
            _this.loader = LoadingService.$loader($scope);
        };

        this.moveBooking = function () {
            if (AppService.isModalOpen()) {
                setPiwik();
                _this.bookingToMove.setAskedQuestions();
                // setAskedQuestions will check if the booking is ready to be moved
                if (_this.bookingToMove.ready) {
                    _this.loader.notLoaded();
                    PurchaseBookingService.update(_this.bookingToMove).then(function (movedBooking) {
                        handleMovedBooking(movedBooking);
                    }, function (err) {
                        _this.loader.setLoaded();
                        $log.info(err);
                        AlertService.add('danger', { msg: $translate.instant('CORE.ALERTS.MOVE_BOOKING_FAILED') });
                    });
                } else {
                    $log.info('booking is not ready to be moved');
                }
            } else $log.info('please load bbMoveBooking using bbMoveBookingOpenMoveModal(which would load in a modal).');
        };
    }
})();
'use strict';

(function () {

    /**
     * @ngdoc directive
     * @name BB.bbMoveBooking
     *
     * @description
     * bbMoveBookingOpenMoveModal component initialises widget in modal to change time of bookings
     *
     <example module='BB.bbMoveBooking'>
        <bb-move-booking-open-move-modal
          booking-to-move="bookings[0]"
          move-reasons="bb.move_reasons"
          cancel-reasons="bb.cancel_reasons">
        </bb-move-booking-open-move-modal>
      </example>
     */

    angular.module('BB').component('bbMoveBookingOpenMoveModal', {
        templateUrl: '_move_booking_open_move_modal.html',
        bindings: {
            bookingToMove: '<',
            cancelReasons: '<',
            moveReasons: '<'
        },
        controller: bbMoveBookingOpenMoveModalCtrl,
        controllerAs: '$bbMoveBookingOpenMoveModalCtrl'
    });

    function bbMoveBookingOpenMoveModalCtrl(MoveBookingOptions, WidgetModalService) {

        this.openMoveModal = function () {
            this.modalParams = {
                company_id: this.bookingToMove.company_id,
                total_id: this.bookingToMove.purchase_ref,
                first_page: MoveBookingOptions.modalFirstPage,
                template: MoveBookingOptions.modalTemplate,
                templateUrl: MoveBookingOptions.modalTemplateUrl,
                move_reasons: this.moveReasons ? this.moveReasons : null,
                cancel_reasons: this.cancelReasons ? this.cancelReason : null,
                size: 'lg'
            };

            WidgetModalService.open(this.modalParams);
        };
    }
})();
'use strict';

(function () {

    angular.module('BB.Services').provider('MoveBookingOptions', function () {

        var options = {
            modalFirstPage: 'calendar',
            modalTemplate: 'main_view_booking',
            modalTemplateUrl: 'widget_modal.html',
            nextStepTemplate: 'confirmation'
        };

        this.setOption = function (option, value) {
            if (options.hasOwnProperty(option)) {
                options[option] = value;
            }
        };

        this.$get = function () {
            return options;
        };
    });
})();
'use strict';

/**
 * @ngdoc directive
 * @name BB.i18n:bbLanguagePicker
 * @scope
 * @restrict A
 *
 * @description
 * Responsible for providing a ui representation of available translations
 *
 */
angular.module('BB.i18n').directive('bbLanguagePicker', function () {

    return {
        controller: bbLanguagePickerController,
        controllerAs: 'vm',
        restrict: 'A',
        scope: true,
        link: bbLanguagePickerLink,
        templateUrl: 'i18n/language_picker.html'
    };
});

function bbLanguagePickerLink(scope, element, attrs) {

    if (scope.vm.availableLanguages.length <= 1) {
        angular.element(element).addClass('hidden');
    }
}

function bbLanguagePickerController($rootScope, $scope, bbLocale, tmhDynamicLocale, bbi18nOptions) {
    'ngInject';

    /*jshint validthis: true */

    var _this = this;

    var languages = bbi18nOptions.available_languages;
    this.language = null;
    this.availableLanguages = [];
    this.setAvailableLanguages = setAvailableLanguages;
    this.setCurrentLanguage = setCurrentLanguage;
    this.setLanguage = setLanguage;

    (function () {
        _this.setAvailableLanguages();
        _this.setCurrentLanguage();
        $scope.$on('BBLanguagePicker:refresh', setCurrentLanguage);
        _this.pickLanguage = pickLanguage;
    })();

    function setAvailableLanguages() {
        var _this2 = this;

        languages.forEach(function (languageKey) {
            _this2.availableLanguages.push(createLanguage(languageKey));
        });
    }

    function setCurrentLanguage() {
        var _this3 = this;

        tmhDynamicLocale.set(bbLocale.getLocale()).then(function () {
            _this3.language = { selected: createLanguage(bbLocale.getLocale()) };
        });
    }

    /*
     * @param {String]
     */
    function createLanguage(languageKey) {
        return {
            identifier: languageKey,
            label: 'COMMON.LANGUAGE.' + languageKey.toUpperCase()
        };
    }

    function setLanguage(lang) {
        this.language.selected = lang;
        this.pickLanguage(lang.identifier);
    }

    /*
     * @param {String]
     */
    function pickLanguage(languageKey) {
        tmhDynamicLocale.set(languageKey).then(function () {
            bbLocale.setLocale(languageKey, 'bbLanguagePicker.pickLanguage');
            $rootScope.$broadcast('BBLanguagePicker:languageChanged');
        });
    }
}
'use strict';

(function () {

    'use strict';

    /**
     * @ngdoc directive
     * @name BBAdminDashboard.bbTimeZoneSelect
     *
     * @description
     * TimeZone Select component changes the time zone in which times are displayed in Studio
     * Configured using bbi18nOptionsProvider
     *
     *
     <example module='BBAdminDashboard.bbTimeZoneSelect'>
        <bb-time-zone-select></bb-time-zone-select>
     </example>
     */

    angular.module('BB.i18n').component('bbTimeZoneSelect', {
        templateUrl: 'i18n/_bb_timezone_select.html',
        bindings: {
            hideToggle: '<',
            format: '<'
        },
        controller: TimeZoneSelectCtrl,
        controllerAs: '$bbTimeZoneSelectCtrl'
    });

    function TimeZoneSelectCtrl($rootScope, $scope, $localStorage, bbi18nOptions, bbTimeZone, bbTimeZoneOptions, bbTimeZoneUtils) {
        'ngInject';

        var _this = this;

        var LIST_CAPACITY = 100;
        var companyTimeZone = void 0;
        var displayTimeZone = void 0;
        var browserTimeZone = void 0;

        this.timeZones = [];
        this.isAutomaticTimeZone = false;
        this.selectedTimeZone = null;
        this.isLongList = false;

        this.$onInit = function () {
            _this.timeZones = bbTimeZoneOptions.composeTimeZoneList(_this.format, bbTimeZone.getDisplay());
            _this.isLongList = _this.timeZones.length > LIST_CAPACITY;
            _this.setTimeZone = setTimeZone;
            _this.automaticTimeZoneToggle = automaticTimeZoneToggle;
            $rootScope.connection_started ? $rootScope.connection_started.then(determineDefaults) : determineDefaults();
        };

        var determineDefaults = function determineDefaults() {
            var localStorage = $localStorage.getObject('bbTimeZone');
            var getEqualTzInList = function getEqualTzInList(timeZone) {
                return bbTimeZoneUtils.getEqualInList(timeZone, _this.timeZones);
            };
            companyTimeZone = getEqualTzInList(bbTimeZone.getCompany());
            displayTimeZone = getEqualTzInList(bbTimeZone.getDisplay());
            browserTimeZone = getEqualTzInList(moment.tz.guess());
            _this.isAutomaticTimeZone = localStorage.useBrowserTimeZone || bbi18nOptions.timeZone.useBrowser && !localStorage.displayTimeZone;
            _this.selectedTimeZone = _this.timeZones.find(function (tz) {
                return tz.value === displayTimeZone;
            });
        };

        var automaticTimeZoneToggle = function automaticTimeZoneToggle() {
            displayTimeZone = _this.isAutomaticTimeZone ? browserTimeZone : companyTimeZone;
            _this.timeZones = bbTimeZoneOptions.addMissingTimeZones(_this.timeZones, _this.format, displayTimeZone);
            setTimeZone(displayTimeZone, _this.isAutomaticTimeZone);
            $scope.$broadcast('UISelect:closeSelect');
            bbTimeZone.setLocalStorage({ useBrowserTimeZone: _this.isAutomaticTimeZone });
        };

        var setTimeZone = function setTimeZone(timeZone) {
            var isAutomaticTimeZone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

            displayTimeZone = timeZone;
            bbTimeZone.setDisplay(timeZone);
            _this.selectedTimeZone = _this.timeZones.find(function (tz) {
                return tz.value === timeZone;
            });
            $rootScope.$broadcast('BBTimeZoneOptions:timeZoneChanged', timeZone);
            if (!isAutomaticTimeZone) bbTimeZone.setLocalStorage({ displayTimeZone: timeZone });
        };

        var languageChangedHandler = function languageChangedHandler() {
            _this.timeZones = bbTimeZoneOptions.composeTimeZoneList(_this.format, displayTimeZone);
            _this.selectedTimeZone = _this.timeZones.find(function (tz) {
                return tz.value === displayTimeZone;
            });
        };

        $scope.$on('BBLanguagePicker:languageChanged', languageChangedHandler);
    }
})();
'use strict';

(function () {

    angular.module('BB.i18n').constant('bbCustomTimeZones', {
        GROUPED_TIME_ZONES: {
            'Africa/Cairo': 'Cairo',
            'Africa/Casablanca': 'Monrovia',
            'Africa/Harare': 'Harare, Pretoria',
            'Africa/Lagos': 'West Central Africa',
            'Africa/Nairobi': 'Nairobi',
            'America/Bogota': 'Bogota, Lima, Quito',
            'America/Buenos_Aires': 'Buenos Aires, Georgetown',
            'America/Caracas': 'Caracas, La Paz',
            'America/Chicago': 'Central Time (US and Canada)',
            'America/Chihuahua': 'Chihuahua, Mazatlan',
            'America/Denver': 'Mountain Time (US and Canada)',
            'America/El_Salvador': 'Central America',
            'America/Halifax': 'Atlantic Time (Canada)',
            'America/Indiana/Knox': 'Indiana (East)',
            'America/Los_Angeles': 'Pacific Time (US and Canada); Tijuana',
            'America/Mexico_City': 'Guadalajara, Mexico City, Monterrey',
            'America/New_York': 'Eastern Time (US and Canada)',
            'America/Phoenix': 'Arizona',
            'America/Santiago': 'Santiago',
            'America/Sao_Paulo': 'Brasilia',
            'America/Thule': 'Greenland',
            'Asia/Almaty': 'Almaty, Novosibirsk',
            'Asia/Baghdad': 'Baghdad',
            'Asia/Bangkok': 'Bangkok, Hanoi, Jakarta',
            'Asia/Colombo': 'Sri Jayawardenepura',
            'Asia/Dhaka': 'Astana, Dhaka',
            'Asia/Dubai': 'Abu Dhabi, Muscat',
            'Asia/Hong_Kong': 'Beijing, Chongqing, Hong Kong SAR, Urumqi',
            'Asia/Irkutsk': 'Irkutsk, Ulaanbaatar',
            'Asia/Jerusalem': 'Jerusalem',
            'Asia/Kabul': 'Kabul',
            'Asia/Karachi': 'Islamabad, Karachi, Tashkent',
            'Asia/Kathmandu': 'Kathmandu',
            'Asia/Kolkata': 'Chennai, Kolkata, Mumbai, New Delhi',
            'Asia/Krasnoyarsk': 'Krasnoyarsk',
            'Asia/Kuwait': 'Kuwait, Riyadh',
            'Asia/Magadan': 'Magadan, Solomon Islands, New Caledonia',
            'Asia/Rangoon': 'Yangon Rangoon',
            'Asia/Seoul': 'Seoul',
            'Asia/Singapore': 'Kuala Lumpur, Singapore',
            'Asia/Taipei': 'Taipei',
            'Asia/Tehran': 'Tehran',
            'Asia/Tokyo': 'Osaka, Sapporo, Tokyo',
            'Asia/Vladivostok': 'Vladivostok',
            'Asia/Yakutsk': 'Yakutsk',
            'Asia/Yekaterinburg': 'Ekaterinburg',
            'Asia/Yerevan': 'Baku, Tbilisi, Yerevan',
            'Atlantic/Azores': 'Azores',
            'Atlantic/Cape_Verde': 'Cape Verde Islands',
            'Australia/Adelaide': 'Adelaide',
            'Australia/Brisbane': 'Brisbane',
            'Australia/Canberra': 'Canberra, Melbourne, Sydney',
            'Australia/Darwin': 'Darwin',
            'Australia/Perth': 'Perth',
            'Australia/Tasmania': 'Hobart',
            'Canada/Newfoundland': 'Newfoundland and Labrador',
            'Canada/Saskatchewan': 'Saskatchewan',
            'Etc/GMT+12': 'International Date Line West',
            'Europe/Amsterdam': 'Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna',
            'Europe/Athens': 'Athens, Minsk',
            'Europe/Belgrade': 'Belgrade, Bratislava, Budapest, Ljubljana, Prague',
            'Europe/Bucharest': 'Bucharest',
            'Europe/Helsinki': 'Helsinki, Kiev, Riga, Sofia, Tallinn, Vilnius',
            'Europe/Istanbul': 'Istanbul',
            'Europe/London': 'Edinburgh, Lisbon, London',
            'Europe/Moscow': 'Moscow, St. Petersburg, Volgograd',
            'Europe/Paris': 'Brussels, Copenhagen, Madrid, Paris',
            'Europe/Sarajevo': 'Sarajevo, Skopje, Warsaw, Zagreb',
            'Pacific/Auckland': 'Auckland, Wellington',
            'Pacific/Fiji': 'Fiji Islands, Kamchatka, Marshall Islands',
            'Pacific/Guam': 'Guam, Port Moresby',
            'Pacific/Honolulu': 'Hawaii',
            'Pacific/Pago_Pago': 'Midway Island, Samoa',
            'Pacific/Tongatapu': 'Nuku\'alofa',
            'US/Alaska': 'Alaska'
        }
    });
})();
'use strict';

angular.module('BB.i18n').provider('bbi18nOptions', function (bbOptionsProvider) {
    'ngInject';

    var options = {
        default_language: 'en',
        use_browser_language: true,
        available_languages: ['en'],
        available_language_associations: {
            'en_*': 'en',
            'fr_*': 'fr'
        },
        timeZone: {
            default: 'Europe/London',
            useBrowser: false,
            useCompany: true,
            useCustomList: true,
            replaceBrowser: { replace: '', replaceWith: '' },
            filters: {
                limitTo: [],
                limitDaylightSaving: [],
                limitStandard: [],
                exclude: []
            }
        }
    };

    this.setOption = function (option, value) {
        options = bbOptionsProvider.setOption(options, option, value);
    };

    this.getOption = function (option) {
        return options[option];
    };

    this.$get = function () {
        return options;
    };
});
'use strict';

angular.module('BB.i18n').service('bbLocale', function (bbi18nOptions, $log, $translate, $window) {
    'ngInject';

    var _localeCompanyUsed = false;

    var determineLocale = function determineLocale() {

        if ($translate.use() !== 'undefined' && angular.isDefined($translate.use()) && isAvailable($translate.use())) {
            setLocale($translate.use(), '$translate.use() locale');
        } else {
            var browserLocale = $translate.negotiateLocale($translate.resolveClientLocale()); //browserLocale = $window.navigator.language;
            var defaultLocale = bbi18nOptions.default_language;
            var URIParamLocale = $window.getURIparam('locale');

            if (URIParamLocale && isAvailable(URIParamLocale)) {
                setLocale(URIParamLocale, 'URIParam locale');
            } else if (bbi18nOptions.use_browser_language && isAvailable(browserLocale)) {
                setLocale(browserLocale, 'browser locale');
            } else {
                setLocale(defaultLocale, 'default locale');
            }
        }

        $translate.preferredLanguage(getLocale());
    };

    /*
     * @param {String} locale
     * @param {String} setWith
     */
    var setLocale = function setLocale(locale, setWith) {
        if (setWith == null) {
            setWith = '';
        }
        if (!isAvailable(locale)) {
            return;
        }

        moment.locale(locale); // TODO we need angular wrapper for moment
        $translate.use(locale);

        //console.info('bbLocale.locale = ', locale, ', set with: ', setWith)

        if (locale !== moment.locale() || locale !== $translate.use()) {
            console.error('moment locale not available, preferred locale = ' + locale + ', moment.locale() = ', moment.locale(), '$translate.use() = ', $translate.use());
        }
    };

    /*
     * {String} locale
     */
    var isAvailable = function isAvailable(locale) {
        return bbi18nOptions.available_languages.indexOf(locale) !== -1;
    };

    /*
     * @returns {String}
     */
    var getLocale = function getLocale() {
        return $translate.use();
    };

    /*
     * It's a hacky way to map country code to specific locale. Reason is moment default is set to en_US
     * @param {string} countryCode
     */
    var setLocaleUsingCountryCode = function setLocaleUsingCountryCode(countryCode) {
        if (_localeCompanyUsed) {
            return; //can be set only once
        }
        _localeCompanyUsed = true;

        if (countryCode && countryCode.match(/^(gb|au)$/)) {
            var locale = 'en-' + countryCode;
            setLocale(locale, 'countryCode');
        }
    };

    return {
        determineLocale: determineLocale,
        getLocale: getLocale,
        setLocale: setLocale,
        setLocaleUsingCountryCode: setLocaleUsingCountryCode
    };
});
'use strict';

(function () {

    /**
     * @ngdoc service
     * @name BBAdminDashboard.bbTimeZone
     * @description
     * TimeZone factory
     */
    angular.module('BB.i18n').service('bbTimeZone', bbTimeZoneService);

    function bbTimeZoneService($localStorage, $log, moment, bbi18nOptions, CompanyStoreService, bbCustomTimeZones, bbTimeZoneUtils) {
        'ngInject';

        var displayTimeZone = bbTimeZoneUtils.getKeyInCustomList(bbi18nOptions.timeZone.default, bbi18nOptions.timeZone.useCustomList);

        return {
            getDisplay: getDisplay,
            getDisplayUTCOffset: getDisplayUTCOffset,
            getCompany: getCompany,
            getCompanyUTCOffset: getCompanyUTCOffset,

            convertToCompany: convertToCompany,
            convertToDisplay: convertToDisplay,

            determine: determine,
            setDisplay: setDisplay,
            setLocalStorage: setLocalStorage
        };

        /**
         * @param {moment|String} dateTime If string must be valid ISO string
         * @returns {moment}
         */
        function convertToCompany(dateTime) {
            return convertDateTime(dateTime, CompanyStoreService.time_zone);
        }

        /**
         * @param {moment|String} dateTime If string must be valid ISO string
         * @returns {moment}
         */
        function convertToDisplay(dateTime) {
            return convertDateTime(dateTime, displayTimeZone);
        }

        function convertDateTime(dateTime, timeZone) {
            if (!moment(dateTime).isValid()) $log.error('not valid dateTime', dateTime);
            var converted = moment.tz(dateTime, timeZone);
            return converted;
        }

        function getDisplay() {
            return displayTimeZone;
        }

        function getDisplayUTCOffset() {
            return moment().tz(displayTimeZone).utcOffset();
        }

        function getCompany() {
            return CompanyStoreService.time_zone;
        }

        function getCompanyUTCOffset() {
            return moment().tz(CompanyStoreService.time_zone).utcOffset();
        }

        function determine() {
            var _bbi18nOptions$timeZo = bbi18nOptions.timeZone,
                useBrowser = _bbi18nOptions$timeZo.useBrowser,
                useCustomList = _bbi18nOptions$timeZo.useCustomList,
                useCompany = _bbi18nOptions$timeZo.useCompany;

            var localStorage = $localStorage.getObject('bbTimeZone');

            if (localStorage.displayTimeZone) {
                setDisplay(localStorage.displayTimeZone);
                return;
            }

            if (useBrowser || localStorage.useBrowserTimeZone) {
                var timeZone = bbTimeZoneUtils.getKeyInCustomList(moment.tz.guess(), useCustomList);
                setDisplay(timeZone);
                return;
            }

            if (useCompany && CompanyStoreService.time_zone) {
                var _timeZone = bbTimeZoneUtils.getKeyInCustomList(CompanyStoreService.time_zone, useCustomList);
                setDisplay(_timeZone);
            }
        }

        function setDisplay(timeZone) {
            moment.tz.setDefault(timeZone);
            displayTimeZone = timeZone;
        }

        function setLocalStorage(localStorageObj) {
            $localStorage.setObject('bbTimeZone', localStorageObj);
        }
    }
})();
'use strict';

(function () {

    /**
     * @ngdoc service
     * @name BBAdminDashboard.bbTimeZoneOptions
     * @description
     * TimeZone options factory
     */
    angular.module('BB.i18n').factory('bbTimeZoneOptions', timeZoneOptionsService);

    function timeZoneOptionsService(bbi18nOptions, bbTimeZoneUtils) {
        'ngInject';

        var compose = function compose() {
            for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
                funcs[_key] = arguments[_key];
            }

            return function (value) {
                return funcs.reduce(function (v, fn) {
                    return fn(v);
                }, value);
            };
        };
        var initOptions = function initOptions() {
            var timeZones = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            var displayFormat = arguments[1];
            var timeZone = arguments[2];

            return {
                timeZone: timeZone,
                timeZones: timeZones,
                displayFormat: displayFormat,
                useCustomList: bbi18nOptions.timeZone.useCustomList,
                filters: bbi18nOptions.timeZone.filters,
                isDST: moment().isDST()
            };
        };

        return {
            composeTimeZoneList: composeTimeZoneList,
            addMissingTimeZones: addMissingTimeZones
        };

        function composeTimeZoneList(displayFormat, timeZone) {
            var options = initOptions(undefined, displayFormat, timeZone);
            var composeTimeZones = compose(bbTimeZoneUtils.loadKeys, bbTimeZoneUtils.findFilterKeysInCustomList, bbTimeZoneUtils.filter, bbTimeZoneUtils.reject, bbTimeZoneUtils.filterDayLightOrStandard, bbTimeZoneUtils.ensureExists, bbTimeZoneUtils.mapModel, bbTimeZoneUtils.removeDuplicates, bbTimeZoneUtils.order);
            return composeTimeZones(options).timeZones;
        }

        function addMissingTimeZones(timeZones, displayFormat, timeZone) {
            var options = initOptions(timeZones, displayFormat, timeZone);
            var composeTimeZones = compose(bbTimeZoneUtils.ensureExists, bbTimeZoneUtils.mapModel, bbTimeZoneUtils.removeDuplicates, bbTimeZoneUtils.order);
            return options.filters.limitTo.length ? composeTimeZones(options).timeZones : timeZones;
        }
    }
})();
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

(function () {

    /**
     * @ngdoc service
     * @name BBAdminDashboard.bbTimeZoneOptions
     * @description
     * TimeZone options factory
     */
    angular.module('BB.i18n').factory('bbTimeZoneUtils', bbTimeZoneUtils);

    function bbTimeZoneUtils($translate, $log, moment, orderByFilter, bbi18nOptions, bbCustomTimeZones) {
        'ngInject';

        return {
            loadKeys: loadKeys,
            filter: filter,
            reject: reject,
            findFilterKeysInCustomList: findFilterKeysInCustomList,
            filterDayLightOrStandard: filterDayLightOrStandard,
            ensureExists: ensureExists,
            mapModel: mapModel,
            removeDuplicates: removeDuplicates,
            order: order,

            getKeyInCustomList: getKeyInCustomList,
            getEqualInList: getEqualInList
        };

        function loadKeys(options) {
            return Object.assign({}, options, {
                timeZones: options.useCustomList ? Object.keys(bbCustomTimeZones.GROUPED_TIME_ZONES) : loadMomentNames()
            });
        }

        function loadMomentNames() {
            var timeZones = moment.tz.names();
            var contains = function contains(timeZone) {
                return function (strings) {
                    return _.any(strings, function (string) {
                        return timeZone.indexOf(string) !== -1;
                    });
                };
            };
            var isUpperCase = function isUpperCase(timeZone) {
                return timeZone.match(/[^/]*$/)[0] === timeZone.match(/[^/]*$/)[0].toUpperCase();
            };
            return _.chain(timeZones).reject(contains(['GMT', 'Etc'])).reject(isUpperCase).value();
        }

        function findFilterKeysInCustomList(options) {
            var getKey = function getKey(timeZoneKey) {
                return getKeyInCustomList(timeZoneKey, options.useCustomList);
            };
            var mapFilters = function mapFilters(listOfFilters, typeOfFilter, filters) {
                return filters[typeOfFilter] = _.map(listOfFilters, getKey);
            };
            return Object.assign({}, options, {
                filters: _.mapObject(options.filters, mapFilters)
            });
        }

        function filter(options) {
            return Object.assign({}, options, {
                timeZones: filterTimeZoneList(options.timeZones, options.filters.limitTo)
            });
        }

        function reject(options) {
            return Object.assign({}, options, {
                timeZones: filterTimeZoneList(options.timeZones, options.filters.exclude, true)
            });
        }

        function filterDayLightOrStandard(options) {
            var _options$filters = options.filters,
                limitDaylightSaving = _options$filters.limitDaylightSaving,
                limitStandard = _options$filters.limitStandard;

            return Object.assign({}, options, {
                timeZones: filterTimeZoneList(options.timeZones, options.isDST ? limitDaylightSaving : limitStandard)
            });
        }

        function filterTimeZoneList(timeZones, timeZonesToFilter) {
            var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;


            if (!angular.isArray(timeZonesToFilter)) {
                $log.error('must be an Array:', timeZonesToFilter + ':' + (typeof timeZonesToFilter === 'undefined' ? 'undefined' : _typeof(timeZonesToFilter)));
                return timeZones;
            }

            if (!timeZonesToFilter.length) {
                return timeZones;
            }

            var contains = function contains(filters) {
                return function (timeZone) {
                    return _.any(filters, function (filter) {
                        return timeZone.indexOf(filter) !== -1;
                    });
                };
            };
            if (exclude) {
                return _.reject(timeZones, contains(timeZonesToFilter));
            } else {
                return _.filter(timeZones, contains(timeZonesToFilter));
            }
        }

        function ensureExists(options) {
            return Object.assign({}, options, {
                timeZones: addMissingTimeZone(options.timeZones, options.timeZone)
            });
        }

        function addMissingTimeZone(timeZones, timeZone) {
            var mappedTimeZone = getEqualInList(timeZone, timeZones);
            var allTimeZones = [].concat(_toConsumableArray(timeZones));
            if (!allTimeZones.find(function (tz) {
                return (tz.value || tz) === mappedTimeZone;
            })) {
                allTimeZones.push(mappedTimeZone);
            }
            return allTimeZones;
        }

        function mapModel(options) {
            var mapTimeZone = function mapTimeZone(timeZone, index) {
                return timeZone.value ? timeZone : mapTimeZoneItem(options, timeZone, index);
            };
            return Object.assign({}, options, {
                timeZones: _.map(options.timeZones, mapTimeZone)
            });
        }

        function mapTimeZoneItem(options, timeZoneKey, index) {
            var city = timeZoneKey.match(/[^/]*$/)[0].replace(/-/g, '_');
            var momentTz = moment.tz(timeZoneKey);
            return {
                id: index,
                display: formatDisplayValue(options, city, momentTz),
                value: timeZoneKey,
                order: [parseInt(momentTz.format('Z')), momentTz.format('zz'), city]
            };
        }

        function formatDisplayValue(options, city, momentTz) {

            var format = angular.copy(options.displayFormat);

            var formatMap = {
                'tz-code': $translate.instant('I18N.TIMEZONE_LOCATIONS.CODES.' + momentTz.format('zz')),
                'offset-hours': momentTz.format('Z'),
                'location': $translate.instant('I18N.TIMEZONE_LOCATIONS.' + (options.useCustomList ? 'CUSTOM' : 'MOMENT') + '.' + city.toUpperCase())
            };

            if (!format) return '(GMT' + formatMap['offset-hours'] + ') ' + formatMap.location;
            for (var formatKey in formatMap) {
                format = format.replace(formatKey, formatMap[formatKey]);
            }

            return format;
        }

        function removeDuplicates(options) {
            return Object.assign({}, options, {
                timeZones: _.uniq(options.timeZones, function (timeZone) {
                    return timeZone.display;
                })
            });
        }

        function order(options) {
            return Object.assign({}, options, {
                timeZones: orderByFilter(options.timeZones, ['order[0]', 'order[1]', 'order[2]'], false)
            });
        }

        function getKeyInCustomList(timeZone) {
            var useCustomList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

            var selectedTimeZone = void 0;

            if (!useCustomList) return timeZone;
            if (bbCustomTimeZones.GROUPED_TIME_ZONES[timeZone]) return timeZone;

            var city = timeZone.match(/[^/]*$/)[0].replace(/ /g, "_");

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = Object.entries(bbCustomTimeZones.GROUPED_TIME_ZONES)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var _step$value = _slicedToArray(_step.value, 2),
                        groupName = _step$value[0],
                        groupCities = _step$value[1];

                    if (groupName.match(/[^/]*$/)[0] === city) {
                        selectedTimeZone = groupName;
                        break;
                    }

                    groupCities = groupCities.split(/\s*,\s*/).map(function (tz) {
                        return tz.replace(/ /g, "_");
                    }).join(', ').split(/\s*,\s*/);
                    var cityGroupIndex = groupCities.findIndex(function (groupCity) {
                        return groupCity === city;
                    });
                    if (cityGroupIndex !== -1) {
                        selectedTimeZone = groupName;
                        break;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return selectedTimeZone || timeZone;
        }

        function getEqualInList(timeZone, timeZones) {
            var selectedTimeZone = void 0;

            var overwrite = bbi18nOptions.timeZone.replaceBrowser;
            if (overwrite.replace && overwrite.replaceWith) {
                if (overwrite.replace === timeZone) {
                    selectedTimeZone = overwrite.replaceWith;
                    return selectedTimeZone;
                }
            }

            var formatTz = function formatTz(timeZone, format) {
                return moment.tz(timeZone).format(format);
            };
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = timeZones[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var tz = _step2.value;

                    if (formatTz(tz.value || tz, 'zz') === formatTz(timeZone, 'zz') && formatTz(tz.value || tz, 'ZZ') === formatTz(timeZone, 'ZZ')) {
                        selectedTimeZone = tz.value || tz;
                        break;
                    }
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            return selectedTimeZone || timeZone;
        }
    }
})();
'use strict';

/**
 * @ngdoc service
 * @name BB.i18n.RuntimeTranslate
 *
 * @description
 * Returns an instance of $translateProvider that allows late language binding (on runtime)
 */

/**
 * @ngdoc service
 * @name BB.i18n.RuntimeTranslateProvider
 *
 * @description
 * Provider
 *
 * @example
 <pre>
 angular.module('ExampleModule').config ['RuntimeTranslateProvider', '$translateProvider', (RuntimeTranslateProvider, $translateProvider) ->
 RuntimeTranslateProvider.setProvider($translateProvider)
 ]
 </pre>
 */
angular.module('BB.i18n').provider('RuntimeTranslate', function ($translateProvider) {
  'ngInject';

  var translateProvider = $translateProvider;
  this.setProvider = function (provider) {
    return translateProvider = provider;
  };
  this.$get = function () {
    return translateProvider;
  };
});
'use strict';

angular.module('BB.i18n').config(function ($translateProvider) {
    'ngInject';

    var translations = {
        I18N: {
            LANGUAGE_PICKER: {
                SELECT_LANG_PLACEHOLDER: 'Select...'
            },
            TIMEZONE: {
                PREFERENCES: 'Preferences',
                TIMEZONE_INFO: 'All times are shown in {{time_zone_name}}.',
                SET_TIMEZONE_AUTOMATICALLY_LABEL: 'Set timezone automatically',
                SET_TIMEZONE_AUTOMATICALLY_ON_LABEL: 'On',
                SET_TIMEZONE_AUTOMATICALLY_OFF_LABEL: 'Off',
                TIMEZONE_LABEL: 'Timezone',
                SELECT_TIMEZONE_PLACEHOLDER: 'Select timezone'
            },
            TIMEZONE_LOCATIONS: {
                CODES: {
                    '+00': '+00',
                    '+01': '+01',
                    '+02': '+02',
                    '+03': '+03',
                    '+04': '+04',
                    '+05': '+05',
                    '+0530': '+0530',
                    '+06': '+06',
                    '+07': '+07',
                    '+08': '+08',
                    '+09': '+09',
                    '+10': '+10',
                    '+11': '+11',
                    '+12': '+12',
                    '+13': '+13',
                    '+14': '+14',
                    '-01': '-01',
                    '-02': '-02',
                    '-03': '-03',
                    '-04': '-04',
                    '-05': '-05',
                    '-06': '-06',
                    '-07': '-07',
                    '-08': '-08',
                    '-09': '-09',
                    '-10': '-10',
                    '-11': '-11',
                    '-12': '-12',
                    ACDT: 'ACDT',
                    ACST: 'ACST',
                    ACT: 'ACT',
                    ACWST: 'ACWST',
                    ADT: 'ADT',
                    AEDT: 'AEDT',
                    AEST: 'AEST',
                    AFT: 'AFT',
                    AKDT: 'AKDT',
                    AKST: 'AKST',
                    AMST: 'AMST',
                    AMT: 'AMT',
                    ART: 'ART',
                    AST: 'AST',
                    AWST: 'AWST',
                    AZOST: 'AZOST',
                    AZOT: 'AZOT',
                    BDT: 'BDT',
                    BNT: 'BNT',
                    BOT: 'BOT',
                    BRST: 'BRST',
                    BRT: 'BRT',
                    BST: 'BST',
                    BTT: 'BTT',
                    CAT: 'CAT',
                    CCT: 'CCT',
                    CDT: 'CDT',
                    CEST: 'CEST',
                    CET: 'CET',
                    CHADT: 'CHADT',
                    CHAST: 'CHAST',
                    CHOST: 'CHOST',
                    CHOT: 'CHOT',
                    CHUT: 'CHUT',
                    CKT: 'CKT',
                    CLST: 'CLST',
                    COT: 'COT',
                    CST: 'CST',
                    CVT: 'CVT',
                    CXT: 'CXT',
                    'ChST': 'ChST',
                    EASST: 'EASST',
                    EAT: 'EAT',
                    ECT: 'ECT',
                    EDT: 'EDT',
                    EEST: 'EEST',
                    EET: 'EET',
                    EGST: 'EGST',
                    EGT: 'EGT',
                    EST: 'EST',
                    FJST: 'FJST',
                    FJT: 'FJT',
                    FKST: 'FKST',
                    FNT: 'FNT',
                    GALT: 'GALT',
                    GAMT: 'GAMT',
                    GFT: 'GFT',
                    GILT: 'GILT',
                    GMT: 'GMT',
                    GST: 'GST',
                    GYT: 'GYT',
                    HDT: 'HDT',
                    HKT: 'HKT',
                    HOVST: 'HOVST',
                    HOVT: 'HOVT',
                    HST: 'HST',
                    ICT: 'ICT',
                    IDT: 'IDT',
                    IOT: 'IOT',
                    IRDT: 'IRDT',
                    IRST: 'IRST',
                    IST: 'IST',
                    JST: 'JST',
                    KOST: 'KOST',
                    KST: 'KST',
                    LHDT: 'LHDT',
                    LHST: 'LHST',
                    LINT: 'LINT',
                    MART: 'MART',
                    MDT: 'MDT',
                    MEST: 'MEST',
                    MET: 'MET',
                    MHT: 'MHT',
                    MIST: 'MIST',
                    MMT: 'MMT',
                    MSK: 'MSK',
                    MST: 'MST',
                    MUT: 'MUT',
                    MVT: 'MVT',
                    MYT: 'MYT',
                    NCT: 'NCT',
                    NDT: 'NDT',
                    NFT: 'NFT',
                    NPT: 'NPT',
                    NRT: 'NRT',
                    NST: 'NST',
                    NUT: 'NUT',
                    NZDT: 'NZDT',
                    NZST: 'NZST',
                    PDT: 'PDT',
                    PET: 'PET',
                    PGT: 'PGT',
                    PHOT: 'PHOT',
                    PHT: 'PHT',
                    PKT: 'PKT',
                    PMDT: 'PMDT',
                    PMST: 'PMST',
                    PONT: 'PONT',
                    PST: 'PST',
                    PWT: 'PWT',
                    PYST: 'PYST',
                    PYT: 'PYT',
                    RET: 'RET',
                    SAST: 'SAST',
                    SBT: 'SBT',
                    SCT: 'SCT',
                    SGT: 'SGT',
                    SRT: 'SRT',
                    SST: 'SST',
                    TAHT: 'TAHT',
                    TKT: 'TKT',
                    TLT: 'TLT',
                    TVT: 'TVT',
                    UCT: 'UCT',
                    ULAST: 'ULAST',
                    ULAT: 'ULAT',
                    UTC: 'UTC',
                    UYT: 'UYT',
                    VET: 'VET',
                    VUT: 'VUT',
                    WAKT: 'WAKT',
                    WAST: 'WAST',
                    WAT: 'WAT',
                    WEST: 'WEST',
                    WET: 'WET',
                    WFT: 'WFT',
                    WGST: 'WGST',
                    WGT: 'WGT',
                    WIB: 'WIB',
                    WIT: 'WIT',
                    WITA: 'WITA',
                    WSDT: 'WSDT',
                    WSST: 'WSST',
                    XJT: 'XJT'
                },
                CUSTOM: {
                    ADELAIDE: 'Adelaide',
                    ALASKA: 'Alaska',
                    ALMATY: 'Almaty, Novosibirsk',
                    AMSTERDAM: 'Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna',
                    ATHENS: 'Athens, Minsk',
                    AUCKLAND: 'Auckland, Wellington',
                    AZORES: 'Azores',
                    BAGHDAD: 'Baghdad',
                    BANGKOK: 'Bangkok, Hanoi, Jakarta',
                    BELGRADE: 'Belgrade, Bratislava, Budapest, Ljubljana, Prague',
                    BOGOTA: 'Bogota, Lima, Quito',
                    BRISBANE: 'Brisbane',
                    BUCHAREST: 'Bucharest',
                    BUENOS_AIRES: 'Buenos Aires, Georgetown',
                    CAIRO: 'Cairo',
                    CANBERRA: 'Canberra, Melbourne, Sydney',
                    CAPE_VERDE: 'Cape Verde Islands',
                    CARACAS: 'Caracas, La Paz',
                    CASABLANCA: 'Casablanca, Monrovia',
                    CHICAGO: 'Central Time (US and Canada)',
                    CHIHUAHUA: 'Chihuahua, La Paz, Mazatlan',
                    COLOMBO: 'Sri Jayawardenepura',
                    DARWIN: 'Darwin',
                    DENVER: 'Mountain Time (US and Canada)',
                    DHAKA: 'Astana, Dhaka',
                    DUBAI: 'Abu Dhabi, Muscat',
                    EL_SALVADOR: 'Central America',
                    FIJI: 'Fiji Islands, Kamchatka, Marshall Islands',
                    'GMT+12': 'International Date Line West',
                    GUAM: 'Guam, Port Moresby',
                    HALIFAX: 'Atlantic Time (Canada)',
                    HARARE: 'Harare, Pretoria',
                    HELSINKI: 'Helsinki, Kiev, Riga, Sofia, Tallinn, Vilnius',
                    HONG_KONG: 'Beijing, Chongqing, Hong Kong SAR, Urumqi',
                    HONOLULU: 'Hawaii',
                    IRKUTSK: 'Irkutsk, Ulaanbaatar',
                    ISTANBUL: 'Istanbul',
                    JERUSALEM: 'Jerusalem',
                    KABUL: 'Kabul',
                    KARACHI: 'Islamabad, Karachi, Tashkent',
                    KATHMANDU: 'Kathmandu',
                    KNOX: 'Indiana (East)',
                    KOLKATA: 'Chennai, Kolkata, Mumbai, New Delhi',
                    KRASNOYARSK: 'Krasnoyarsk',
                    KUWAIT: 'Kuwait, Riyadh',
                    LAGOS: 'West Central Africa',
                    LONDON: 'Dublin, Edinburgh, Lisbon, London',
                    LOS_ANGELES: 'Pacific Time (US and Canada), Tijuana',
                    MAGADAN: 'Magadan, Solomon Islands, New Caledonia',
                    MEXICO_CITY: 'Guadalajara, Mexico City, Monterrey',
                    MOSCOW: 'Moscow, St. Petersburg, Volgograd',
                    NAIROBI: 'Nairobi',
                    NEWFOUNDLAND: 'Newfoundland and Labrador',
                    NEW_YORK: 'Eastern Time (US and Canada)',
                    PAGO_PAGO: 'Midway Island, Samoa',
                    PARIS: 'Brussels, Copenhagen, Madrid, Paris',
                    PERTH: 'Perth',
                    PHOENIX: 'Arizona',
                    RANGOON: 'Yangon Rangoon',
                    SANTIAGO: 'Santiago',
                    SAO_PAULO: 'Brasilia',
                    SARAJEVO: 'Sarajevo, Skopje, Warsaw, Zagreb',
                    SASKATCHEWAN: 'Saskatchewan',
                    SEOUL: 'Seoul',
                    SINGAPORE: 'Kuala Lumpur, Singapore',
                    TAIPEI: 'Taipei',
                    TASMANIA: 'Hobart',
                    TEHRAN: 'Tehran',
                    THULE: 'Greenland',
                    TOKYO: 'Osaka, Sapporo, Tokyo',
                    TONGATAPU: 'Nuku\'alofa',
                    VLADIVOSTOK: 'Vladivostok',
                    YAKUTSK: 'Yakutsk',
                    YEKATERINBURG: 'Ekaterinburg',
                    YEREVAN: 'Baku, Tbilisi, Yerevan'
                },
                MOMENT: {
                    ABIDJAN: 'Abidjan',
                    ACCRA: 'Accra',
                    ACRE: 'Acre',
                    ADAK: 'Adak',
                    ADDIS_ABABA: 'Addis Ababa',
                    ADELAIDE: 'Adelaide',
                    ADEN: 'Aden',
                    ALASKA: 'Alaska',
                    ALEUTIAN: 'Aleutian',
                    ALGIERS: 'Algiers',
                    ALMATY: 'Almaty',
                    AMMAN: 'Amman',
                    AMSTERDAM: 'Amsterdam',
                    ANADYR: 'Anadyr',
                    ANCHORAGE: 'Anchorage',
                    ANDORRA: 'Andorra',
                    ANGUILLA: 'Anguilla',
                    ANTANANARIVO: 'Antananarivo',
                    ANTIGUA: 'Antigua',
                    APIA: 'Apia',
                    AQTAU: 'Aqtau',
                    AQTOBE: 'Aqtobe',
                    ARAGUAINA: 'Araguaina',
                    ARIZONA: 'Arizona',
                    ARUBA: 'Aruba',
                    ASHGABAT: 'Ashgabat',
                    ASHKHABAD: 'Ashkhabad',
                    ASMARA: 'Asmara',
                    ASMERA: 'Asmera',
                    ASTRAKHAN: 'Astrakhan',
                    ASUNCION: 'Asuncion',
                    ATHENS: 'Athens',
                    ATIKOKAN: 'Atikokan',
                    ATKA: 'Atka',
                    ATLANTIC: 'Atlantic',
                    ATYRAU: 'Atyrau',
                    AUCKLAND: 'Auckland',
                    AZORES: 'Azores',
                    BAGHDAD: 'Baghdad',
                    BAHIA: 'Bahia',
                    BAHIA_BANDERAS: 'Bahia Banderas',
                    BAHRAIN: 'Bahrain',
                    BAJANORTE: 'BajaNorte',
                    BAJASUR: 'BajaSur',
                    BAKU: 'Baku',
                    BAMAKO: 'Bamako',
                    BANGKOK: 'Bangkok',
                    BANGUI: 'Bangui',
                    BANJUL: 'Banjul',
                    BARBADOS: 'Barbados',
                    BARNAUL: 'Barnaul',
                    BEIRUT: 'Beirut',
                    BELEM: 'Belem',
                    BELFAST: 'Belfast',
                    BELGRADE: 'Belgrade',
                    BELIZE: 'Belize',
                    BERLIN: 'Berlin',
                    BERMUDA: 'Bermuda',
                    BEULAH: 'Beulah',
                    BISHKEK: 'Bishkek',
                    BISSAU: 'Bissau',
                    BLANC_SABLON: 'Blanc-Sablon',
                    BLANTYRE: 'Blantyre',
                    BOA_VISTA: 'Boa Vista',
                    BOGOTA: 'Bogota',
                    BOISE: 'Boise',
                    BOUGAINVILLE: 'Bougainville',
                    BRATISLAVA: 'Bratislava',
                    BRAZZAVILLE: 'Brazzaville',
                    BRISBANE: 'Brisbane',
                    BROKEN_HILL: 'Broken Hill',
                    BRUNEI: 'Brunei',
                    BRUSSELS: 'Brussels',
                    BUCHAREST: 'Bucharest',
                    BUDAPEST: 'Budapest',
                    BUENOS_AIRES: 'Buenos Aires',
                    BUJUMBURA: 'Bujumbura',
                    BUSINGEN: 'Busingen',
                    CAIRO: 'Cairo',
                    CALCUTTA: 'Calcutta',
                    CAMBRIDGE_BAY: 'Cambridge Bay',
                    CAMPO_GRANDE: 'Campo Grande',
                    CANARY: 'Canary',
                    CANBERRA: 'Canberra',
                    CANCUN: 'Cancun',
                    CAPE_VERDE: 'Cape Verde',
                    CARACAS: 'Caracas',
                    CASABLANCA: 'Casablanca',
                    CASEY: 'Casey',
                    CATAMARCA: 'Catamarca',
                    CAYENNE: 'Cayenne',
                    CAYMAN: 'Cayman',
                    CENTER: 'Center',
                    CENTRAL: 'Central',
                    CEUTA: 'Ceuta',
                    CHAGOS: 'Chagos',
                    CHATHAM: 'Chatham',
                    CHICAGO: 'Chicago',
                    CHIHUAHUA: 'Chihuahua',
                    CHISINAU: 'Chisinau',
                    CHITA: 'Chita',
                    CHOIBALSAN: 'Choibalsan',
                    CHONGQING: 'Chongqing',
                    CHRISTMAS: 'Christmas',
                    CHUNGKING: 'Chungking',
                    CHUUK: 'Chuuk',
                    COCOS: 'Cocos',
                    COLOMBO: 'Colombo',
                    COMODRIVADAVIA: 'ComodRivadavia',
                    COMORO: 'Comoro',
                    CONAKRY: 'Conakry',
                    CONTINENTAL: 'Continental',
                    COPENHAGEN: 'Copenhagen',
                    CORAL_HARBOUR: 'Coral Harbour',
                    CORDOBA: 'Cordoba',
                    COSTA_RICA: 'Costa Rica',
                    CRESTON: 'Creston',
                    CUBA: 'Cuba',
                    CUIABA: 'Cuiaba',
                    CURACAO: 'Curacao',
                    CURRIE: 'Currie',
                    DACCA: 'Dacca',
                    DAKAR: 'Dakar',
                    DAMASCUS: 'Damascus',
                    DANMARKSHAVN: 'Danmarkshavn',
                    DARWIN: 'Darwin',
                    DAR_ES_SALAAM: 'Dar es Salaam',
                    DAVIS: 'Davis',
                    DAWSON: 'Dawson',
                    DAWSON_CREEK: 'Dawson Creek',
                    DENORONHA: 'DeNoronha',
                    DENVER: 'Denver',
                    DETROIT: 'Detroit',
                    DHAKA: 'Dhaka',
                    DILI: 'Dili',
                    DJIBOUTI: 'Djibouti',
                    DOMINICA: 'Dominica',
                    DOUALA: 'Douala',
                    DUBAI: 'Dubai',
                    DUBLIN: 'Dublin',
                    DUMONTDURVILLE: 'DumontDUrville',
                    DUSHANBE: 'Dushanbe',
                    EAST: 'East',
                    EASTER: 'Easter',
                    EASTERISLAND: 'EasterIsland',
                    EASTERN: 'Eastern',
                    EAST_INDIANA: 'East-Indiana',
                    EAST_SASKATCHEWAN: 'East-Saskatchewan',
                    EDMONTON: 'Edmonton',
                    EFATE: 'Efate',
                    EGYPT: 'Egypt',
                    EIRE: 'Eire',
                    EIRUNEPE: 'Eirunepe',
                    EL_AAIUN: 'El Aaiun',
                    EL_SALVADOR: 'El Salvador',
                    ENDERBURY: 'Enderbury',
                    ENSENADA: 'Ensenada',
                    EUCLA: 'Eucla',
                    FAEROE: 'Faeroe',
                    FAKAOFO: 'Fakaofo',
                    FAMAGUSTA: 'Famagusta',
                    FAROE: 'Faroe',
                    FIJI: 'Fiji',
                    FORTALEZA: 'Fortaleza',
                    FORT_NELSON: 'Fort Nelson',
                    FORT_WAYNE: 'Fort Wayne',
                    FREETOWN: 'Freetown',
                    FUNAFUTI: 'Funafuti',
                    GABORONE: 'Gaborone',
                    GALAPAGOS: 'Galapagos',
                    GAMBIER: 'Gambier',
                    GAZA: 'Gaza',
                    GB_EIRE: 'GB-Eire',
                    GENERAL: 'General',
                    GIBRALTAR: 'Gibraltar',
                    GLACE_BAY: 'Glace Bay',
                    GODTHAB: 'Godthab',
                    GOOSE_BAY: 'Goose Bay',
                    GRAND_TURK: 'Grand Turk',
                    GREENWICH: 'Greenwich',
                    GRENADA: 'Grenada',
                    GUADALCANAL: 'Guadalcanal',
                    GUADELOUPE: 'Guadeloupe',
                    GUAM: 'Guam',
                    GUATEMALA: 'Guatemala',
                    GUAYAQUIL: 'Guayaquil',
                    GUERNSEY: 'Guernsey',
                    GUYANA: 'Guyana',
                    HALIFAX: 'Halifax',
                    HARARE: 'Harare',
                    HARBIN: 'Harbin',
                    HAVANA: 'Havana',
                    HAWAII: 'Hawaii',
                    HEBRON: 'Hebron',
                    HELSINKI: 'Helsinki',
                    HERMOSILLO: 'Hermosillo',
                    HOBART: 'Hobart',
                    HONGKONG: 'Hongkong',
                    HONG_KONG: 'Hong Kong',
                    HONOLULU: 'Honolulu',
                    HOVD: 'Hovd',
                    HO_CHI_MINH: 'Ho Chi Minh',
                    ICELAND: 'Iceland',
                    INDIANAPOLIS: 'Indianapolis',
                    INDIANA_STARKE: 'Indiana-Starke',
                    INUVIK: 'Inuvik',
                    IQALUIT: 'Iqaluit',
                    IRAN: 'Iran',
                    IRKUTSK: 'Irkutsk',
                    ISLE_OF_MAN: 'Isle of Man',
                    ISRAEL: 'Israel',
                    ISTANBUL: 'Istanbul',
                    JAKARTA: 'Jakarta',
                    JAMAICA: 'Jamaica',
                    JAN_MAYEN: 'Jan Mayen',
                    JAPAN: 'Japan',
                    JAYAPURA: 'Jayapura',
                    JERSEY: 'Jersey',
                    JERUSALEM: 'Jerusalem',
                    JOHANNESBURG: 'Johannesburg',
                    JOHNSTON: 'Johnston',
                    JUBA: 'Juba',
                    JUJUY: 'Jujuy',
                    JUNEAU: 'Juneau',
                    KABUL: 'Kabul',
                    KALININGRAD: 'Kaliningrad',
                    KAMCHATKA: 'Kamchatka',
                    KAMPALA: 'Kampala',
                    KARACHI: 'Karachi',
                    KASHGAR: 'Kashgar',
                    KATHMANDU: 'Kathmandu',
                    KATMANDU: 'Katmandu',
                    KERGUELEN: 'Kerguelen',
                    KHANDYGA: 'Khandyga',
                    KHARTOUM: 'Khartoum',
                    KIEV: 'Kiev',
                    KIGALI: 'Kigali',
                    KINSHASA: 'Kinshasa',
                    KIRITIMATI: 'Kiritimati',
                    KIROV: 'Kirov',
                    KNOX: 'Knox',
                    KNOX_IN: 'Knox IN',
                    KOLKATA: 'Kolkata',
                    KOSRAE: 'Kosrae',
                    KRALENDIJK: 'Kralendijk',
                    KRASNOYARSK: 'Krasnoyarsk',
                    KUALA_LUMPUR: 'Kuala Lumpur',
                    KUCHING: 'Kuching',
                    KUWAIT: 'Kuwait',
                    KWAJALEIN: 'Kwajalein',
                    LAGOS: 'Lagos',
                    LA_PAZ: 'La Paz',
                    LA_RIOJA: 'La Rioja',
                    LIBREVILLE: 'Libreville',
                    LIBYA: 'Libya',
                    LIMA: 'Lima',
                    LINDEMAN: 'Lindeman',
                    LISBON: 'Lisbon',
                    LJUBLJANA: 'Ljubljana',
                    LOME: 'Lome',
                    LONDON: 'London',
                    LONGYEARBYEN: 'Longyearbyen',
                    LORD_HOWE: 'Lord Howe',
                    LOS_ANGELES: 'Los Angeles',
                    LOUISVILLE: 'Louisville',
                    LOWER_PRINCES: 'Lower Princes',
                    LUANDA: 'Luanda',
                    LUBUMBASHI: 'Lubumbashi',
                    LUSAKA: 'Lusaka',
                    LUXEMBOURG: 'Luxembourg',
                    MACAO: 'Macao',
                    MACAU: 'Macau',
                    MACEIO: 'Maceio',
                    MACQUARIE: 'Macquarie',
                    MADEIRA: 'Madeira',
                    MADRID: 'Madrid',
                    MAGADAN: 'Magadan',
                    MAHE: 'Mahe',
                    MAJURO: 'Majuro',
                    MAKASSAR: 'Makassar',
                    MALABO: 'Malabo',
                    MALDIVES: 'Maldives',
                    MALTA: 'Malta',
                    MANAGUA: 'Managua',
                    MANAUS: 'Manaus',
                    MANILA: 'Manila',
                    MAPUTO: 'Maputo',
                    MARENGO: 'Marengo',
                    MARIEHAMN: 'Mariehamn',
                    MARIGOT: 'Marigot',
                    MARQUESAS: 'Marquesas',
                    MARTINIQUE: 'Martinique',
                    MASERU: 'Maseru',
                    MATAMOROS: 'Matamoros',
                    MAURITIUS: 'Mauritius',
                    MAWSON: 'Mawson',
                    MAYOTTE: 'Mayotte',
                    MAZATLAN: 'Mazatlan',
                    MBABANE: 'Mbabane',
                    MCMURDO: 'McMurdo',
                    MELBOURNE: 'Melbourne',
                    MENDOZA: 'Mendoza',
                    MENOMINEE: 'Menominee',
                    MERIDA: 'Merida',
                    METLAKATLA: 'Metlakatla',
                    MEXICO_CITY: 'Mexico City',
                    MICHIGAN: 'Michigan',
                    MIDWAY: 'Midway',
                    MINSK: 'Minsk',
                    MIQUELON: 'Miquelon',
                    MOGADISHU: 'Mogadishu',
                    MONACO: 'Monaco',
                    MONCTON: 'Moncton',
                    MONROVIA: 'Monrovia',
                    MONTERREY: 'Monterrey',
                    MONTEVIDEO: 'Montevideo',
                    MONTICELLO: 'Monticello',
                    MONTREAL: 'Montreal',
                    MONTSERRAT: 'Montserrat',
                    MOSCOW: 'Moscow',
                    MOUNTAIN: 'Mountain',
                    MUSCAT: 'Muscat',
                    NAIROBI: 'Nairobi',
                    NASSAU: 'Nassau',
                    NAURU: 'Nauru',
                    NAVAJO: 'Navajo',
                    NDJAMENA: 'Ndjamena',
                    NEWFOUNDLAND: 'Newfoundland',
                    NEW_SALEM: 'New Salem',
                    NEW_YORK: 'New York',
                    NIAMEY: 'Niamey',
                    NICOSIA: 'Nicosia',
                    NIPIGON: 'Nipigon',
                    NIUE: 'Niue',
                    NOME: 'Nome',
                    NORFOLK: 'Norfolk',
                    NORONHA: 'Noronha',
                    NORTH: 'North',
                    NOUAKCHOTT: 'Nouakchott',
                    NOUMEA: 'Noumea',
                    NOVOKUZNETSK: 'Novokuznetsk',
                    NOVOSIBIRSK: 'Novosibirsk',
                    OJINAGA: 'Ojinaga',
                    OMSK: 'Omsk',
                    ORAL: 'Oral',
                    OSLO: 'Oslo',
                    OUAGADOUGOU: 'Ouagadougou',
                    PACIFIC: 'Pacific',
                    PACIFIC_NEW: 'Pacific-New',
                    PAGO_PAGO: 'Pago Pago',
                    PALAU: 'Palau',
                    PALMER: 'Palmer',
                    PANAMA: 'Panama',
                    PANGNIRTUNG: 'Pangnirtung',
                    PARAMARIBO: 'Paramaribo',
                    PARIS: 'Paris',
                    PERTH: 'Perth',
                    PETERSBURG: 'Petersburg',
                    PHNOM_PENH: 'Phnom Penh',
                    PHOENIX: 'Phoenix',
                    PITCAIRN: 'Pitcairn',
                    PODGORICA: 'Podgorica',
                    POHNPEI: 'Pohnpei',
                    POLAND: 'Poland',
                    PONAPE: 'Ponape',
                    PONTIANAK: 'Pontianak',
                    PORTO_ACRE: 'Porto Acre',
                    PORTO_NOVO: 'Porto-Novo',
                    PORTO_VELHO: 'Porto Velho',
                    PORTUGAL: 'Portugal',
                    PORT_AU_PRINCE: 'Port-au-Prince',
                    PORT_MORESBY: 'Port Moresby',
                    PORT_OF_SPAIN: 'Port of Spain',
                    PRAGUE: 'Prague',
                    PUERTO_RICO: 'Puerto Rico',
                    PUNTA_ARENAS: 'Punta Arenas',
                    PYONGYANG: 'Pyongyang',
                    QATAR: 'Qatar',
                    QUEENSLAND: 'Queensland',
                    QYZYLORDA: 'Qyzylorda',
                    RAINY_RIVER: 'Rainy River',
                    RANGOON: 'Rangoon',
                    RANKIN_INLET: 'Rankin Inlet',
                    RAROTONGA: 'Rarotonga',
                    RECIFE: 'Recife',
                    REGINA: 'Regina',
                    RESOLUTE: 'Resolute',
                    REUNION: 'Reunion',
                    REYKJAVIK: 'Reykjavik',
                    RIGA: 'Riga',
                    RIO_BRANCO: 'Rio Branco',
                    RIO_GALLEGOS: 'Rio Gallegos',
                    RIYADH: 'Riyadh',
                    ROME: 'Rome',
                    ROSARIO: 'Rosario',
                    ROTHERA: 'Rothera',
                    SAIGON: 'Saigon',
                    SAIPAN: 'Saipan',
                    SAKHALIN: 'Sakhalin',
                    SALTA: 'Salta',
                    SAMARA: 'Samara',
                    SAMARKAND: 'Samarkand',
                    SAMOA: 'Samoa',
                    SANTAREM: 'Santarem',
                    SANTA_ISABEL: 'Santa Isabel',
                    SANTIAGO: 'Santiago',
                    SANTO_DOMINGO: 'Santo Domingo',
                    SAN_JUAN: 'San Juan',
                    SAN_LUIS: 'San Luis',
                    SAN_MARINO: 'San Marino',
                    SAO_PAULO: 'Sao Paulo',
                    SAO_TOME: 'Sao Tome',
                    SARAJEVO: 'Sarajevo',
                    SARATOV: 'Saratov',
                    SASKATCHEWAN: 'Saskatchewan',
                    SCORESBYSUND: 'Scoresbysund',
                    SEOUL: 'Seoul',
                    SHANGHAI: 'Shanghai',
                    SHIPROCK: 'Shiprock',
                    SIMFEROPOL: 'Simferopol',
                    SINGAPORE: 'Singapore',
                    SITKA: 'Sitka',
                    SKOPJE: 'Skopje',
                    SOFIA: 'Sofia',
                    SOUTH: 'South',
                    SOUTH_GEORGIA: 'South Georgia',
                    SOUTH_POLE: 'South Pole',
                    SREDNEKOLYMSK: 'Srednekolymsk',
                    STANLEY: 'Stanley',
                    STOCKHOLM: 'Stockholm',
                    ST_BARTHELEMY: 'St Barthelemy',
                    ST_HELENA: 'St Helena',
                    ST_JOHNS: 'St Johns',
                    ST_KITTS: 'St Kitts',
                    ST_LUCIA: 'St Lucia',
                    ST_THOMAS: 'St Thomas',
                    ST_VINCENT: 'St Vincent',
                    SWIFT_CURRENT: 'Swift Current',
                    SYDNEY: 'Sydney',
                    SYOWA: 'Syowa',
                    TAHITI: 'Tahiti',
                    TAIPEI: 'Taipei',
                    TALLINN: 'Tallinn',
                    TARAWA: 'Tarawa',
                    TASHKENT: 'Tashkent',
                    TASMANIA: 'Tasmania',
                    TBILISI: 'Tbilisi',
                    TEGUCIGALPA: 'Tegucigalpa',
                    TEHRAN: 'Tehran',
                    TELL_CITY: 'Tell City',
                    TEL_AVIV: 'Tel Aviv',
                    THIMBU: 'Thimbu',
                    THIMPHU: 'Thimphu',
                    THULE: 'Thule',
                    THUNDER_BAY: 'Thunder Bay',
                    TIJUANA: 'Tijuana',
                    TIMBUKTU: 'Timbuktu',
                    TIRANE: 'Tirane',
                    TIRASPOL: 'Tiraspol',
                    TOKYO: 'Tokyo',
                    TOMSK: 'Tomsk',
                    TONGATAPU: 'Tongatapu',
                    TORONTO: 'Toronto',
                    TORTOLA: 'Tortola',
                    TRIPOLI: 'Tripoli',
                    TROLL: 'Troll',
                    TRUK: 'Truk',
                    TUCUMAN: 'Tucuman',
                    TUNIS: 'Tunis',
                    TURKEY: 'Turkey',
                    UJUNG_PANDANG: 'Ujung Pandang',
                    ULAANBAATAR: 'Ulaanbaatar',
                    ULAN_BATOR: 'Ulan Bator',
                    ULYANOVSK: 'Ulyanovsk',
                    UNIVERSAL: 'Universal',
                    URUMQI: 'Urumqi',
                    USHUAIA: 'Ushuaia',
                    UST_NERA: 'Ust-Nera',
                    UZHGOROD: 'Uzhgorod',
                    VADUZ: 'Vaduz',
                    VANCOUVER: 'Vancouver',
                    VATICAN: 'Vatican',
                    VEVAY: 'Vevay',
                    VICTORIA: 'Victoria',
                    VIENNA: 'Vienna',
                    VIENTIANE: 'Vientiane',
                    VILNIUS: 'Vilnius',
                    VINCENNES: 'Vincennes',
                    VIRGIN: 'Virgin',
                    VLADIVOSTOK: 'Vladivostok',
                    VOLGOGRAD: 'Volgograd',
                    VOSTOK: 'Vostok',
                    WAKE: 'Wake',
                    WALLIS: 'Wallis',
                    WARSAW: 'Warsaw',
                    WEST: 'West',
                    WHITEHORSE: 'Whitehorse',
                    WINAMAC: 'Winamac',
                    WINDHOEK: 'Windhoek',
                    WINNIPEG: 'Winnipeg',
                    YAKUTAT: 'Yakutat',
                    YAKUTSK: 'Yakutsk',
                    YANCOWINNA: 'Yancowinna',
                    YANGON: 'Yangon',
                    YAP: 'Yap',
                    YEKATERINBURG: 'Yekaterinburg',
                    YELLOWKNIFE: 'Yellowknife',
                    YEREVAN: 'Yerevan',
                    YUKON: 'Yukon',
                    ZAGREB: 'Zagreb',
                    ZAPOROZHYE: 'Zaporozhye',
                    ZULU: 'Zulu',
                    ZURICH: 'Zurich'
                }
            }
        }
    };

    $translateProvider.translations('en', translations);
});
'use strict';

(function () {
    'use strict';

    angular.module('BB.Directives').directive('appVersion', function (version) {
        return function (scope, elm, attrs) {
            elm.text(version);
        };
    });
})();
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives.directive:autofocus
 * @scope
 * @restrict A
 *
 * @description
 * Enables the HTML5 autofocus property to work with dynamically loaded content
 *
 * Usage:
 * <input type="text" autofocus="isTrue">
 *
 */
angular.module('BB.Directives').directive('autofocus', function ($timeout) {
    return {
        restrict: 'A',
        link: function link(scope, element, attr) {
            return $timeout(function () {
                if (attr.autofocus === '' || scope.$eval(attr.autofocus)) {
                    return element[0].focus();
                }
            });
        }
    };
});
'use strict';

// This is a customisation of the accordion-group directive in ui bootstrap
// v0.12.0 to fix an issue in ie8. Replace has been changed from true to false

angular.module('BB.Directives')

// The accordion-group directive indicates a block of html that will expand and collapse in an accordion
.directive('bbAccordionGroup', function () {
    return {
        require: '^accordion', // We need this directive to be inside an accordion
        restrict: 'EA',
        transclude: true, // It transcludes the contents of the directive into the template
        replace: false, // The element containing the directive will be replaced with the template
        templateUrl: 'accordion-group.html',
        scope: {
            heading: '@', // Interpolate the heading attribute onto this scope
            isOpen: '=?',
            isDisabled: '=?'
        },
        controller: function controller() {
            this.setHeading = function (element) {
                this.heading = element;
            };
        },
        link: function link(scope, element, attrs, accordionCtrl) {
            accordionCtrl.addGroup(scope);

            scope.$watch('isOpen', function (value) {
                if (value) {
                    accordionCtrl.closeOthers(scope);
                }
            });

            scope.toggleOpen = function () {
                if (!scope.isDisabled) {
                    scope.isOpen = !scope.isOpen;
                }
            };
        }
    };
})

// Use accordion-heading below an accordion-group to provide a heading containing HTML
// <accordion-group>
//   <accordion-heading>Heading containing HTML - <img src="..."></accordion-heading>
// </accordion-group>
.directive('bbAccordionHeading', function () {
    return {
        restrict: 'EA',
        transclude: true, // Grab the contents to be used as the heading
        template: '', // In effect remove this element!
        replace: true,
        require: '^bbAccordionGroup',
        link: function link(scope, element, attr, accordionGroupCtrl, transclude) {
            // Pass the heading to the accordion-group controller
            // so that it can be transcluded into the right place in the template
            // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
            accordionGroupCtrl.setHeading(transclude(scope, function () {}));
        }
    };
})

// Use in the accordion-group template to indicate where you want the heading to be transcluded
// You must provide the property on the accordion-group controller that will hold the transcluded element
// <div class="accordion-group">
//   <div class="accordion-heading" ><a ... accordion-transclude="heading">...</a></div>
//   ...
// </div>
.directive('bbAccordionTransclude', function () {
    return {
        require: '^bbAccordionGroup',
        link: function link(scope, element, attr, controller) {
            scope.$watch(function () {
                return controller[attr.bbAccordionTransclude];
            }, function (heading) {
                if (heading) {
                    element.html('');
                    element.append(heading);
                }
            });
        }
    };
});
'use strict';

(function () {

    angular.module('BB.Controllers').controller('AccordionRangeGroup', accordionRangeGroupController);

    function accordionRangeGroupController($scope, $rootScope, DateTimeUtilitiesService, $translate, CompanyStoreService, bbTimeZone) {
        'ngInject';

        $scope.$watch('slots', function () {
            return setData();
        });

        $rootScope.connection_started.then(function () {
            return $scope.init();
        });

        /***
         * @ngdoc method
         * @name init
         * @methodOf BB.Directives:bbAccordionRangeGroup
         * @description
         * Initialization of start time, end time and options
         *
         * @param {date} start_time The start time of the range group
         * @param {date} end_time The end time of the range group
         * @param {object} options The options of the range group
         */
        $scope.init = function () {

            $scope.start_time = $scope.options.range[0];
            $scope.end_time = $scope.options.range[1];

            $scope.options.collapse_when_time_selected = _.isBoolean($scope.options.collapse_when_time_selected) ? $scope.options.collapse_when_time_selected : true;
            $scope.options.hide_availability_summary = _.isBoolean($scope.options.hide_availability_summary) ? $scope.options.hide_availability_summary : false;

            $scope.heading = $translate.instant($scope.options.heading);

            return setData();
        };

        /***
         * @ngdoc method
         * @name setData
         * @methodOf BB.Directives:bbAccordionRangeGroup
         * @description
         * Set this data as ready
         */
        var setData = function setData() {

            $scope.accordion_slots = [];
            $scope.is_open = $scope.is_open || false;
            $scope.has_availability = $scope.has_availability || false;
            $scope.is_selected = $scope.is_selected || false;

            if ($scope.slots) {

                angular.forEach($scope.slots, function (slot) {

                    // use display time zone to ensure slots get added to the correct range group
                    var slot_time = void 0;
                    var displayTimeZone = bbTimeZone.getDisplay();
                    if (displayTimeZone != null && displayTimeZone !== CompanyStoreService.time_zone) {
                        var datetime = moment(slot.datetime).tz(displayTimeZone);
                        slot_time = DateTimeUtilitiesService.convertMomentToTime(datetime);
                    } else {
                        slot_time = slot.time;
                    }

                    if (slot_time >= $scope.start_time && slot_time < $scope.end_time && slot.avail === 1) {
                        return $scope.accordion_slots.push(slot);
                    }
                });

                return updateAvailability();
            }
        };

        /***
         * @ngdoc method
         * @name updateAvailability
         * @methodOf BB.Directives:bbAccordionRangeGroup
         * @description
         * Update availability of the slot
         *
         * @param {date} day The day of range group
         * @param {string} slot The slot of range group
         */
        var updateAvailability = function updateAvailability(day, slot) {

            $scope.selected_slot = null;
            if ($scope.accordion_slots) {
                $scope.has_availability = hasAvailability();
            }

            if ($scope.disabled_slot && $scope.disabled_slot.time) {
                if ($scope.disabled_slot.date === $scope.day.date.toISODate()) {
                    var relevent_slot = void 0;
                    if (Array.isArray($scope.disabled_slot.time)) {
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = Array.from($scope.disabled_slot.time)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var times = _step.value;

                                times;
                                relevent_slot = _.findWhere($scope.slots, { time: times });
                                if (relevent_slot) {
                                    relevent_slot.disabled = true;
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return) {
                                    _iterator.return();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                    } else {
                        relevent_slot = _.findWhere($scope.slots, { time: $scope.disabled_slot.time });
                        if (relevent_slot) {
                            relevent_slot.disabled = true;
                        }
                    }
                }
            }

            // if a day and slot has been provided, check if the slot is in range and mark it as selected
            if (day && slot) {

                // use display time zone to ensure slots get added to the right range group
                var slot_time = void 0;
                var displayTimeZone = bbTimeZone.getDisplay();
                if (displayTimeZone != null && displayTimeZone !== CompanyStoreService.time_zone) {
                    var datetime = moment(slot.datetime).tz(displayTimeZone);
                    slot_time = DateTimeUtilitiesService.convertMomentToTime(datetime);
                } else {
                    slot_time = slot.time;
                }

                if (day.date.isSame($scope.day.date, 'day') && slot_time >= $scope.start_time && slot_time < $scope.end_time) {
                    $scope.selected_slot = slot;
                }
            } else {
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {

                    for (var _iterator2 = Array.from($scope.accordion_slots)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        slot = _step2.value;

                        if (slot.selected) {
                            $scope.selected_slot = slot;
                            break;
                        }
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }
            }

            if ($scope.selected_slot) {
                $scope.hideHeading = true;
                $scope.is_selected = true;
                if ($scope.options.collapse_when_time_selected) {
                    return $scope.is_open = false;
                }
            } else {
                $scope.is_selected = false;
                if ($scope.options.collapse_when_time_selected) {
                    return $scope.is_open = false;
                }
            }
        };

        /***
         * @ngdoc method
         * @name hasAvailability
         * @methodOf BB.Directives:bbAccordionRangeGroup
         * @description
         * Verify if availability of accordion slots have a slot
         */
        var hasAvailability = function hasAvailability() {
            if (!$scope.accordion_slots) {
                return false;
            }
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = Array.from($scope.accordion_slots)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var slot = _step3.value;

                    if (slot.availability() > 0) {
                        return true;
                    }
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }

            return false;
        };

        return $scope.$on('slotChanged', function (event, day, slot) {
            if (day && slot) {
                return updateAvailability(day, slot);
            } else {
                return updateAvailability();
            }
        });
    }
})();
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbAccordionRangeGroup
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Use to group TimeSlot's by specified range for use with AngularUI Bootstrap accordion control
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @param {hash} bbAccordionRangeGroup  A hash of options
 * @property {boolean} collapse_when_time_selected Collapse when time is selected
 * @property {string} setRange Set time range for start and end
 * @property {string} start_time The start time
 * @property {string} end_time The end time
 * @property {array} accordion_slots The accordion slots
 * @property {boolean} is_open Time is open
 * @property {boolean} has_availability Group has have availability
 * @property {boolean} is_selected Group is selected
 * @property {string} source_slots Source of slots
 * @property {boolean} selected_slot Range group selected slot
 * @property {boolean} hideHeading Range group hide heading
 */ //


angular.module('BB.Directives').directive('bbAccordionRangeGroup', function (PathSvc) {
    return {
        restrict: 'AE',
        replace: false,
        scope: {
            day: '=',
            slots: '=',
            selectSlot: '=',
            disabled_slot: "=disabledSlot"
        },
        controller: 'AccordionRangeGroup',
        link: function link(scope, element, attrs) {
            addFocusOnlyOnPressingTabFunctionality(scope, element);
            return scope.options = scope.$eval(attrs.bbAccordionRangeGroup) || {};
        },
        templateUrl: function templateUrl(element, attrs) {
            return PathSvc.directivePartial("_accordion_range_group");
        }
    };

    /***
     * @ngdoc function
     * @name addFocusOnlyOnPressingTabFunctionality
     *
     * @description
     * Adds listeners to accordion group detecting if mouse was clicked. It adds special tab-focused class to
     * element only if focus what obtained in another way.
     */
    function addFocusOnlyOnPressingTabFunctionality(scope, element) {
        var wasElementClicked = false;

        element.mousedown(function () {
            return wasElementClicked = true;
        });
        element.mouseup(function () {
            return wasElementClicked = false;
        });

        element.focusin(function (event) {
            if (!wasElementClicked && event.target.localName !== 'li') {
                // 1. Mark as focused only in case the element wasn't clicked before.
                // 2. Do not focus element when event was meant to be delivered to its child element.
                element.find('div.panel-heading[role="tab"]').addClass('tab-focused');
            }
        });

        element.focusout(function () {
            element.find('div.panel-heading[role="tab"]').removeClass('tab-focused');
        });

        // Clearing DOM from redundant binding.
        scope.$on('$destroy', function () {
            return element.off();
        });
    }
});
'use strict';

angular.module('BB.Controllers').controller('AddressList', function ($scope, $rootScope, $filter, $sniffer, FormDataStoreService, LoadingService, BBModel) {

    $scope.manual_postcode_entry = false;
    var loader = LoadingService.$loader($scope);

    FormDataStoreService.init('AddressList', $scope, ['show_complete_address']);

    $rootScope.connection_started.then(function () {
        if ($scope.client.postcode && !$scope.bb.postcode) {
            $scope.bb.postcode = $scope.client.postcode;
        }

        // if client postcode is set and matches postcode entered by the user (and address isn't already set), copy the address from the client
        if ($scope.client.postcode && $scope.bb.postcode && $scope.client.postcode === $scope.bb.postcode && !$scope.bb.address1) {
            $scope.bb.address1 = $scope.client.address1;
            $scope.bb.address2 = $scope.client.address2;
            $scope.bb.address3 = $scope.client.address3;
            $scope.bb.address4 = $scope.client.address4;
            $scope.bb.address5 = $scope.client.address5;
        }

        $scope.manual_postcode_entry = !$scope.bb.postcode ? true : false;
        $scope.show_complete_address = $scope.bb.address1 ? true : false;
        if (!$scope.postcode_submitted) {
            $scope.findByPostcode();
            return $scope.postcode_submitted = false;
        }
    }, function (err) {
        return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
    });

    /***
     * @ngdoc method
     * @name findByPostcode
     * @methodOf BB.Directives:bbAddresses
     * @description
     * Make a request for a list of addresses. They come as seperate list of objects containing addresses and monikers, which are converted into a single list of objects containing both properties.
     */
    // make a request for a list of addresses. They come as seperate list of
    // objects containing addresses and monikers, which are converted into a single
    // list of objects containing both properties.
    $scope.findByPostcode = function () {
        $scope.postcode_submitted = true;
        if (!$scope.bb.postcode) {
            return;
        }

        loader.notLoaded();
        return BBModel.Address.$query({
            company: $scope.bb.company,
            post_code: $scope.bb.postcode
        }).then(function (response) {
            // create an array of addresses
            var addressArr = void 0;
            if (angular.isArray(response)) {
                addressArr = _.map(response, function (item, i) {
                    return {
                        address: item.partialAddress,
                        moniker: item.moniker
                    };
                });
            } else {
                addressArr = [{
                    address: response.partialAddress,
                    moniker: response.moniker
                }];
            }

            //  there is a bug in IE where it can't display a single option if the
            //  select menu is set to display more than one i.e. <select size="3">, so
            //  we add a blank
            if (addressArr.length === 1 && $sniffer.msie) {
                var newaddr = [];
                newaddr.push(addressArr[0]);
                newaddr.push({ address: '' });
                addressArr = newaddr;
            }

            $scope.addresses = addressArr;
            // set address as as first item to prevent angular adding an empty item to
            // the select control this is bound to
            $scope.bb.address = addressArr[0];
            $scope.client.address = addressArr[0];
            loader.setLoaded();
        }, function (err) {
            $scope.show_complete_address = true;
            $scope.postcode_submitted = true;
            return loader.setLoaded();
        });
    };

    /***
     * @ngdoc method
     * @name showCompleteAddress
     * @methodOf BB.Directives:bbAddresses
     * @description
     * Show complete address
     */
    $scope.showCompleteAddress = function () {
        $scope.show_complete_address = true;
        $scope.postcode_submitted = false;

        if ($scope.bb.address && $scope.bb.address.moniker) {
            loader.notLoaded();
            return BBModel.Address.$getAddress({
                company: $scope.bb.company,
                id: $scope.bb.address.moniker
            }).then(function (response) {
                var address2 = void 0,
                    address3 = void 0,
                    addressLine2 = void 0,
                    streetName = void 0;
                var address = response;
                var house_number = '';
                if (typeof address.buildingNumber === 'string') {
                    house_number = address.buildingNumber;
                } else if (address.buildingNumber == null) {
                    house_number = address.buildingName;
                }

                if (typeof address.streetName === 'string') {
                    streetName = address.streetName ? address.streetName : '';
                    $scope.bb.address1 = house_number + ' ' + streetName;
                } else {
                    addressLine2 = address.addressLine2 ? address.addressLine2 : '';
                    $scope.bb.address1 = house_number + ' ' + addressLine2;
                }

                if (address.buildingName && address.buildingNumber == null) {
                    $scope.bb.address1 = house_number;
                    $scope.bb.address2 = address.streetName;
                    if (address.county != null) {
                        $scope.bb.address4 = address.county;
                    }
                }

                if (typeof address.buildingNumber === 'string' && typeof address.buildingName === 'string' && typeof address.streetName === 'string') {
                    streetName = address.streetName ? address.streetName : '';
                    $scope.bb.address1 = address.buildingName;
                    $scope.bb.address2 = address.buildingNumber + " " + streetName;
                }

                if (address.buildingName != null && address.buildingName.match(/(^[^0-9]+$)/)) {
                    var building_number = address.buildingNumber ? address.buildingNumber : '';
                    $scope.bb.address1 = address.buildingName + " " + building_number;
                    $scope.bb.address2 = address.streetName;
                }

                if (address.buildingNumber == null && address.streetName == null) {
                    $scope.bb.address1 = address.buildingName;
                    $scope.bb.address2 = address.addressLine3;
                    $scope.bb.address4 = address.town;
                }

                //The below conditional logic is VERY specific to different company address layouts
                if (address.companyName != null) {
                    $scope.bb.address1 = address.companyName;

                    if (address.buildingNumber == null && address.streetName == null) {
                        $scope.bb.address2 = address.addressLine3;
                    } else if (address.buildingNumber == null) {
                        address2 = address.buildingName ? address.buildingName + ', ' + address.streetName : address.streetName;
                        $scope.bb.address2 = address2;
                    } else if (address.buildingName == null && address.addressLine2 == null) {
                        $scope.bb.address2 = address.buildingNumber + ", " + address.streetName;
                    } else {
                        $scope.bb.address2 = address.buildingName;
                    }
                    $scope.bb.address3 = address.buildingName;

                    if (address.addressLine3 && address.buildingNumber != null) {
                        address3 = address.addressLine3;
                    } else if (address.addressLine2 == null && address.buildingNumber != null) {
                        address3 = address.buildingNumber + " " + address.streetName;
                    } else if (address.addressLine2 == null && address.buildingNumber == null && address.buildingName != null) {
                        address3 = address.addressLine3;
                    } else {
                        address3 = '';
                    }
                    $scope.bb.address3 = address3;
                    $scope.bb.address4 = address.town;
                    $scope.bb.address5 = "";
                    $scope.bb.postcode = address.postCode;
                }

                if (address.buildingName == null && address.companyName == null && address.county == null) {
                    if (address.addressLine2 == null && address.companyName == null) {
                        address2 = address.addressLine3;
                    } else {
                        address2 = address.addressLine2;
                    }
                    $scope.bb.address2 = address2;
                } else if (address.buildingName == null && address.companyName == null) {
                    $scope.bb.address2 = address.addressLine3;
                }

                if (address.buildingName != null && address.streetName != null && address.companyName == null && address.addressLine3 != null) {
                    if (address.addressLine3 == null) {
                        $scope.bb.address3 = address.buildingName;
                    } else {
                        $scope.bb.address3 = address.addressLine3;
                    }
                } else if (address.buildingName == null && address.companyName == null && address.addressLine2 != null) {
                    $scope.bb.address3 = address.addressLine3;
                } else if (address.buildingName == null && address.streetName != null && address.addressLine3 == null) {
                    $scope.bb.address3 = address.addressLine3;
                }
                $scope.bb.address4 = address.town;
                if (address.county != null) {
                    $scope.bb.address5 = address.county;
                }
                loader.setLoaded();
            }, function (err) {
                $scope.show_complete_address = true;
                $scope.postcode_submitted = false;
                return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
            });
        }
    };

    /***
     * @ngdoc method
     * @name setManualPostcodeEntry
     * @methodOf BB.Directives:bbAddresses
     * @description
     * Set manual postcode entry
     *
     * @param {string} value The value of postcode
     */
    $scope.setManualPostcodeEntry = function (value) {
        return $scope.manual_postcode_entry = value;
    };

    return $scope.$on("client_details:reset_search", function (event) {
        $scope.bb.address1 = null;
        $scope.bb.address2 = null;
        $scope.bb.address3 = null;
        $scope.bb.address4 = null;
        $scope.bb.address5 = null;
        $scope.show_complete_address = false;
        $scope.postcode_submitted = false;
        return $scope.bb.address = $scope.addresses[0];
    });
});
'use strict';

//# Address List

/***
 * @ngdoc directive
 * @name BB.Directives:bbAddresses
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Loads a list of addresses for the currently in scope company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @property {boolean} manual_postcode_entry The manual postcode entry of the address
 * @property {string} address1 The first address of the client
 * @property {string} address2 The second address of the client
 * @property {string} address3 The third address of the client
 * @property {string} address4 The fourth address of the client
 * @property {string} address5 The fifth address of the client
 * @property {boolean} show_complete_address Display complete address of the client
 * @property {boolean} postcode_submitted Postcode of the client has been submitted
 * @property {string} findByPostcode Find address by postcode
 * @property {string} setLoaded Set loaded address list
 * @property {string} notLoaded Address list not loaded
 */ //

angular.module('BB.Directives').directive('bbAddresses', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'AddressList'
    };
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives.bbAttendees
 * @scope
 * @restrict AE
 *
 * @description
 * Provide a description here
 */

angular.module('BB.Directives').directive('bbAttendees', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: function controller($scope, $rootScope, $q, PurchaseService, AlertService, ValidatorService, LoadingService, BBModel) {

            var loader = LoadingService.$loader($scope);

            $rootScope.connection_started.then(function () {
                return initialise();
            });

            var initialise = function initialise() {
                return $scope.items = $scope.bb.basket.timeItems();
            };

            var updateBooking = function updateBooking() {

                var deferred = $q.defer();

                var params = {
                    purchase: $scope.bb.moving_purchase,
                    bookings: $scope.bb.basket.items,
                    notify: true
                };
                PurchaseService.update(params).then(function (purchase) {
                    $scope.bb.purchase = purchase;
                    loader.setLoaded();
                    $scope.bb.current_item.move_done = true;
                    $rootScope.$broadcast("booking:updated");
                    return deferred.resolve();
                }, function (err) {
                    return deferred.reject();
                });

                return deferred.promise;
            };

            /***
             * @ngdoc method
             * @name markItemAsChanged
             * @methodOf BB.Directives.bbAttendees
             * @description
             * Call this when an attendee is changed
             */
            $scope.markItemAsChanged = function (item) {
                return item.attendee_changed = true;
            };

            /***
             * @ngdoc method
             * @name updateBooking
             * @methodOf BB.Directives.bbAttendees
             * @description
             * Set this page section as ready - see {@link BB.Directives:bbPage Page Control}
             */
            $scope.changeAttendees = function () {

                if (!$scope.bb.current_item.ready || !$scope.bb.moving_purchase) {
                    return false;
                }

                var deferred = $q.defer();

                loader.notLoaded();

                var client_promises = [];

                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Array.from($scope.items)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var item = _step.value;


                        if (item.attendee_changed) {

                            var client = new BBModel.Client();
                            client.first_name = item.first_name;
                            client.last_name = item.last_name;

                            client_promises.push(BBModel.Client.$create_or_update($scope.bb.company, client));
                        } else {

                            client_promises.push($q.when([]));
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                $q.all(client_promises).then(function (result) {

                    for (var index = 0; index < $scope.items.length; index++) {
                        item = $scope.items[index];
                        if (result[index] && result[index].id) {
                            item.client_id = result[index].id;
                        }
                    }

                    return updateBooking().then(function () {
                        if ($scope.$parent.$has_page_control) {
                            return deferred.resolve();
                        } else {
                            $scope.decideNextPage('purchase');
                            AlertService.raise('ATTENDEES_CHANGED');
                            return deferred.resolve();
                        }
                    }, function (err) {
                        return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
                    });
                });

                return deferred.promise;
            };

            /***
             * @ngdoc method
             * @name setReady
             * @methodOf BB.Directives.bbAttendees
             * @description
             * Set this page section as ready - see {@link BB.Directives:bbPage Page Control}
             */
            return $scope.setReady = function () {
                return $scope.changeAttendees();
            };
        }
    };
});
'use strict';

angular.module('BB.Controllers').controller('Breadcrumbs', function ($scope) {
    var loadStep = $scope.loadStep;

    $scope.steps = $scope.bb.steps;
    $scope.allSteps = $scope.bb.allSteps;

    // stop users from clicking back once the form is completed ###
    $scope.loadStep = function (number) {
        if (!lastStep() && !currentStep(number) && !atDisablePoint()) {
            return loadStep(number);
        }
    };

    var lastStep = function lastStep() {
        return $scope.bb.current_step === $scope.bb.allSteps.length;
    };

    var currentStep = function currentStep(step) {
        return step === $scope.bb.current_step;
    };

    var atDisablePoint = function atDisablePoint() {
        if (!angular.isDefined($scope.bb.disableGoingBackAtStep)) {
            return false;
        }
        return $scope.bb.current_step >= $scope.bb.disableGoingBackAtStep;
    };

    return $scope.isDisabledStep = function (step) {
        if (lastStep() || currentStep(step.number) || !step.passed || atDisablePoint()) {
            return true;
        } else {
            return false;
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('bbBreadcrumbs', function (PathSvc) {
    return {
        restrict: 'A',
        replace: true,
        scope: true,
        controller: 'Breadcrumbs',
        templateUrl: function templateUrl(element, attrs) {
            if (_.has(attrs, 'complex')) {
                return PathSvc.directivePartial("_breadcrumb_complex");
            } else {
                return PathSvc.directivePartial("_breadcrumb");
            }
        },
        link: function link(scope) {}
    };
});
'use strict';

// Used to load the application's content. It uses ng-include.
angular.module('BB.Directives').directive('bbContentNew', function (PathSvc) {
    return {
        restrict: 'A',
        replace: true,
        scope: true,
        templateUrl: PathSvc.directivePartial("content_main"),
        controller: function controller($scope) {
            $scope.initPage = function () {
                return $scope.$eval('setPageLoaded()');
            };
        }
    };
});
'use strict';

angular.module('BB.Controllers').controller('CustomBookingText', function ($scope, $rootScope, $q, CustomTextService, LoadingService) {

        var loader = LoadingService.$loader($scope).notLoaded();

        return $rootScope.connection_started.then(function () {
                return CustomTextService.BookingText($scope.bb.company, $scope.bb.current_item).then(function (msgs) {
                        $scope.messages = msgs;
                        return loader.setLoaded();
                }, function (err) {
                        return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
                });
        }, function (err) {
                return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
        });
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbCustomBookingText
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Loads a list of custom booking text for the currently in scope company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @property {string} messages The messages text
 * @property {string} setLoaded Loading set of custom text
 * @property {object} setLoadedAndShowError Set loaded and show error
 */ //


angular.module('BB.Directives').directive('bbCustomBookingText', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'CustomBookingText'
    };
});
'use strict';

angular.module('BB.Controllers').controller('CustomConfirmationText', function ($scope, $rootScope, CustomTextService, $q, LoadingService) {
    var loader = LoadingService.$loader($scope).notLoaded();

    $rootScope.connection_started.then(function () {
        return $scope.loadData();
    }, function (err) {
        return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
    });

    /***
     * @ngdoc method
     * @name loadData
     * @methodOf BB.Directives:bbCustomBookingText
     * @description
     * Load data and display a text message
     */
    return $scope.loadData = function () {

        if ($scope.total) {

            return CustomTextService.confirmationText($scope.bb.company, $scope.total).then(function (msgs) {
                $scope.messages = msgs;
                return loader.setLoaded();
            }, function (err) {
                return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
            });
        } else if ($scope.loadingTotal) {

            return $scope.loadingTotal.then(function (total) {
                return CustomTextService.confirmationText($scope.bb.company, total).then(function (msgs) {
                    $scope.messages = msgs;
                    return loader.setLoaded();
                }, function (err) {
                    return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
                });
            }, function (err) {
                return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
            });
        } else {
            return loader.setLoaded();
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('bbCustomConfirmationText', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'CustomConfirmationText'
    };
});
'use strict';

(function () {

    /***
     * @ngdoc directive
     * @name BB.Directives.directive:bbDateTimePicker
     * @scope
     * @restrict A
     *
     * @description
     * DateTime picker that combines date & timepicker and consolidates
     * the Use of Moment.js in the App and Date in the pickers
     *
     * @param {object}  date   A moment.js date object
     * @param {boolean}  showMeridian   Switch to show/hide meridian (optional, default:false)
     * @param {number}  minuteStep Step for the timepicker (optional, default:10)
     * @param {object}  minDate Min date value for datetimepicker
     * @param {object}  maxDate Max date value for datetimepicker
     */
    angular.module('BB.Directives').directive('bbDateTimePicker', bbDateTimePickerDirective);

    function bbDateTimePickerDirective() {
        return {
            scope: {
                date: '=',
                showMeridian: '=?',
                minuteStep: '=?',
                minDate: '=?',
                maxDate: '=?',
                format: '=?',
                dateOnly: '=?',
                bbDisabled: '=?'
            },
            restrict: 'A',
            templateUrl: 'bb_date_time_picker.html',
            controller: function controller($scope, GeneralOptions) {
                if ($scope.format == null) {
                    $scope.format = 'dd/MM/yyyy';
                }

                if ($scope.bbDisabled == null) {
                    $scope.bbDisabled = false;
                }

                // Default minuteStep value
                if (!$scope.minuteStep || typeof $scope.minuteStep === 'undefined') {
                    $scope.minuteStep = GeneralOptions.calendar_minute_step;
                }

                // Default showMeridian value
                if (!$scope.showMeridian || typeof $scope.showMeridian === 'undefined') {
                    $scope.showMeridian = GeneralOptions.twelve_hour_format;
                }

                // Watch for changes in the timepicker and reassemble the new datetime
                $scope.$watch('datetimeWithNoTz', function (newValue, oldValue) {

                    if (newValue != null && moment(newValue).isValid() && newValue.getTime() !== oldValue.getTime()) {
                        var assembledDate = moment();
                        assembledDate.set({
                            'year': parseInt(newValue.getFullYear()),
                            'month': parseInt(newValue.getMonth()),
                            'date': parseInt(newValue.getDate()),
                            'hour': parseInt(newValue.getHours()),
                            'minute': parseInt(newValue.getMinutes()),
                            'second': 0,
                            'milliseconds': 0
                        });

                        return $scope.date = assembledDate;
                    }
                });

                var clearTimezone = function clearTimezone(date) {

                    if (date != null && moment(date).isValid()) {
                        date = moment(date);
                        var newDate = new Date();
                        newDate.setFullYear(date.year());
                        newDate.setMonth(date.month());
                        newDate.setDate(date.date());
                        newDate.setHours(date.hours());
                        newDate.setMinutes(date.minutes());
                        newDate.setSeconds(0);
                        newDate.setMilliseconds(0);

                        return newDate;
                    }
                    // otherwise undefined (important for timepicker)
                    return undefined;
                };

                $scope.datetimeWithNoTz = clearTimezone($scope.date);

                $scope.$watch('date', function (newValue, oldValue) {
                    if (newValue !== oldValue && clearTimezone(newValue) !== oldValue) {
                        return $scope.datetimeWithNoTz = clearTimezone(newValue);
                    }
                });

                $scope.$watch('minDate', function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        return $scope.minDateClean = clearTimezone(newValue);
                    }
                });

                $scope.$watch('maxDate', function (newValue, oldValue) {
                    if (newValue !== oldValue) {
                        return $scope.maxDateClean = clearTimezone(newValue);
                    }
                });

                $scope.minDateClean = clearTimezone($scope.minDate);
                return $scope.maxDateClean = clearTimezone($scope.maxDate);
            }
        };
    }
})();
'use strict';

// replaces the date parse method for the angular-ui datepicker popup. the picker
// defaults to US style dates when typing a date into the picker input, so
// 05/09/2014 is translated as 9th May rather than the 5th September
angular.module('BB.Directives').directive('bbDatepickerPopup', function ($parse, $document, $timeout, $bbug, CompanyStoreService, viewportSize) {
    var ie8orLess = false;
    // stop user typing in input field if using ie8 or less as the date gets a
    // little delyaed and outputs wrong date
    try {
        ie8orLess = window.parseInt(/MSIE\s*(\d)/.exec(window.navigator.userAgent)[1]);
    } catch (e) {
        ie8orLess = false;
    }

    return {
        restrict: 'A',
        //  set low priority as we want to make sure the 'datepickerPopup' directive
        //  runs first
        priority: -1,
        require: 'ngModel',

        // this is the original effort at trying to allow the user to type the date in
        // to the input field. it works ok but there are a few bugs relative to setting
        // the ngmodel value and it then it dissapears during the digest loop
        link: function link(scope, element, attrs, ngModel) {
            var format = void 0,
                replacementDateParser = void 0;
            var origDateParser = null;
            var data = element.controller('ngModel');
            if (attrs.uibDatepickerPopup != null) {
                format = {
                    date_us: "MM/dd/yyyy",
                    date_uk: "dd/MM/yyyy"
                };
                if (CompanyStoreService.country_code === "us") {
                    attrs.uibDatepickerPopup = format.date_us;
                } else {
                    attrs.uibDatepickerPopup = format.date_uk;
                }
            }

            var dateFormat = attrs.bbDatepickerPopup ? attrs.bbDatepickerPopup : 'DD/MM/YYYY';
            var yearNow = moment(new Date()).year();
            var getter = $parse(attrs.ngModel);
            var timeRangeScope = scope;

            // the date picker is sometimes in a nested controller so we need to find the
            // timerange scope as the 'selected_date' property is assigned directly to
            // the scope, which causes inheritance issues.
            var getTimeRangeScope = function getTimeRangeScope(scope) {
                if (scope) {
                    if (scope.controller && scope.controller.indexOf('TimeRangeList') > 0) {
                        return timeRangeScope = scope;
                    } else {
                        return getTimeRangeScope(scope.$parent);
                    }
                }
            };
            getTimeRangeScope(scope);

            if (ie8orLess) {
                $bbug(element).on('keydown keyup keypress', function (ev) {
                    ev.preventDefault();
                    return ev.stopPropagation();
                });
            }

            if (ie8orLess || viewportSize.isXS()) {
                $bbug(element).attr('readonly', 'true');
            }

            // the date picker doesn't support the typing in of dates very well, or
            // hiding the popup after typing a date.
            $bbug(element).on('keydown', function (e) {
                if (e.keyCode === 13) {
                    replacementDateParser($bbug(e.target).val(), true);
                    // hide popup
                    $document.trigger('click');
                    return $bbug(element).blur();
                }
            });

            $bbug(element).on('click', function (e) {
                e.preventDefault();
                e.stopPropagation();
                return $timeout(function () {
                    return scope.opened = true;
                });
            });

            // completely disable focus for the input, but only if input is readonly
            $bbug(element).on('focus', function () {
                if ($(this).attr("readonly")) {
                    return this.blur();
                }
            });

            // call the function which handles the date change
            // on-date-change="selectedDateChanged()"
            var callDateHandler = function callDateHandler(date) {
                // something somewhere is removing the date value from the scope after the
                // date is set. so we watch digest and set it back if it gets removed.
                var watch = scope.$watch(getter, function (newVal, oldVal) {
                    if (!newVal) {
                        return getter.assign(timeRangeScope, date);
                    }
                });

                // and then remove watcher after the digest has finished
                $timeout(watch, 0);

                // US date format needed
                var selectedMoment = new moment(date, dateFormat);
                var selectedDate = new Date(selectedMoment.format('MM/DD/YYYY'));

                var isDate = _.isDate(selectedDate);

                if (isDate) {
                    getter.assign(timeRangeScope, selectedDate);
                    ngModel.$setValidity('date', true);
                    scope.$eval(attrs.onDateChange);
                }

                return isDate;
            };

            replacementDateParser = function replacementDateParser(viewValue, returnKey) {
                // if date user has selected a date from popup then update the picker
                if (callDateHandler(viewValue)) {
                    return viewValue;
                }

                if (ie8orLess) {
                    return viewValue;
                }

                var mDate = moment(viewValue, dateFormat);

                if (!mDate.isValid()) {
                    mDate = moment(new Date());
                }

                // the year date has to be in the four 'YYYY' format
                if (/\/YY$/.test(dateFormat)) {
                    dateFormat += 'YY';
                }

                if (mDate.year() === 0) {
                    mDate.year(yearNow);
                }

                // convert date to american format as that's what the picker works with.
                viewValue = mDate.format('MM/DD/YYYY');

                // test year format is not /0201, /0202 etc
                viewValue = viewValue.replace(/\/00/, '/20');
                if (/\/02\d{2}$/.test(viewValue)) {
                    return;
                }

                // user has typed in a date and pressed the return key. as the picker
                // doesn't support this kind of functionality we have to implement it.
                if (returnKey) {
                    if (mDate.year().toString().length === 2) {
                        mDate.year(mDate.year() + 2000);
                    }
                    return callDateHandler(mDate._d);
                } else {
                    return origDateParser.call(this, viewValue);
                }
            };
            // wait until the data object for the popup element has been initialised by
            // angular-ui and then override the $parser with our parse function
            var f = function f() {
                if (_.isFunction(data.$parsers[0])) {
                    origDateParser = data.$parsers[0];
                    data.$parsers[0] = replacementDateParser;
                    return;
                } else {
                    setTimeout(f, 10);
                }
            };
            f();
        }
    };
});
"use strict";

angular.module("BB.Directives").directive("bbFbLogin", function (LoginService, $rootScope, AlertService, $window) {

    return {
        restrict: 'A',
        scope: true,
        link: function link(scope, element, attrs) {

            var options = scope.$eval(attrs.bbFbLogin) || {};
            $rootScope.connection_started.then(function () {
                return checkLoginState();
            });

            var statusChangeCallback = function statusChangeCallback(response) {
                if (response.status === 'connected') {
                    var params = {};
                    params.access_token = response.authResponse.accessToken;
                    if (options.login_only) {
                        params.login_only = options.login_only;
                    }
                    loginToBBWithFBUser(params);
                } else if (response.status === 'not_authorized') {
                    scope.loginFB();
                } else {
                    scope.loginFB();
                }
            };

            var checkLoginState = function checkLoginState() {
                FB.getLoginStatus(function (response) {
                    statusChangeCallback(response);
                });
            };

            var loginToBBWithFBUser = function loginToBBWithFBUser(params) {
                return LoginService.FBLogin(scope.bb.company, params).then(function (member) {
                    $rootScope.member = member;
                    scope.setClient($rootScope.member);
                    if (scope.bb.destination) {
                        return scope.redirectTo(scope.bb.destination);
                    } else {
                        scope.setLoaded(scope);
                        return scope.decideNextPage();
                    }
                }, function (err) {
                    if (err.data.error === "FACEBOOK-LOGIN-MEMBER-NOT-FOUND") {
                        return AlertService.raise('FB_LOGIN_NOT_A_MEMBER');
                    } else {
                        return AlertService.raise('LOGIN_FAILED');
                    }
                });
            };

            return scope.loginFB = function () {
                return FB.login(function (response) {
                    if (response.status === 'connected') {
                        var params = {};
                        params.access_token = response.authResponse.accessToken;
                        if (options.login_only) {
                            params.login_only = options.login_only;
                        }
                        loginToBBWithFBUser(params);
                    } else if (response.status === 'not_authorized') {
                        AlertService.raise('LOGIN_FAILED');
                    } else {
                        AlertService.raise('LOGIN_FAILED');
                    }
                }, { scope: 'public_profile,email' });
            };
        }
    };
});
'use strict';

angular.module('BB.Controllers').controller('FileUpload', function ($scope, Upload) {
    return (

        /***
         * @ngdoc method
         * @name uploadFile
         * @methodOf BB.Directives:bbItemDetails
         * @description
         * Upload a file
         * For more information see https://github.com/danialfarid/ng-file-upload
         * To use this module:
         *
         * @param {object} item basket item
         * @param {object} file uploaded file
         * @param {number} existing attachment id
         * @param {array} errFiles errors array
         */
        $scope.uploadFile = function (item, file, err_files, existing) {
            $scope.err_file = err_files && err_files[0];
            $scope.show_error = false;
            $scope.file_type_error = false;
            $scope.my_file = file;
            var accepted_files = $scope.accept.replace(/\'/g, '').split(',');
            var file_is_valid = file && (0 <= accepted_files.indexOf(file.type) || 0 <= file.type.indexOf('image'));

            if (file_is_valid) {
                var att_id = void 0;
                if (existing) {
                    att_id = existing;
                } else {
                    att_id = null;
                }

                var method = "POST";
                if (att_id) {
                    method = "PUT";
                }
                var url = item.$href('add_attachment');

                var onSuccess = function onSuccess(response) {
                    file.result = response.data;
                    item.attachment = response.data;
                    item.attachment_id = response.data.id;
                    return file.progress = 100;
                };

                var onError = function onError(response) {
                    $scope.show_error = true;
                    return file.progress = 100;
                };

                var onProgress = function onProgress(evt) {
                    return file.progress = Math.min(100, parseInt(99.0 * evt.loaded / evt.total));
                };

                Upload.rename(file, file.name.replace(/[^\x00-\x7F]/g, '')); //eslint-disable-line no-control-regex

                file.upload = Upload.upload({
                    url: url,
                    method: method,
                    data: { attachment_id: att_id },
                    file: file
                });

                return file.upload.then(onSuccess, onError, onProgress);
            } else if (file_is_valid === false) {
                return $scope.file_type_error = true;
            }
        }
    );
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbFileUpload
 * @restrict AE
 * @scope true
 *
 * @description
 * File upload
 *
 *  
 <example>
    <file name="index.html">
        <div
        bb-file-upload
        item="item"
        max-size="100KB"
        pretty-accept="images, .pdf, .doc/docx"
        accept="'application/pdf,application/msword,image/*'">
        </div>
 </file>
</example>
 */

angular.module('BB.Directives').directive('bbFileUpload', function () {
    return {
        restrict: 'A',
        replace: false,
        scope: {
            accept: '@',
            prettyAccept: '@',
            maxSize: '@',
            item: '='
        },
        controller: 'FileUpload',
        templateUrl: 'file_upload.html'
    };
});
'use strict';

// Form Data Store Directive  this does very little apart from register the
// widget, so the user's form choices are stored.
angular.module('BB.Directives').directive('bbFormDataStore', function (FormDataStoreService) {
    //  remove '?' when we change over the bbWidget directive
    return {
        require: '?bbWidget',
        link: function link(scope) {
            return FormDataStoreService.register(scope);
        }
    };
});
'use strict';

angular.module('BB.Controllers').controller('GetAvailability', function ($scope, $element, $attrs, $rootScope, $q, TimeService, AlertService, BBModel, halClient) {
    return (

        /***
         * @ngdoc method
         * @name loadAvailability
         * @methodOf BB.Directives:bbGetAvailability
         * @description
         * Load availability of the services in according of prms parameter
         *
         * @param {array} prms The parameters of availability
         */
        $scope.loadAvailability = function (prms) {

            var service = halClient.$get($scope.bb.api_url + '/api/v1/' + prms.company_id + '/services/' + prms.service);
            return service.then(function (serv) {
                $scope.earliest_day = null;
                var sday = moment();
                var eday = moment().add(30, 'days');
                return serv.$get('days', { date: sday.toISOString(), edate: eday.toISOString() }).then(function (res) {
                    return function () {
                        var result = [];
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = Array.from(res.days)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var day = _step.value;

                                var item = void 0;
                                if (day.spaces > 0 && !$scope.earliest_day) {
                                    $scope.earliest_day = moment(day.date);
                                    if (day.first) {
                                        item = $scope.earliest_day.add(day.first, "minutes");
                                    }
                                }
                                result.push(item);
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return) {
                                    _iterator.return();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }

                        return result;
                    }();
                });
            });
        }
    );
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbGetAvailability
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Loads a list of availability for the currently in scope company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @property {array} earliest_day The availability of earliest day
 * @property {object} alert The alert service - see {@link BB.Services:Alert Alert Service}
 */ //


angular.module('BB.Directives').directive('bbGetAvailability', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'GetAvailability',
        link: function link(scope, element, attrs) {
            if (attrs.bbGetAvailability) {
                scope.loadAvailability(scope.$eval(attrs.bbGetAvailability));
            }
        }
    };
});
"use strict";

// International Telephone Input directive
// http://www.tooorangey.co.uk/posts/that-international-telephone-input-umbraco-7-property-editor/
// https://github.com/Bluefieldscom/intl-tel-input
angular.module('BB.Directives').directive("bbIntTelNumber", function ($bbug, $parse, $rootScope) {
    return {
        restrict: "A",
        require: "ngModel",

        link: function link(scope, element, attrs, ctrl) {

            var options = scope.$eval(attrs.bbIntTelNumber);

            // apply plugin
            element.intlTelInput(options);

            var isValid = function isValid(value) {
                if (value) {
                    return element.intlTelInput("isValidNumber");
                } else {
                    return true;
                }
            };

            if (attrs.prefix) {
                $bbug(element).on("countrychange", function (e, countryData) {
                    scope.$eval(attrs.prefix + " = \"" + countryData.dialCode + "\"");
                    format(ctrl.$viewValue);
                    ctrl.$render();
                });
            }

            ctrl.$render = function () {
                ctrl.$setViewValue(ctrl.$modelValue);
            };

            var format = function format(value) {
                var str = "";
                if (attrs.prefix) {
                    if (scope.$eval(attrs.prefix) != null) {
                        str += "+" + scope.$eval(attrs.prefix) + " ";
                    }
                } else {
                    if (scope.$eval(attrs.ngModel + '_prefix') != null) {
                        str += "+" + scope.$eval(attrs.ngModel + '_prefix') + " ";
                    }
                }
                if (scope.$eval(attrs.ngModel) != null) {
                    str += scope.$eval(attrs.ngModel);
                }
                if (str[0] === "+") {
                    if (attrs.prefix) {
                        if (scope.$eval(attrs.ngModel) != null) {
                            element.intlTelInput("setNumber", "+" + scope.$eval(attrs.prefix) + " " + scope.$eval(attrs.ngModel));
                        }
                    } else {
                        element.intlTelInput("setNumber", "+" + scope.$eval(attrs.ngModel + '_prefix') + " " + scope.$eval(attrs.ngModel));
                    }
                    ctrl.$setValidity(attrs.ngModel, isValid(value));
                }
                return str;
            };

            var parse = function parse(value) {
                var prefix = element.intlTelInput("getSelectedCountryData").dialCode;
                var getter = void 0;
                if (attrs.prefix) {
                    getter = $parse(attrs.prefix);
                } else {
                    getter = $parse(attrs.ngModel + '_prefix');
                }
                getter.assign(scope, prefix);
                ctrl.$setValidity(attrs.ngModel, isValid(value));
                return value;
            };

            ctrl.$formatters.push(format);
            ctrl.$parsers.push(parse);
        }
    };
});
'use strict';

// Loader Directive

// Example usage;
// <div bb-loader>
// <div bb-loader="#someid">
// <div bb-loader=".someclass">

// classes or ids will be added to the loading item so they can be styled
// individually.

angular.module('BB.Directives').directive('bbLoader', function ($rootScope, $compile, PathSvc, TemplateSvc) {
    return {
        restrict: 'A',
        replace: false,
        scope: {},
        controllerAs: 'LoaderCtrl',
        controller: function controller($scope) {
            // get parent scope's id as that is the element on which the 'bbLoader'
            // directive was applied. we can then act on all child scope events.
            var parentScopeId = $scope.$parent.$id;
            var scopeIdArr = [];

            // if scope which is emitting 'show:loader' event is child of this bbLoader
            // instance, then store it's id so we can check when it's finished loading.
            var addScopeId = function addScopeId(id) {
                scopeIdArr.push(id);
                scopeIdArr = _.uniq(scopeIdArr);
            };

            // remove scope ids when they emit the 'hide:loader' event. return the array
            // length so we can see if we need to hide the loading icon.
            var removeScopeId = function removeScopeId(id) {
                scopeIdArr = _.without(scopeIdArr, id);
                return scopeIdArr.length;
            };

            // check to see if this instance of bbLoader is a parent of the scope which
            // has emitted the 'show:loader' event. if it is then show the loading
            // icon and store it's id.
            var showLoader = function showLoader(e, cscope) {
                var sid = cscope.$id;

                while (cscope) {
                    if (cscope.$id === parentScopeId) {
                        // store scope id so we can check when it's finished loading
                        addScopeId(sid);
                        // show loading icon
                        $scope.scopeLoaded = false;
                        break;
                    }
                    cscope = cscope.$parent;
                }
            };

            // check scopeid array. if it's empty then hide the loading icon. the
            // removeScopeId() function returns the array length
            var hideLoader = function hideLoader(e, cscope) {
                if (!removeScopeId(cscope.$id)) {
                    $scope.scopeLoaded = true;
                    return;
                }
            };

            // start listening for events emitted by other scopes
            $rootScope.$on('show:loader', showLoader);
            $rootScope.$on('hide:loader', hideLoader);
            // show loader by default
            $scope.scopeLoaded = false;
        },
        link: function link(scope, element, attrs) {
            // we can't load the template using 'templateUrl' as this will alter the
            // element which contains the directive. we can't use transclusion on a
            // directive applied to the BBCrtl element as the controller contains most of
            // the app's logic and any transcluded content will use the scope of it's
            // parent and skip the BBCrtl. also translcuded content which contains ng-
            // init throws a js error and there is lots of that in the app. so for those
            // reasons we load the template manually and compile it.
            TemplateSvc.get(PathSvc.directivePartial("loader")).then(function (html) {
                // add the id or class attribute if there is one used with the directive
                if (_.isString(attrs.bbLoader)) {
                    var str = attrs.bbLoader.slice(1);

                    if (/^#/.test(attrs.bbLoader)) {
                        html.attr('id', str);
                    } else if (/^\./.test(attrs.bbLoader)) {
                        html.addClass(str);
                    }
                }

                element.prepend(html);
                $compile(html)(scope);
            });
        }
    };
});

// Loading Spinner Directive

// Example usage;
// <div bb-loading-spinner>

angular.module('BB.Directives').directive('bbLoadingSpinner', function ($compile) {

    return {
        transclude: true,

        link: function link(scope, element, attrs, controller, transclude) {

            var loadingScopes = {};
            scope.isLoading = false;

            return scope.$on('isLoading', function (event, isLoading) {
                event.stopPropagation();
                loadingScopes[event.targetScope.$id] = isLoading;
                return scope.isLoading = _.every(_.values(loadingScopes));
            });
        },


        template: '            <div ng-show="isLoading" class="loader-wrapper">\n                <div class="loader"></div>\n            </div>\n            <div ng-transclude></div>            '
    };
});
"use strict";

/**
 * This directive allows to use the bb-logged-user attribute to show some
 * content only if the user is logged in.
 *
 * You can transclude the directive children content as well.
 *
 * You can use this directive anywhere you need to show or hide a content
 * conditionally for a logged in user.
 *
 * Example:
 *
 * <div bb-logged-user>
 *     <span>some content for the logged in user only</span>
 *     <p>only an authenticated user can see me</span>
 * </div>
 *
 * The block above is rendered only if the user logs in or is already logged in.
 * The directive handles the runtime login status changes as well
 *
 * @param $compile
 * @param LoginService
 * @returns {{transclude: boolean, scope: {}, terminal: boolean, restrict: string, priority: number, compile: compile}}
 */
function bbLoggedUser($compile, LoginService) {
    return {
        transclude: true,
        scope: {},
        // tell Angular to stop compiling after that (on the same directive)
        terminal: true,
        restrict: 'A',
        priority: 10000,
        compile: function compile(element, attrs) {
            /*
             * Avoid indefinite loop. Otherwise Angular tries
             * to infinitely recompile the directive itself
             */
            element.removeAttr("add-condition");
            element.removeAttr("data-add-condition");

            // remove the directive attribute
            element.removeAttr('bb-logged-user');

            return {
                post: function postLink(scope, iElement, iAttrs, controller, transcluded) {
                    /*
                     * Retrieve the directive child/ren content.
                     *
                     * The directive content is removed during the compiling process
                     * so we have to re-add it again
                     */
                    transcluded(scope, function (clone) {

                        // set the condition we need to show/hide the content
                        iElement[0].setAttribute('ng-if', '$root.member');

                        LoginService.checkLogin();

                        // all children are translated into string to set inner html
                        iElement[0].innerHTML = clone.map(function (index, c) {
                            return c.outerHTML || null;
                        }).get().join('');

                        // recompile
                        $compile(iElement)(scope);
                    });
                }
            };
        }
    };
}

bbLoggedUser.$inject = ['$compile', 'LoginService'];
angular.module('BB.Directives').directive('bbLoggedUser', bbLoggedUser);
'use strict';

(function () {

    angular.module('BB.Directives').directive('bbModalWidget', modalWidget);

    function modalWidget(BBModel, $log, $compile, $q, PathSvc, $templateCache, $http) {

        var getTemplate = function getTemplate(template) {
            var partial = template ? template : 'main';
            return $templateCache.get(partial + '.html');
        };

        var renderTemplate = function renderTemplate(scope, element, design_mode, template) {
            $q.when(getTemplate(template)).then(function (template) {
                element.html(template).show();
                if (design_mode) {
                    element.append('<style widget_css scoped></style>');
                }
                $compile(element.contents())(scope);
            });
        };

        var link = function link(scope, element, attrs) {
            var config = scope.$eval(attrs.bbModalWidget);
            scope.initWidget(config);
            return renderTemplate(scope, element, config.design_mode, config.template);
        };

        var directive = {
            link: link,
            controller: 'BBCtrl',
            controllerAs: '$bbCtrl',
            scope: true
        };

        return directive;
    }
})();
'use strict';

angular.module('BB.Directives').directive('bbMonthPicker', function (PathSvc, $timeout) {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        require: ['^?bbEvents', '^?bbMultiCompanyEvents'],
        templateUrl: function templateUrl(element, attrs) {
            return PathSvc.directivePartial("_month_picker");
        },
        link: function link(scope, el, attrs) {

            scope.picker_settings = scope.$eval(attrs.bbMonthPicker) || {};
            scope.picker_settings.months_to_show = scope.picker_settings.months_to_show || 3;

            $(window).resize(function () {
                return $timeout(function () {
                    var width = el.width();
                    return scope.rebuildSlideToWidth(width);
                }, 500);
            });

            return scope.$watch(attrs.dayData, function (dayData) {
                if (dayData) {
                    if (!dayData.length) {
                        scope.months = null;
                    }
                    if (dayData.length) {
                        scope.processDates(dayData);
                    }
                    var width = el.width();
                    return scope.rebuildSlideToWidth(width);
                }
            });
        },
        controller: function controller($scope) {

            $scope.processDates = function (dates) {

                var first_carousel_month = void 0;
                if (!dates.length) {
                    dates = null;
                }

                var datehash = {};
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Array.from(dates)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var date = _step.value;

                        datehash[date.date.format("DDMMYY")] = date;
                        if (!$scope.first_available_day && date.spaces > 0) {
                            $scope.first_available_day = date.date;
                        }
                    }

                    // start at current month or the first month that has availability
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                if ($scope.picker_settings.start_at_first_available_day) {
                    first_carousel_month = $scope.first_available_day.clone().startOf('month');
                } else {
                    first_carousel_month = moment().startOf('month');
                }

                var last_date = _.last(dates);
                var diff = last_date.date.diff(first_carousel_month, 'months');
                diff = diff > 0 ? diff + 1 : 1;

                // use picker settings or diff between first and last date to determine number of months to display
                $scope.num_months = $scope.picker_settings && $scope.picker_settings.months ? $scope.picker_settings.months : diff;

                return $scope.months = $scope.getMonths($scope.num_months, first_carousel_month, datehash);
            };

            // listen to date changes from the date filter and clear the selected day
            $scope.$on('event_list_filter_date:changed', function (event, date) {

                var newDay = $scope.getDay(date);

                if ($scope.selected_day) {
                    if ($scope.selected_day.date.isSame(date)) {
                        return $scope.selected_day.selected = !$scope.selected_day.selected;
                    } else {
                        $scope.selected_day.selected = false;
                        if (newDay) {
                            $scope.selected_day = newDay;
                            return $scope.selected_day.selected = true;
                        }
                    }
                } else {
                    if (newDay) {
                        $scope.selected_day = newDay;
                        return $scope.selected_day.selected = true;
                    }
                }
            });

            $scope.$on('event_list_filter_date:cleared', function () {
                if ($scope.selected_day) {
                    return $scope.selected_day.selected = false;
                }
            });

            $scope.toggleDay = function (day) {

                if (!day || day.data && (day.data.spaces === 0 || day.disabled || !day.available) || !day.data && !day._d) {
                    return;
                }

                // toggle when same day selected
                if ($scope.selected_day && $scope.selected_day.date.isSame(day.date)) {
                    $scope.selected_day.selected = !$scope.selected_day.selected;
                }

                // swap when new day selected
                if ($scope.selected_day && !$scope.selected_day.date.isSame(day.date)) {
                    $scope.selected_day.selected = false;
                    $scope.selected_day = day;
                    $scope.selected_day.selected = true;
                }

                // set new selected day
                if (!$scope.selected_day) {
                    $scope.selected_day = day;
                    $scope.selected_day.selected = true;
                }

                // TODO refactor to call showDay via controller
                return $scope.showDay(day.date);
            };

            $scope.rebuildSlide = function (n) {

                var months = void 0;
                var last_carousel_month = moment().startOf('month');
                var num_empty_months_to_add = 0;

                if ($scope.months && $scope.months.length) {
                    // remove filler months before rebuilding
                    months = [];
                    var _iteratorNormalCompletion2 = true;
                    var _didIteratorError2 = false;
                    var _iteratorError2 = undefined;

                    try {
                        for (var _iterator2 = Array.from($scope.months)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                            var month = _step2.value;

                            if (month && !month.filler) {
                                months.push(month);
                            }
                        }
                    } catch (err) {
                        _didIteratorError2 = true;
                        _iteratorError2 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                _iterator2.return();
                            }
                        } finally {
                            if (_didIteratorError2) {
                                throw _iteratorError2;
                            }
                        }
                    }

                    if (months.length) {
                        $scope.months = months;
                    }
                    // set required vars
                    last_carousel_month = angular.copy($scope.months[$scope.months.length - 1].start_date);
                    last_carousel_month.add(1, 'month');

                    num_empty_months_to_add = n - $scope.months.length % n;
                    if (num_empty_months_to_add === n) {
                        num_empty_months_to_add = 0;
                    }
                } else {
                    // set required vars
                    num_empty_months_to_add = n;
                    last_carousel_month = moment().startOf('month');
                }

                var monthCollection = [];
                var slide = [];

                if (!$scope.months) {
                    $scope.months = [];
                }

                var fillerMonths = $scope.getMonths(num_empty_months_to_add, last_carousel_month);
                $scope.months = $scope.months.concat(fillerMonths);

                // displays months in sets per slide
                var _iteratorNormalCompletion3 = true;
                var _didIteratorError3 = false;
                var _iteratorError3 = undefined;

                try {
                    for (var _iterator3 = Array.from($scope.months)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                        var value = _step3.value;

                        if (slide.length === n) {
                            monthCollection.push(slide);
                            slide = [];
                        }
                        slide.push(value);
                    }
                } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion3 && _iterator3.return) {
                            _iterator3.return();
                        }
                    } finally {
                        if (_didIteratorError3) {
                            throw _iteratorError3;
                        }
                    }
                }

                monthCollection.push(slide);
                return $scope.monthCollection = monthCollection;
            };

            $scope.getMonths = function (months_to_display, start_month, datehash) {
                var months = [];
                // generates dates for carousel
                for (var m = 0, end = months_to_display, asc = 0 <= end; asc ? m < end : m > end; asc ? m++ : m--) {
                    var date = start_month.clone().startOf('week');
                    var month = { weeks: [] };
                    month.index = m - 1;
                    for (var w = 1; w <= 6; w++) {
                        var week = { days: [] };
                        for (var d = 1; d <= 7; d++) {

                            var day_data;
                            if (date.isSame(date.clone().startOf('month'), 'day') && !month.start_date) {
                                month.start_date = date.clone();
                            }
                            if (datehash) {
                                day_data = datehash[date.format("DDMMYY")];
                            }

                            var day = {
                                date: date.clone(),
                                data: datehash ? day_data : null,
                                available: datehash ? day_data && day_data.spaces && day_data.spaces > 0 : false,
                                today: moment().isSame(date, 'day'),
                                past: date.isBefore(moment(), 'day'),
                                disabled: !month.start_date || !date.isSame(month.start_date, 'month')
                            };
                            week.days.push(day);

                            if ($scope.selected_date && day.date.isSame($scope.selected_date, 'day')) {
                                day.selected = true;
                                $scope.selected_day = day;
                            }

                            date.add(1, 'day');
                        }

                        if (!datehash) {
                            month.filler = true;
                        }
                        month.weeks.push(week);
                    }

                    months.push(month);
                    start_month.add(1, 'month');
                }

                return months;
            };

            $scope.rebuildSlideToWidth = function (width) {
                // TODO - add code for 4 and 5?
                var num_slides_to_display = void 0;
                if (width > 750) {
                    // desktop
                    num_slides_to_display = 3;
                    return $scope.rebuildSlide(num_slides_to_display);
                } else if (width > 550) {
                    // tablet
                    num_slides_to_display = 2;
                    return $scope.rebuildSlide(num_slides_to_display);
                } else {
                    // phone
                    num_slides_to_display = 1;
                    return $scope.rebuildSlide(num_slides_to_display);
                }
            };

            return $scope.getDay = function (date) {
                var _iteratorNormalCompletion4 = true;
                var _didIteratorError4 = false;
                var _iteratorError4 = undefined;

                try {
                    for (var _iterator4 = Array.from($scope.months)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                        var month = _step4.value;
                        var _iteratorNormalCompletion5 = true;
                        var _didIteratorError5 = false;
                        var _iteratorError5 = undefined;

                        try {
                            for (var _iterator5 = Array.from(month.weeks)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                                var week = _step5.value;
                                var _iteratorNormalCompletion6 = true;
                                var _didIteratorError6 = false;
                                var _iteratorError6 = undefined;

                                try {
                                    for (var _iterator6 = Array.from(week.days)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                                        var day = _step6.value;

                                        if (day.date.isSame(date) && !day.disabled) {
                                            return day;
                                        }
                                    }
                                } catch (err) {
                                    _didIteratorError6 = true;
                                    _iteratorError6 = err;
                                } finally {
                                    try {
                                        if (!_iteratorNormalCompletion6 && _iterator6.return) {
                                            _iterator6.return();
                                        }
                                    } finally {
                                        if (_didIteratorError6) {
                                            throw _iteratorError6;
                                        }
                                    }
                                }
                            }
                        } catch (err) {
                            _didIteratorError5 = true;
                            _iteratorError5 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion5 && _iterator5.return) {
                                    _iterator5.return();
                                }
                            } finally {
                                if (_didIteratorError5) {
                                    throw _iteratorError5;
                                }
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError4 = true;
                    _iteratorError4 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion4 && _iterator4.return) {
                            _iterator4.return();
                        }
                    } finally {
                        if (_didIteratorError4) {
                            throw _iteratorError4;
                        }
                    }
                }
            };
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('bbMonthPickerListener', function (PathSvc, $timeout) {
    return {
        restrict: 'A',
        scope: true,
        link: function link(scope, el, attrs) {
            $(window).resize(function () {
                return $timeout(function () {
                    return scope.carouselIndex = 0;
                });
            });

            return scope.$on('event_list_filter:changed', function () {
                return $timeout(function () {
                    return scope.carouselIndex = 0;
                });
            });
        }
    };
});
'use strict';

(function () {
    'use strict';

    angular.module('BB').controller('BBPageCtrl', BBPageCtrl);

    function BBPageCtrl($scope, $q, ValidatorService, LoadingService) {
        'ngInject';

        this.$scope = $scope;

        function init() {
            $scope.$has_page_control = true;

            console.warn('Deprecation warning: validator.validateForm() will be removed from bbPage in an upcoming major release, please update your template to use bbForm and submitForm() instead. See https://github.com/bookingbug/bookingbug-angular/issues/638');
            $scope.validator = ValidatorService;

            $scope.checkReady = checkReady;
            $scope.routeReady = routeReady;
        }

        function isScopeReady(childScope) {
            var readyList = [],
                children = [],
                child = childScope.$$childHead;

            while (child) {
                children.push(child);
                child = child.$$nextSibling;
            }

            children.sort(sortChildrenScopes);

            for (var i = 0; i < children.length; i++) {
                areChildrenScopesReady(children[i], readyList);
            }

            if (childScope.hasOwnProperty('setReady')) {
                readyList.push(childScope.setReady());
            }

            return readyList;
        }

        function areChildrenScopesReady(child, readyList) {
            var ready = isScopeReady(child);
            if (angular.isArray(ready)) {
                Array.prototype.push.apply(readyList, ready);
            } else {
                readyList.push(ready);
            }
        }

        function sortChildrenScopes(a, b) {
            if ((a.ready_order || 0) >= (b.ready_order || 0)) {
                return 1;
            } else {
                return -1;
            }
        }

        /**
         * @ngdoc method
         * @name checkReady
         * @methodOf BB.Directives:bbPage
         * @description
         * Check the page ready
         */
        function checkReady() {

            var readyList = isScopeReady($scope);
            var checkReadyDefer = $q.defer();
            $scope.$checkingReady = checkReadyDefer.promise;

            readyList = readyList.filter(filterOutTrueValues);
            if (!readyList && readyList.length === 0) {
                checkReadyDefer.resolve(); //all readyList elements were 'true' values
                return true;
            }

            angular.forEach(readyList, function (readyValue) {
                if (typeof readyValue === 'boolean' && !readyValue) {
                    checkReadyDefer.reject(); // at least one readyList element was 'false' value
                    return false;
                }
            });

            var loader = LoadingService.$loader($scope).notLoaded();
            $q.all(readyList).then(function () {
                loader.setLoaded();
                checkReadyDefer.resolve();
            }, function (err) {
                loader.setLoaded();
            });

            return true;
        }

        function filterOutTrueValues(v) {
            return !(typeof v === 'boolean' && v);
        }

        /**
         * @ngdoc method
         * @name routeReady
         * @methodOf BB.Directives:bbPage
         * @description
         *
         * @param {string=} route A specific route to load
         */
        function routeReady(route) {
            if (!$scope.$checkingReady) {
                return $scope.decideNextPage(route);
            } else {
                return $scope.$checkingReady.then(function () {
                    return $scope.decideNextPage(route);
                });
            }
        }

        init();
    }
})();
'use strict';

/**
 * @ngdoc directive
 * @name BB.Directives:bbPage
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Loads a list of page for the currently in scope company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 */
(function () {
    'use strict';

    angular.module('BB').directive('bbPage', function () {
        'ngInject';

        return {
            restrict: 'AE',
            replace: true,
            scope: true,
            controller: 'BBPageCtrl',
            controllerAs: '$bbPageCtrl'
        };
    });
})();
'use strict';

angular.module('BB.Controllers').controller('PayForm', function ($scope, $location) {

    /***
     * @ngdoc method
     * @name setTotal
     * @methodOf BB.Directives:bbPayForm
     * @description
     * Set total price
     *
     * @param {array} total The total price
     */
    var payment_form = void 0;
    $scope.setTotal = function (total) {
        return $scope.total = total;
    };

    /***
     * @ngdoc method
     * @name setCard
     * @methodOf BB.Directives:bbPayForm
     * @description
     * Set card used to payment
     *
     * @param {array} card The card used to payment
     */
    $scope.setCard = function (card) {
        return $scope.card = card;
    };

    /***
     * @ngdoc method
     * @name sendSubmittingEvent
     * @methodOf BB.Directives:bbPayForm
     * @description
     * Send submitting event
     */
    var sendSubmittingEvent = function sendSubmittingEvent() {
        var referrer = $location.protocol() + "://" + $location.host();
        if ($location.port()) {
            referrer += ':' + $location.port();
        }
        var target_origin = $scope.referrer;

        var payload = JSON.stringify({
            'type': 'submitting',
            'message': referrer
        });
        return parent.postMessage(payload, target_origin);
    };

    /***
     * @ngdoc method
     * @name submitPaymentForm
     * @methodOf BB.Directives:bbPayForm
     * @description
     * Submit payment form
     */
    var submitPaymentForm = function submitPaymentForm() {
        payment_form = angular.element.find('form');
        return payment_form[0].submit();
    };

    /***
     * @ngdoc method
     * @name submitAndSendMessage
     * @methodOf BB.Directives:bbPayForm
     * @description
     * Submit and send message in according of event paramenter
     *
     * @param {object} event The event
     */
    return $scope.submitAndSendMessage = function (event) {
        event.preventDefault();
        event.stopPropagation();
        payment_form = $scope.$eval('payment_form');
        if (payment_form.$invalid) {
            payment_form.submitted = true;
            return false;
        } else {
            sendSubmittingEvent();
            return submitPaymentForm();
        }
    };
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbPayForm
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Loads a list of pay forms for the currently in scope company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @property {array} total The total pay_form price
 * @property {array} card The card is used to payment
 */ //


angular.module('BB.Directives').directive('bbPayForm', function ($window, $timeout, $sce, $http, $compile, $document, $location, GeneralOptions) {

    /**
     * @ngdoc method
     * @name applyCustomPartials
     * @methodOf BB.Directives:bbPayForm
     * @description
     * Apply the custom partials in according of custom partial url, scope and element parameters
     *
     * @param {string} custom_partial_url The custom partial url
     */
    var applyCustomPartials = function applyCustomPartials(custom_partial_url, scope, element) {
        if (custom_partial_url != null) {
            $document.domain = "bookingbug.com";
            return $http.get(custom_partial_url).then(function (custom_templates) {
                return $compile(custom_templates.data)(scope, function (custom, scope) {
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = Array.from(custom)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var e = _step.value;

                            if (e.tagName === "STYLE") {
                                element.after(e.outerHTML);
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }

                    var custom_form = function () {
                        var result = [];
                        var _iteratorNormalCompletion2 = true;
                        var _didIteratorError2 = false;
                        var _iteratorError2 = undefined;

                        try {
                            for (var _iterator2 = Array.from(custom)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                e = _step2.value;

                                if (e.id === 'payment_form') {
                                    result.push(e);
                                }
                            }
                        } catch (err) {
                            _didIteratorError2 = true;
                            _iteratorError2 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                    _iterator2.return();
                                }
                            } finally {
                                if (_didIteratorError2) {
                                    throw _iteratorError2;
                                }
                            }
                        }

                        return result;
                    }();
                    if (custom_form && custom_form[0]) {
                        return $compile(custom_form[0].innerHTML)(scope, function (compiled_form, scope) {
                            var form = element.find('form')[0];
                            var action = form.action;

                            compiled_form.attr('action', action);
                            return $(form).replaceWith(compiled_form);
                        });
                    }
                });
            });
        }
    };

    /***
     * @ngdoc method
     * @name applyCustomStylesheet
     * @methodOf BB.Directives:bbPayForm
     * @description
     * Apply the custom stylesheet from href
     *
     * @param {string} href The href of the stylesheet
     */
    var applyCustomStylesheet = function applyCustomStylesheet(href) {
        var css_id = 'custom_css';
        if (!document.getElementById(css_id)) {
            var head = document.getElementsByTagName('head')[0];
            var link = document.createElement('link');
            link.id = css_id;
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = href;
            link.media = 'all';
            head.appendChild(link);

            // listen to load of css and trigger resize
            return link.onload = function () {
                if ('parentIFrame' in $window) {
                    return parentIFrame.size();
                }
            };
        }
    };

    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'PayForm',
        link: function link(scope, element, attributes) {
            return $window.addEventListener('message', function (event) {
                var data = void 0;
                if (angular.isObject(event.data)) {
                    data = event.data;
                } else if (angular.isString(event.data) && !event.data.match(/iFrameSizer/)) {
                    data = JSON.parse(event.data);
                }
                if (data) {
                    switch (data.type) {
                        case "load":
                            return scope.$apply(function () {
                                scope.referrer = data.message;
                                if (data.custom_partial_url) {
                                    applyCustomPartials(event.data.custom_partial_url, scope, element);
                                }
                                if (data.custom_stylesheet) {
                                    applyCustomStylesheet(data.custom_stylesheet);
                                }
                                if (data.scroll_offset) {
                                    return GeneralOptions.scroll_offset = data.scroll_offset;
                                }
                            });
                    }
                }
            }, false);
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('bbPaymentButton', function ($compile, $sce, $http, $templateCache, $q, $log, TemplateSvc, $translate) {
    return {
        restrict: 'EA',
        replace: true,
        scope: {
            total: '=',
            bb: '=',
            decideNextPage: '=',
            notLoaded: '=',
            setLoaded: '='
        },
        link: function link(scope, element, attributes) {

            var getTemplate = function getTemplate(type, scope) {
                switch (type) {
                    case 'button_form':
                        return getButtonFormTemplate(scope);
                    case 'page':
                        return TemplateSvc.get("payment.html");
                    case 'location':
                        return "<a href='{{payment_link}}'>{{label}}</a>";
                    default:
                        return "";
                }
            };

            var getButtonFormTemplate = function getButtonFormTemplate(scope) {
                var src = $sce.parseAsResourceUrl('\'' + scope.payment_link + '\'')();
                return $http.get(src, {}).then(function (response) {
                    return response.data;
                });
            };

            var setClassAndValue = function setClassAndValue(scope, element, attributes) {
                var main_tag = void 0;
                switch (scope.link_type) {
                    case 'button_form':
                        {
                            var inputs = element.find("input");
                            main_tag = Array.from(inputs).filter(function (i) {
                                return $(i).attr('type') === 'submit';
                            }).map(function (i) {
                                return i;
                            })[0];
                            if (attributes.value) {
                                $(main_tag).attr('value', $translate.instant(attributes.value));
                            }
                            break;
                        }
                    case 'page':
                    case 'location':
                        {
                            main_tag = element.find("a")[0];
                            break;
                        }
                }
                if (attributes.class) {
                    return Array.from(attributes.class.split(" ")).map(function (c) {
                        return $(main_tag).addClass(c), $(element).removeClass(c);
                    });
                }
            };

            var killWatch = scope.$watch('total', function (total) {
                if (total && total.$has('new_payment')) {
                    killWatch();
                    scope.bb.payment_status = "pending";
                    scope.bb.total = scope.total;
                    scope.link_type = scope.total.$link('new_payment').type;
                    scope.label = attributes.value || "Make Payment";
                    scope.payment_link = scope.total.$href('new_payment');
                    scope.total.$href('new_payment');
                    return $q.when(getTemplate(scope.link_type, scope)).then(function (template) {
                        element.html(template).show();
                        $compile(element.contents())(scope);
                        return setClassAndValue(scope, element, attributes);
                    }, function (err) {
                        $log.warn(err.data);
                        return element.remove();
                    });
                } else {
                    element.hide();
                    return console.warn("new_payment link missing: payment configuration maybe incorrect");
                }
            });
        }
    };
});

angular.module('BB.Directives').directive('bbPaypalExpressButton', function ($compile, $sce, $http, $templateCache, $q, $log, $window, UriTemplate) {

    return {
        restrict: 'EA',
        replace: true,
        template: '<a ng-href="{{href}}" ng-click="showLoader()">Pay</a>',
        scope: {
            total: '=',
            bb: '=',
            decideNextPage: '=',
            paypalOptions: '=bbPaypalExpressButton',
            notLoaded: '='
        },
        link: function link(scope, element, attributes) {
            var total = scope.total;
            var paypalOptions = scope.paypalOptions;

            scope.href = new UriTemplate(total.$link('paypal_express').href).fillFromObject(paypalOptions);

            return scope.showLoader = function () {
                if (scope.notLoaded) {
                    return scope.notLoaded(scope);
                }
            };
        }
    };
});
'use strict';

angular.module('BB.Controllers').controller('PostcodeLookup', function ($scope, $rootScope, $q, ValidatorService, AlertService, LoadingService, $attrs) {

    angular.extend(this, new CompanyListBase($scope, $rootScope, $q, $attrs));

    var loader = LoadingService.$loader($scope);

    /***
     * @ngdoc method
     * @name searchPostcode
     * @methodOf BB.Directives:bbCompanies
     * @description
     * Search the postcode
     *
     * @param {object} form The form where postcode has been searched
     * @param {object} prms The parameters of postcode searching
     */
    $scope.searchPostcode = function (form, prms) {

        loader.notLoaded();

        var promise = ValidatorService.validatePostcode(form, prms);
        if (promise) {
            return promise.then(function () {
                $scope.bb.postcode = ValidatorService.getGeocodeResult().address_components[0].short_name;
                $scope.postcode = $scope.bb.postcode;
                var loc = ValidatorService.getGeocodeResult().geometry.location;
                return $scope.selectItem($scope.getNearestCompany({ center: loc }));
            }, function (err) {
                return loader.setLoaded();
            });
        } else {
            return loader.setLoaded();
        }
    };

    /***
     * @ngdoc method
     * @name getNearestCompany
     * @methodOf BB.Directives:bbCompanies
     * @description
     * Get nearest company in according of centre parameter
     *
     * @param {string} centre Map centre
     */
    return $scope.getNearestCompany = function (_ref) {
        var centre = _ref.centre;


        var distances = [];

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = Array.from($scope.items)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var company = _step.value;


                if (company.address.lat && company.address.long && company.live) {

                    var map_centre = {
                        lat: center.lat(),
                        long: centre.lng()
                    };

                    var company_position = {
                        lat: company.address.lat,
                        long: company.address.long
                    };

                    company.distance = GeolocationService.haversine(map_centre, company_position);

                    distances.push(company);
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        distances.sort(function (a, b) {
            return a.distance - b.distance;
        });

        return distances[0];
    };
});
'use strict';

angular.module('BB.Directives').directive('bbPostcodeLookup', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'PostcodeLookup'
    };
});
'use strict';

angular.module('BB.Controllers').controller('PurchaseTotal', function ($scope, $rootScope, $window, BBModel, $q) {

    angular.extend(this, new $window.PageController($scope, $q));

    /***
     * @ngdoc method
     * @name load
     * @methodOf BB.Directives:bbPurchaseTotal
     * @description
     * Load the total purchase by id
     *
     * @param {integer} total_id The total id of the total purchase
     */
    return $scope.load = function (total_id) {
        return $rootScope.connection_started.then(function () {
            $scope.loadingTotal = BBModel.PurchaseTotal.$query({ company: $scope.bb.company, total_id: total_id });
            return $scope.loadingTotal.then(function (total) {
                return $scope.total = total;
            });
        });
    };
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbPurchaseTotal
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Loads a list of purchase total for the currently in scope company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @property {array} total The total purchase
 */ //


angular.module('BB.Directives').directive('bbPurchaseTotal', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'PurchaseTotal'
    };
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbSkipDecideNextPage
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Disables the auto decide next page inside the widget controllers
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @property {string} target widget directive name, e.g. bb-times
 */ //


angular.module('BB.Directives').directive('bbSkipDecideNextPage', function (bbWidgetPage) {

    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        link: function link(scope, element, attrs) {

            if (attrs.bbSkipDecideNextPage) bbWidgetPage.setAutoDecideNextPage(attrs.bbSkipDecideNextPage, false);else console.warn("Warning: you forgot to use the bb-skip-decide-next-page=\"directive-name\" notation");
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('bbToggleEdit', function ($compile, $window, $document) {
    return {
        restrict: 'AE',
        link: function link(scope, element, attr) {
            scope.editing = false;
            element.on('dblclick', function (event) {
                return scope.$apply(function () {
                    return scope.editing = true;
                });
            });

            $document.on('click', function () {
                if (!element.is(':hover')) {
                    return scope.$apply(function () {
                        return scope.editing = false;
                    });
                }
            });

            return true;
        }
    };
});
'use strict';

(function () {

    'use strict';

    angular.module('BB.Controllers').controller('BBCtrl', BBCtrl);

    function BBCtrl(routeStates, $scope, $rootScope, QueryStringService, LoadingService, viewportSize, bbWidgetBasket, bbWidgetPage, bbWidgetStep, bbWidgetInit, bbWidgetUtilities) {

        bbWidgetBasket.setScope($scope);
        bbWidgetPage.setScope($scope);
        bbWidgetStep.setScope($scope);
        bbWidgetInit.setScope($scope);
        bbWidgetUtilities.setScope($scope);

        this.$scope = $scope;

        $scope.cid = "BBCtrl";
        $scope.qs = QueryStringService;
        $scope.company_api_path = '/api/v1/company/{company_id}{?embed,category_id}';
        $scope.company_admin_api_path = '/api/v1/admin/{company_id}/company{?embed,category_id}';
        $rootScope.Route = $scope.Route = routeStates;

        this.$onInit = function () {
            //Initialization
            bbWidgetInit.initializeBBWidget();
            $scope.initWidget = bbWidgetInit.initWidget;
            //Steps
            $scope.checkStepTitle = bbWidgetStep.checkStepTitle;
            $scope.getCurrentStepTitle = bbWidgetStep.getCurrentStepTitle;
            $scope.loadPreviousStep = bbWidgetStep.loadPreviousStep;
            $scope.loadStep = bbWidgetStep.loadStep;
            $scope.loadStepByPageName = bbWidgetStep.loadStepByPageName;
            $scope.reset = bbWidgetStep.reset;
            $scope.restart = bbWidgetStep.restart;
            $scope.setLastSelectedDate = bbWidgetStep.setLastSelectedDate;
            $scope.setStepTitle = bbWidgetStep.setStepTitle;
            $scope.skipThisStep = bbWidgetStep.skipThisStep;
            //Pages
            $scope.clearPage = bbWidgetPage.clearPage;
            $scope.decideNextPage = bbWidgetPage.decideNextPage;
            $scope.hidePage = bbWidgetPage.hidePage;
            $scope.isLoadingPage = bbWidgetPage.isLoadingPage;
            $scope.jumpToPage = bbWidgetPage.jumpToPage;
            $scope.setLoadingPage = bbWidgetPage.setLoadingPage;
            $scope.setPageLoaded = bbWidgetPage.setPageLoaded;
            $scope.setPageRoute = bbWidgetPage.setPageRoute;
            $scope.showPage = bbWidgetPage.showPage;
            //Basket
            $scope.addItemToBasket = bbWidgetBasket.addItemToBasket;
            $scope.clearBasketItem = bbWidgetBasket.clearBasketItem;
            $scope.deleteBasketItem = bbWidgetBasket.deleteBasketItem;
            $scope.deleteBasketItems = bbWidgetBasket.deleteBasketItems;
            $scope.emptyBasket = bbWidgetBasket.emptyBasket;
            $scope.moveToBasket = bbWidgetBasket.moveToBasket;
            $scope.quickEmptybasket = bbWidgetBasket.quickEmptybasket;
            $scope.setBasket = bbWidgetBasket.setBasket;
            $scope.setBasketItem = bbWidgetBasket.setBasketItem;
            $scope.updateBasket = bbWidgetBasket.updateBasket;
            $scope.setUsingBasket = bbWidgetBasket.setUsingBasket;

            $scope.setClient = bbWidgetInit.setClient;
            $scope.clearClient = bbWidgetInit.clearClient;
            $scope.setCompany = bbWidgetInit.setCompany;
            $scope.setAffiliate = bbWidgetInit.setAffiliate;

            $scope.isAdmin = bbWidgetUtilities.isAdmin;
            $scope.isAdminIFrame = bbWidgetUtilities.isAdminIFrame;
            $scope.base64encode = bbWidgetUtilities.base64encode;
            $scope.$debounce = bbWidgetUtilities.$debounce;
            $scope.parseDate = moment;
            $scope.supportsTouch = bbWidgetUtilities.supportsTouch;
            $scope.scrollTo = bbWidgetUtilities.scrollTo;
            $scope.redirectTo = bbWidgetUtilities.redirectTo;
            $scope.areScopesLoaded = LoadingService.areScopesLoaded;

            $scope.broadcastItemUpdate = bbWidgetUtilities.broadcastItemUpdate;
            $scope.getPartial = bbWidgetUtilities.getPartial;
            $scope.getUrlParam = bbWidgetUtilities.getUrlParam;
            $scope.setLoaded = LoadingService.setLoaded;
            $scope.setLoadedAndShowError = LoadingService.setLoadedAndShowError;
            $scope.isMemberLoggedIn = bbWidgetUtilities.isMemberLoggedIn;
            $scope.logout = bbWidgetUtilities.logout;
            $scope.notLoaded = LoadingService.notLoaded;
            $scope.reloadDashboard = bbWidgetUtilities.reloadDashboard;
            $scope.setReadyToCheckout = bbWidgetBasket.setReadyToCheckout;
            $scope.setRoute = bbWidgetUtilities.setRoute;

            $scope.showCheckout = bbWidgetBasket.showCheckout;
            $rootScope.$on('show:loader', bbWidgetUtilities.showLoaderHandler);
            $rootScope.$on('hide:loader', bbWidgetUtilities.hideLoaderHandler);
            $scope.$on('$locationChangeStart', bbWidgetUtilities.locationChangeStartHandler);
        };

        this.$postLink = function () {
            viewportSize.init();
        };
    }
})();
'use strict';

(function () {

    'use strict';

    /**
     * @ngdoc directive
     * @name BB.Directives:bbWidget
     * @restrict A
     * @scope
     *   client: '=?'
     *   apiUrl: '@?'
     *   useParent:'='
     * @description
     *
     * Loads a list of widgets for the currently in scope company
     *
     * <pre>
     * restrict: 'A'
     * scope:
     *   client: '=?'
     *   apiUrl: '@?'
     *   useParent:'='
     * transclude: true
     * </pre>
     *
     * @param {hash} bbWidget A hash of options
     * @property {string} pusher The pusher
     * @property {string} pusher_channel The pusher channel
     * @property {string} init_params Initialization of basic parameters
     */

    angular.module('BB.Directives').directive('bbWidget', BBWidget);

    function BBWidget($http, $templateCache, $compile, $q, AppConfig, $timeout, $bbug, $rootScope, AppService, bbConfig) {

        var DEFAULT_TEMPLATE = "main";

        /**
         * @ngdoc method
         * @name getTemplate
         * @methodOf BB.Directives:bbWidget
         * @description
         * Get template
         *
         * @param {object} template The template
         */
        var getTemplate = function getTemplate(template) {
            var partial = template ? template : DEFAULT_TEMPLATE;
            return $templateCache.get(partial + '.html');
        };

        /**
         * @ngdoc method
         * @name updatePartials
         * @methodOf BB.Directives:bbWidget
         * @description
         * Update partials
         *
         * @param {object} prms The parameter
         */
        var updatePartials = function updatePartials(scope, element, prms) {
            var i, j, len, ref;
            ref = element.children();
            for (j = 0, len = ref.length; j < len; j++) {
                i = ref[j];
                if ($bbug(i).hasClass('custom_partial')) {
                    $bbug(i).remove();
                }
            }
            return appendCustomPartials(scope, element, prms).then(function () {
                return scope.$broadcast('refreshPage');
            });
        };

        /**
         * @ngdoc method
         * @name setupPusher
         * @methodOf BB.Directives:bbWidget
         * @description
         * Push setup
         *
         * @param {object} prms The parameter
         */
        var setupPusher = function setupPusher(scope, element, prms) {
            return $timeout(function () {
                scope.pusher = new Pusher('c8d8cea659cc46060608');
                scope.pusher_channel = scope.pusher.subscribe("widget_" + prms.design_id);
                return scope.pusher_channel.bind('update', function (data) {
                    return updatePartials(scope, element, prms);
                });
            });
        };

        /**
         * @ngdoc method
         * @name appendCustomPartials
         * @methodOf BB.Directives:bbWidget
         * @description
         * Appent custom partials
         *
         * @param {object} prms The parameter
         */
        var appendCustomPartials = function appendCustomPartials(scope, element, prms) {
            var defer;
            defer = $q.defer();
            $http.get(prms.custom_partial_url).then(function (custom_templates) {
                return $compile(custom_templates.data)(scope, function (custom, scope) {
                    var non_style, style, tag;
                    custom.addClass('custom_partial');
                    style = function () {
                        var j, len, results;
                        results = [];
                        for (j = 0, len = custom.length; j < len; j++) {
                            tag = custom[j];
                            if (tag.tagName === "STYLE") {
                                results.push(tag);
                            }
                        }
                        return results;
                    }();
                    non_style = function () {
                        var j, len, results;
                        results = [];
                        for (j = 0, len = custom.length; j < len; j++) {
                            tag = custom[j];
                            if (tag.tagName !== "STYLE") {
                                results.push(tag);
                            }
                        }
                        return results;
                    }();
                    $bbug("#widget_" + prms.design_id).html(non_style);
                    element.append(style);
                    scope.bb.path_setup = true;
                    return defer.resolve(style);
                });
            });
            return defer.promise;
        };

        /**
         * @ngdoc method
         * @name renderTemplate
         * @methodOf BB.Directives:bbWidget
         * @description
         * Render template
         *
         * @param {object} design_mode The design mode
         * @param {object} template The template
         */
        var renderTemplate = function renderTemplate(scope, element, design_mode, template) {
            return $q.when(getTemplate(template)).then(function (template) {
                element.html(template).show();
                if (design_mode) {
                    element.append('<style widget_css scoped></style>');
                }
                return $compile(element.contents())(scope);
            });
        };
        var link = function link(scope, element, attrs, controller, transclude) {
            var evaluator, init_params, _notInModal;
            if (attrs.member != null) {
                scope.client = attrs.member;
            }
            evaluator = scope;
            if (scope.useParent && scope.$parent != null) {
                evaluator = scope.$parent;
            }
            init_params = evaluator.$eval(attrs.bbWidget);

            /*
             Initializing the Bookingbug Widget
             */

            scope.initWidget(init_params);

            /*
             Loading the template-config by configuration
             */

            if (bbConfig && bbConfig.ROUTES) {
                for (var template in bbConfig.ROUTES) {
                    if (init_params.template === template.toLowerCase()) {
                        var _ret = function () {
                            var routes = [];
                            bbConfig.ROUTES[template].forEach(function (pageConfig) {
                                var config = {};
                                for (var attr in pageConfig) {
                                    config[attr.toLowerCase()] = pageConfig[attr];
                                }
                                routes.push(config);
                            });
                            scope.setRoute(routes);
                            return 'break';
                        }();

                        if (_ret === 'break') break;
                    }
                }
            }

            $rootScope.widget_started.then(function (_this) {
                return function () {
                    var prms;
                    prms = scope.bb;
                    if (prms.custom_partial_url) {
                        prms.design_id = prms.custom_partial_url.match(/^.*\/(.*?)$/)[1];
                        $bbug("[ng-app='BB']").append("<div id='widget_" + prms.design_id + "'></div>");
                    }
                    if (scope.bb.partial_url) {
                        if (init_params.partial_url) {
                            AppConfig['partial_url'] = init_params.partial_url;
                        } else {
                            AppConfig['partial_url'] = scope.bb.partial_url;
                        }
                    }
                    return transclude(scope, function (clone) {
                        scope.has_content = clone.length > 1 || clone.length === 1 && (!clone[0].wholeText || /\S/.test(clone[0].wholeText));
                        if (!scope.has_content) {
                            if (prms.custom_partial_url) {
                                appendCustomPartials(scope, element, prms).then(function (style) {
                                    return $q.when(getTemplate()).then(function (template) {
                                        element.html(template).show();
                                        $compile(element.contents())(scope);
                                        element.append(style);
                                        if (prms.update_design) {
                                            return setupPusher(scope, element, prms);
                                        }
                                    });
                                });
                            } else if (prms.template) {
                                renderTemplate(scope, element, prms.design_mode, prms.template);
                            } else {
                                renderTemplate(scope, element, prms.design_mode);
                            }
                            return scope.$on('refreshPage', function () {
                                return renderTemplate(scope, element, prms.design_mode, prms.template);
                            });
                        } else if (prms.custom_partial_url) {
                            appendCustomPartials(scope, element, prms);
                            if (prms.update_design) {
                                setupPusher(scope, element, prms);
                            }
                            return scope.$on('refreshPage', function () {
                                return scope.showPage(scope.bb.current_page);
                            });
                        } else {
                            element.html(clone).show();
                            if (prms.design_mode) {
                                return element.append('<style widget_css scoped></style>');
                            }
                        }
                    });
                };
            }(this));
            _notInModal = function notInModal(p) {
                if (p.length === 0 || p[0].attributes === void 0) {
                    return true;
                } else if (p[0].attributes['uib-modal-window'] !== void 0) {
                    return false;
                } else {
                    if (p.parent().length === 0) {
                        return true;
                    } else {
                        return _notInModal(p.parent());
                    }
                }
            };
            scope.$watch(function () {
                return AppService.isModalOpen();
            }, function (modalOpen) {
                return scope.coveredByModal = modalOpen && _notInModal(element.parent());
            });
        };

        return {
            restrict: 'A',
            scope: {
                client: '=?',
                apiUrl: '@?',
                useParent: '='
            },
            transclude: true,
            controller: 'BBCtrl',
            controllerAs: '$bbCtrl',
            link: link
        };
    }
})();
'use strict';

(function () {

    'use strict';

    /**
     * @ngdoc service
     * @name BB.Models:BBWidget
     *
     * @description
     * Representation of an BBWidget Object
     *
     * @property {integer} uid The unique id of the widget
     * @property {string} page_suffix Widget page suffix
     * @property {array} steps The widget steps
     * @property {array} allSteps The all steps of the widget
     * @property {object} item_defaults Widget defaults item
     * @property {boolean} Checks if widget using basket or not
     * @property {boolean} confirmCheckout Checks if widget confirm is checkout or not
     * @property {boolean} isAdm,in Verify if user is admin
     * @property {string} payment_status The payment status
     */

    angular.module('BB.Models').service('BBWidget', BBWidget);

    function BBWidget($q, BBModel, $urlMatcherFactory, $location, BreadcrumbService, PathHelper, GeneralOptions, $translate) {

        function Widget() {
            this.uid = _.uniqueId('bbwidget_');
            this.page_suffix = "";
            this.steps = [];
            this.allSteps = [];
            this.item_defaults = {};
            this.usingBasket = false;
            this.confirmCheckout = false;
            this.isAdmin = false;
            this.payment_status = null;
        }

        Widget.prototype.pageURL = function (route) {
            return route + '.html';
        };
        Widget.prototype.updateRoute = function (page) {
            var company, date, event, event_group, pattern, prms, service_name, time, url;
            if (!this.routeFormat) {
                return;
            }
            page || (page = this.current_page);
            pattern = $urlMatcherFactory.compile(this.routeFormat);
            service_name = "-";
            event_group = "-";
            event = "-";
            if (this.current_item) {
                if (this.current_item.service) {
                    service_name = this.convertToDashSnakeCase(this.current_item.service.name);
                }
                if (this.current_item.event_group) {
                    event_group = this.convertToDashSnakeCase(this.current_item.event_group.name);
                }
                if (this.current_item.event) {
                    event = this.current_item.event.id;
                }
                if (this.current_item.date) {
                    date = this.current_item.date.date;
                }
                if (date && moment.isMoment(date)) {
                    date = date.toISODate();
                }
                if (this.current_item.time) {
                    time = this.current_item.time.time;
                }
                if (this.current_item.company) {
                    company = this.convertToDashSnakeCase(this.current_item.company.name);
                } else {
                    console.log('%c bb_warning: Make sure you are using a valid company_id', 'background: #c0392b; color: #fff');
                }
            }
            if (this.route_values) {
                prms = angular.copy(this.route_values);
            }
            prms || (prms = {});
            angular.extend(prms, {
                page: page,
                company: company,
                service: service_name,
                event_group: event_group,
                date: date,
                time: time,
                event: event
            });
            url = pattern.format(prms);
            url = url.replace(/\/+$/, "");
            $location.path(url);
            this.routing = true;
            return url;
        };
        Widget.prototype.setRouteFormat = function (route) {
            var match;
            this.routeFormat = route;
            if (!this.routeFormat) {
                return;
            }
            this.routing = true;
            match = PathHelper.matchRouteToPath(this.routeFormat);
            if (match) {
                if (match.company) {
                    this.item_defaults.company = decodeURIComponent(match.company);
                }
                if (match.service && match.service !== "-") {
                    this.item_defaults.service = decodeURIComponent(match.service);
                }
                if (match.event_group && match.event_group !== "-") {
                    this.item_defaults.event_group = match.event_group;
                }
                if (match.event && match.event !== "-") {
                    this.item_defaults.event = decodeURIComponent(match.event);
                }
                if (match.person) {
                    this.item_defaults.person = decodeURIComponent(match.person);
                }
                if (match.resource) {
                    this.item_defaults.resource = decodeURIComponent(match.resource);
                }
                if (match.resources) {
                    this.item_defaults.resources = decodeURIComponent(match.resoures);
                }
                if (match.date) {
                    this.item_defaults.date = match.date;
                }
                if (match.time) {
                    this.item_defaults.time = parseInt(match.time);
                }
                return this.route_matches = match;
            }
        };
        Widget.prototype.matchURLToStep = function () {
            var page, step;
            page = PathHelper.matchRouteToPath(this.routeFormat, 'page');
            step = _.findWhere(this.allSteps, {
                page: page
            });
            if (step) {
                return step.number;
            } else {
                return null;
            }
        };
        Widget.prototype.convertToDashSnakeCase = function (str) {
            str = str.toLowerCase();
            str = $.trim(str);
            str = str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|'’!<>;:,.~`=+-@£&%"]/g, '');
            str = str.replace(/\s{2,}/g, ' ');
            str = str.replace(/\s/g, '-');
            return str;
        };
        Widget.prototype.recordCurrentPage = function () {
            var j, k, l, len, len1, len2, match, ref, ref1, ref2, setDocumentTitle, step, title;
            setDocumentTitle = function setDocumentTitle(title) {
                if (GeneralOptions.update_document_title && title) {
                    return document.title = $translate.instant(title);
                }
            };
            if (!this.current_step) {
                this.current_step = 0;
            }
            match = false;
            if (this.allSteps) {
                ref = this.allSteps;
                for (j = 0, len = ref.length; j < len; j++) {
                    step = ref[j];
                    if (step.page === this.current_page) {
                        this.current_step = step.number;
                        setDocumentTitle(step.title);
                        match = true;
                    }
                }
            }
            if (!match) {
                ref1 = this.steps;
                for (k = 0, len1 = ref1.length; k < len1; k++) {
                    step = ref1[k];
                    if (step && step.page === this.current_page) {
                        this.current_step = step.number;
                        setDocumentTitle(step.title);
                        match = true;
                    }
                }
            }
            if (!match) {
                this.current_step += 1;
            }
            title = "";
            if (this.allSteps) {
                ref2 = this.allSteps;
                for (l = 0, len2 = ref2.length; l < len2; l++) {
                    step = ref2[l];
                    step.active = false;
                    step.passed = step.number < this.current_step;
                }
                if (this.allSteps[this.current_step - 1]) {
                    this.allSteps[this.current_step - 1].active = true;
                    title = this.allSteps[this.current_step - 1].title;
                }
            }
            return this.recordStep(this.current_step, title);
        };
        Widget.prototype.recordStep = function (step_number, title) {
            var j, len, ref, step;
            this.steps[step_number - 1] = {
                url: this.updateRoute(this.current_page),
                current_item: this.current_item.getStep(),
                page: this.current_page,
                number: step_number,
                title: title,
                stacked_length: this.stacked_items.length
            };
            BreadcrumbService.setCurrentStep(step_number);
            ref = this.steps;
            for (j = 0, len = ref.length; j < len; j++) {
                step = ref[j];
                if (step) {
                    step.passed = step.number < this.current_step;
                    step.active = step.number === this.current_step;
                }
                if (step && step.number === step_number) {
                    this.calculatePercentageComplete(step.number);
                }
            }
            if (this.allSteps && this.allSteps.length === step_number || this.current_page === 'checkout') {
                return this.last_step_reached = true;
            } else {
                return this.last_step_reached = false;
            }
        };
        Widget.prototype.calculatePercentageComplete = function (step_number) {
            return this.percentage_complete = step_number && this.allSteps ? step_number / this.allSteps.length * 100 : 0;
        };
        Widget.prototype.setRoute = function (rdata) {
            var i, j, k, len, len1, ref, route, step;
            this.allSteps.length = 0;
            this.nextSteps = {};
            if (!(rdata === void 0 || rdata === null || rdata[0] === void 0)) {
                this.firstStep = rdata[0].page;
            }
            for (i = j = 0, len = rdata.length; j < len; i = ++j) {
                step = rdata[i];
                if (step.disable_breadcrumbs) {
                    this.disableGoingBackAtStep = i + 1;
                }
                if (rdata[i + 1]) {
                    this.nextSteps[step.page] = rdata[i + 1].page;
                }
                this.allSteps.push({
                    number: i + 1,
                    title: step.title,
                    page: step.page
                });
                if (step.when) {
                    this.routeSteps || (this.routeSteps = {});
                    ref = step.when;
                    for (k = 0, len1 = ref.length; k < len1; k++) {
                        route = ref[k];
                        this.routeSteps[route] = step.page;
                    }
                }
            }
            if (this.$wait_for_routing) {
                return this.$wait_for_routing.resolve();
            }
        };
        Widget.prototype.waitForRoutes = function () {
            if (!this.$wait_for_routing) {
                return this.$wait_for_routing = $q.defer();
            }
        };
        Widget.prototype.stackItem = function (item) {
            this.stacked_items.push(item);
            this.sortStackedItems();
            if (this.stacked_items.length === 1) {
                return this.current_item = item;
            }
        };
        Widget.prototype.setStackedItems = function (items) {
            this.stacked_items = items;
            return this.sortStackedItems();
        };
        Widget.prototype.sortStackedItems = function () {
            var arr, item, j, len, ref;
            arr = [];
            ref = this.stacked_items;
            for (j = 0, len = ref.length; j < len; j++) {
                item = ref[j];
                arr = arr.concat(item.promises);
            }
            return $q.all(arr)['finally'](function (_this) {
                return function () {
                    return _this.stacked_items = _this.stacked_items.sort(function (a, b) {
                        var ref1, ref2;
                        if (a.time && b.time) {
                            return (ref1 = a.time.time > b.time.time) != null ? ref1 : {
                                1: -1
                            };
                        } else if (a.service.category && !b.service.category) {
                            return 1;
                        } else if (b.service.category && !a.service.category) {
                            return -1;
                        } else if (!b.service.category && !a.service.category) {
                            return 1;
                        } else {
                            return (ref2 = a.service.category.order > b.service.category.order) != null ? ref2 : {
                                1: -1
                            };
                        }
                    });
                };
            }(this));
        };
        Widget.prototype.deleteStackedItem = function (item) {
            if (item && item.id) {
                BBModel.Basket.$deleteItem(item, this.company, {
                    bb: this
                });
            }
            return this.stacked_items = this.stacked_items.filter(function (i) {
                return i !== item;
            });
        };
        Widget.prototype.removeItemFromStack = function (item) {
            return this.stacked_items = this.stacked_items.filter(function (i) {
                return i !== item;
            });
        };
        Widget.prototype.deleteStackedItemByService = function (item) {
            var i, j, len, ref;
            ref = this.stacked_items;
            for (j = 0, len = ref.length; j < len; j++) {
                i = ref[j];
                if (i && i.service && i.service.self === item.self && i.id) {
                    BBModel.Basket.$deleteItem(i, this.company, {
                        bb: this
                    });
                }
            }
            return this.stacked_items = this.stacked_items.filter(function (i) {
                return i && i.service && i.service.self !== item.self;
            });
        };
        Widget.prototype.emptyStackedItems = function () {
            return this.stacked_items = [];
        };
        Widget.prototype.pushStackToBasket = function () {
            var i, j, len, ref;
            this.basket || (this.basket = new BBModel.Basket(null, this));
            ref = this.stacked_items;
            for (j = 0, len = ref.length; j < len; j++) {
                i = ref[j];
                this.basket.addItem(i);
            }
            return this.emptyStackedItems();
        };
        Widget.prototype.totalStackedItemsDuration = function () {
            var duration, item, j, len, ref;
            duration = 0;
            ref = this.stacked_items;
            for (j = 0, len = ref.length; j < len; j++) {
                item = ref[j];
                if (item.service && item.service.listed_duration) {
                    duration += item.service.listed_duration;
                }
            }
            return duration;
        };
        Widget.prototype.clearStackedItemsDateTime = function () {
            var item, j, len, ref, results;
            ref = this.stacked_items;
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
                item = ref[j];
                results.push(item.clearDateTime());
            }
            return results;
        };
        Widget.prototype.clearAddress = function () {
            delete this.address1;
            delete this.address2;
            delete this.address3;
            delete this.address4;
            return delete this.address5;
        };

        return Widget;
    }
})();
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

(function () {

    'use strict';

    angular.module('BB.Services').service('bbWidgetBasket', BBWidgetBasket);

    function BBWidgetBasket($q, $rootScope, halClient, BBModel, $localStorage, $sessionStorage, bbWidgetPage, bbWidgetStep, $uibModal, bbWidgetUtilities, ErrorService, LoginService, $log) {

        var $scope = null;
        var setScope = function setScope($s) {
            $scope = $s;
        };
        var guardScope = function guardScope() {
            if ($scope === null) {
                throw new Error('please provide scope');
            }
        };
        var deleteBasketItems = function deleteBasketItems(items) {
            guardScope();
            var item, j, len, results;
            results = [];
            for (j = 0, len = items.length; j < len; j++) {
                item = items[j];
                results.push(BBModel.Basket.$deleteItem(item, $scope.bb.company, {
                    bb: $scope.bb
                }).then(function (basket) {
                    return setBasket(basket);
                }));
            }
            return results;
        };
        var setBasketItem = function setBasketItem(item) {
            guardScope();
            return $scope.bb.current_item = item;
        };
        var clearBasketItem = function clearBasketItem() {
            guardScope();
            var def;
            def = $q.defer();
            $scope.bb.current_item = new BBModel.BasketItem(null, $scope.bb);
            if ($scope.bb.default_setup_promises) {
                $q.all($scope.bb.default_setup_promises)["finally"](function () {
                    $scope.bb.current_item.setDefaults($scope.bb.item_defaults);
                    return $q.all($scope.bb.current_item.promises)["finally"](function () {
                        return def.resolve();
                    });
                });
            } else {
                $scope.bb.current_item.setDefaults({});
                def.resolve();
            }
            return def.promise;
        };
        var setBasket = function setBasket(basket) {
            guardScope();
            $scope.bb.basket = basket;
            $scope.basket = basket;
            $scope.bb.basket.company_id = $scope.bb.company_id;
            if ($scope.bb.stacked_items) {
                return $scope.bb.setStackedItems(basket.timeItems());
            }
        };
        var updateBasket = function updateBasket() {
            guardScope();
            var add_defer, current_item_ref, params;
            current_item_ref = $scope.bb.current_item.ref;
            add_defer = $q.defer();
            params = {
                member_id: $scope.client.id,
                member: $scope.client,
                items: $scope.bb.basket.items,
                bb: $scope.bb
            };
            BBModel.Basket.$updateBasket($scope.bb.company, params).then(function (basket) {
                var current_item, item, j, len, ref;
                ref = basket.items;
                for (j = 0, len = ref.length; j < len; j++) {
                    item = ref[j];
                    item.storeDefaults($scope.bb.item_defaults);
                }
                halClient.clearCache("time_data");
                halClient.clearCache("events");
                basket.setSettings($scope.bb.basket.settings);
                setBasket(basket);
                current_item = _.find(basket.items, function (item) {
                    return item.ref === current_item_ref;
                });
                if (!current_item) {
                    current_item = _.last(basket.items);
                }

                $scope.bb.current_item = current_item;

                if (!$scope.bb.current_item) {
                    clearBasketItem().then(function () {
                        add_defer.resolve(basket);
                    });
                } else {
                    add_defer.resolve(basket);
                }
            }, function (err) {
                var error_modal;
                add_defer.reject(err);
                if (err.status === 409) {
                    halClient.clearCache("time_data");
                    halClient.clearCache("events");
                    $scope.bb.current_item.person = null;
                    error_modal = $uibModal.open({
                        templateUrl: bbWidgetUtilities.getPartial('_error_modal'),
                        controller: function controller($scope, $uibModalInstance) {
                            $scope.message = ErrorService.getError('ITEM_NO_LONGER_AVAILABLE').msg;
                            $scope.ok = function () {
                                return $uibModalInstance.close();
                            };
                        }
                    });
                    error_modal.result.then(function () {
                        if ($scope.bb.on_conflict) {
                            $scope.$eval($scope.bb.on_conflict);
                        } else {
                            if ($scope.bb.nextSteps) {
                                if (!bbWidgetPage.setPageRoute($rootScope.Route.Date) && !bbWidgetPage.setPageRoute($rootScope.Route.Event)) {
                                    bbWidgetStep.loadPreviousStep();
                                }
                            } else {
                                bbWidgetPage.decideNextPage();
                            }
                        }
                    });
                }
            });
            return add_defer.promise;
        };

        var createBasketFromBookings = function createBasketFromBookings(bookings, client, totalDefer) {
            // set a basket item from each booking
            var proms = [];
            var readyBookings = [];
            bookings.forEach(function (booking) {
                var newBookingItem = new BBModel.BasketItem(booking, $scope.bb);
                newBookingItem.setSrcBooking(booking, $scope.bb);
                proms.push.apply(proms, _toConsumableArray(newBookingItem.promises));
                $scope.bb.basket.addItem(newBookingItem);
                readyBookings.push(newBookingItem);
            });

            // set current_item if we only have one booking
            if (bookings.length === 1) {
                $scope.bb.current_item = readyBookings[0];
                $scope.bb.current_item.setDefaults({});
                $scope.setClient(client);
            }

            $scope.bb.moving_booking = readyBookings;

            $q.all(proms).then(function () {
                return totalDefer.resolve();
            }, function (err) {
                $log.info(err);
                return totalDefer.reject(err);
            });
        };

        var deleteBasketItem = function deleteBasketItem(item) {
            guardScope();
            return BBModel.Basket.$deleteItem(item, $scope.bb.company, {
                bb: $scope.bb
            }).then(function (basket) {
                return setBasket(basket);
            });
        };
        var emptyBasket = function emptyBasket() {
            guardScope();
            var defer;
            defer = $q.defer();
            if (!$scope.bb.basket.items || $scope.bb.basket.items && $scope.bb.basket.items.length === 0) {
                defer.resolve();
            } else {
                BBModel.Basket.$empty($scope.bb).then(function (basket) {
                    if ($scope.bb.current_item.id) {
                        delete $scope.bb.current_item.id;
                    }
                    setBasket(basket);
                    return defer.resolve();
                }, function (err) {
                    return defer.reject();
                });
            }
            return defer.promise;
        };
        var addItemToBasket = function addItemToBasket() {
            guardScope();
            var add_defer;
            add_defer = $q.defer();
            if (!$scope.bb.current_item.submitted && !$scope.bb.moving_booking) {
                moveToBasket();
                $scope.bb.current_item.submitted = updateBasket();
                $scope.bb.current_item.submitted.then(function (basket) {
                    return add_defer.resolve(basket);
                }, function (err) {
                    if (err.status === 409) {
                        $scope.bb.current_item.person = null;
                        $scope.bb.current_item.resource = null;
                        $scope.bb.current_item.setTime(null);
                        if ($scope.bb.current_item.service) {
                            $scope.bb.current_item.setService($scope.bb.current_item.service);
                        }
                    }
                    $scope.bb.current_item.submitted = null;
                    return add_defer.reject(err);
                });
            } else if ($scope.bb.current_item.submitted) {
                return $scope.bb.current_item.submitted;
            } else {
                add_defer.resolve();
            }
            return add_defer.promise;
        };
        var moveToBasket = function moveToBasket() {
            guardScope();
            return $scope.bb.basket.addItem($scope.bb.current_item);
        };
        var quickEmptybasket = function quickEmptybasket(options) {
            guardScope();
            var def, preserve_stacked_items;
            preserve_stacked_items = options && options.preserve_stacked_items ? true : false;
            if (!preserve_stacked_items) {
                $scope.bb.stacked_items = [];
                setBasket(new BBModel.Basket(null, $scope.bb));
                return clearBasketItem();
            } else {
                $scope.bb.basket = new BBModel.Basket(null, $scope.bb);
                $scope.basket = $scope.bb.basket;
                $scope.bb.basket.company_id = $scope.bb.company_id;
                def = $q.defer();
                def.resolve();
                return def.promise;
            }
        };
        var restoreBasket = function restoreBasket() {
            guardScope();
            var restore_basket_defer;
            restore_basket_defer = $q.defer();
            quickEmptybasket().then(function () {
                var auth_token, href, params, status, uri;
                auth_token = $localStorage.getItem('auth_token') || $sessionStorage.getItem('auth_token');
                href = $scope.bb.api_url + '/api/v1/status{?company_id,affiliate_id,clear_baskets,clear_member}';
                params = {
                    company_id: $scope.bb.company_id,
                    affiliate_id: $scope.bb.affiliate_id,
                    clear_baskets: $scope.bb.clear_basket ? '1' : null,
                    clear_member: $scope.bb.clear_member ? '1' : null
                };
                uri = new UriTemplate(href).fillFromObject(params);
                status = halClient.$get(uri, {
                    "auth_token": auth_token,
                    "no_cache": true
                });
                return status.then(function (_this) {
                    return function (res) {
                        if (res.$has('client')) {
                            res.$get('client').then(function (client) {
                                if (!$scope.client || $scope.client && !$scope.client.valid()) {
                                    return $scope.client = new BBModel.Client(client);
                                }
                            });
                        }
                        if (res.$has('member')) {
                            res.$get('member').then(function (member) {
                                if (member.client_type !== 'Contact') {
                                    member = LoginService.setLogin(member);
                                    return $scope.setClient(member);
                                }
                            });
                        }
                        if ($scope.bb.clear_basket) {
                            return restore_basket_defer.resolve();
                        } else {
                            if (res.$has('baskets')) {
                                return res.$get('baskets').then(function (baskets) {
                                    var basket;
                                    basket = _.find(baskets, function (b) {
                                        return parseInt(b.company_id) === $scope.bb.company_id;
                                    });
                                    if (basket) {
                                        basket = new BBModel.Basket(basket, $scope.bb);
                                        return basket.$get('items').then(function (items) {
                                            var i, j, len, promises;
                                            items = function () {
                                                var j, len, results;
                                                results = [];
                                                for (j = 0, len = items.length; j < len; j++) {
                                                    i = items[j];
                                                    results.push(new BBModel.BasketItem(i));
                                                }
                                                return results;
                                            }();
                                            for (j = 0, len = items.length; j < len; j++) {
                                                i = items[j];
                                                basket.addItem(i);
                                            }
                                            setBasket(basket);
                                            promises = [].concat.apply([], function () {
                                                var l, len1, results;
                                                results = [];
                                                for (l = 0, len1 = items.length; l < len1; l++) {
                                                    i = items[l];
                                                    results.push(i.promises);
                                                }
                                                return results;
                                            }());
                                            return $q.all(promises).then(function () {
                                                if (basket.items.length > 0) {
                                                    $scope.bb.current_item = basket.items[0];
                                                }
                                                return restore_basket_defer.resolve();
                                            });
                                        });
                                    } else {
                                        return restore_basket_defer.resolve();
                                    }
                                });
                            } else {
                                return restore_basket_defer.resolve();
                            }
                        }
                    };
                }(this), function (err) {
                    return restore_basket_defer.resolve();
                });
            });
            return restore_basket_defer.promise;
        };
        var setUsingBasket = function setUsingBasket(usingBasket) {
            return $scope.bb.usingBasket = usingBasket;
        };
        var showCheckout = function showCheckout() {
            guardScope();
            return $scope.bb.current_item.ready;
        };
        var setReadyToCheckout = function setReadyToCheckout(ready) {
            guardScope();
            return $scope.bb.confirmCheckout = ready;
        };

        return {
            setScope: setScope,
            deleteBasketItems: deleteBasketItems,
            createBasketFromBookings: createBasketFromBookings,
            setBasketItem: setBasketItem,
            clearBasketItem: clearBasketItem,
            setBasket: setBasket,
            updateBasket: updateBasket,
            deleteBasketItem: deleteBasketItem,
            emptyBasket: emptyBasket,
            addItemToBasket: addItemToBasket,
            moveToBasket: moveToBasket,
            quickEmptybasket: quickEmptybasket,
            restoreBasket: restoreBasket,
            setUsingBasket: setUsingBasket,
            showCheckout: showCheckout,
            setReadyToCheckout: setReadyToCheckout
        };
    }
})();
'use strict';

(function () {

    'use strict';

    angular.module('BB.Services').service('bbWidgetInit', BBWidgetInit);

    function BBWidgetInit($rootScope, $sessionStorage, $q, $sniffer, QueryStringService, halClient, BBModel, UriTemplate, PurchaseService, $window, SSOService, bbWidgetBasket, CompanyStoreService, $bbug, bbWidgetPage, LoadingService, BBWidget, AppConfig, $location, bbTimeZone) {

        var connectionStarted, isFirstCall, widgetStarted;
        var $scope = null;
        var setScope = function setScope($s) {
            $scope = $s;
            reinitialise();
        };
        var reinitialise = function reinitialise() {
            isFirstCall = true;
            widgetStarted = $q.defer();
            $rootScope.widget_started = widgetStarted.promise;
        };
        var guardScope = function guardScope() {
            if ($scope === null) {
                throw new Error('please provide scope');
            }
        };
        var initWidget = function (prms) {
            guardScope();
            var url;
            if (prms == null) {
                prms = {};
            }
            this.$init_prms = prms;
            connectionStarted = $q.defer();
            $rootScope.connection_started = connectionStarted.promise;
            if (($sniffer.webkit && $sniffer.webkit < 537 || $sniffer.msie && $sniffer.msie <= 9) && isFirstCall) {
                if ($scope.bb.api_url) {
                    url = document.createElement('a');
                    url.href = $scope.bb.api_url;
                    if (url.host === '' || url.host === $location.host() || url.host === $location.host() + ":" + $location.port()) {
                        initWidget2();
                        return;
                    }
                }
                if ($rootScope.iframe_proxy_ready) {
                    initWidget2();
                } else {
                    $scope.$on('iframe_proxy_ready', function (event, args) {
                        if (args.iframe_proxy_ready) {
                            return initWidget2();
                        }
                    });
                }
            } else {
                initWidget2();
            }
        }.bind(this);
        var initWidget2 = function () {
            guardScope();
            var aff_promise, comp_category_id, comp_def, comp_promise, comp_url, company_id, embed_params, get_total, k, match, options, params, prms, ref, setup_promises, setup_promises2, sso_admin_login, sso_member_login, total_id, v;

            $scope.init_widget_started = true;
            prms = this.$init_prms;
            if (prms.query) {
                ref = prms.query;
                for (k in ref) {
                    v = ref[k];
                    prms[k] = QueryStringService(v);
                }
            }
            if (prms.custom_partial_url) {
                $scope.bb.custom_partial_url = prms.custom_partial_url;
                $scope.bb.partial_id = prms.custom_partial_url.substring(prms.custom_partial_url.lastIndexOf("/") + 1);
                if (prms.update_design) {
                    $scope.bb.update_design = prms.update_design;
                }
            } else if (prms.design_mode) {
                $scope.bb.design_mode = prms.design_mode;
            }
            company_id = $scope.bb.company_id;
            if (prms.company_id) {
                company_id = prms.company_id;
            }
            if (prms.affiliate_id) {
                $scope.bb.affiliate_id = prms.affiliate_id;
                $rootScope.affiliate_id = prms.affiliate_id;
            }
            if (prms.api_url) {
                $scope.bb.api_url = prms.api_url;
            }
            if (prms.partial_url) {
                $scope.bb.partial_url = prms.partial_url;
            }
            if (prms.page_suffix) {
                $scope.bb.page_suffix = prms.page_suffix;
            }
            if (prms.admin) {
                $scope.bb.isAdmin = prms.admin;
            }
            if (prms.move_reasons) {
                $scope.bb.move_reasons = prms.move_reasons;
            }
            if (prms.cancel_reasons) {
                $scope.bb.cancel_reasons = prms.cancel_reasons;
            }
            if (prms.auth_token) {
                $sessionStorage.setItem("auth_token", prms.auth_token);
            }
            $scope.bb.app_id = 1;
            $scope.bb.app_key = 1;
            $scope.bb.clear_basket = true;
            if (prms.basket) {
                $scope.bb.clear_basket = false;
            }
            if (prms.clear_basket === false) {
                $scope.bb.clear_basket = false;
            }
            if ($window.bb_setup || prms.client) {
                prms.clear_member || (prms.clear_member = true);
            }
            $scope.bb.client_defaults = prms.client || {};
            if (prms.client_defaults) {
                if (prms.client_defaults.membership_ref) {
                    $scope.bb.client_defaults.membership_ref = prms.client_defaults.membership_ref;
                }
            }
            if ($scope.bb.client_defaults && $scope.bb.client_defaults.name) {
                match = $scope.bb.client_defaults.name.match(/^(\S+)(?:\s(\S+))?/);
                if (match) {
                    $scope.bb.client_defaults.first_name = match[1];
                    if (match[2] != null) {
                        $scope.bb.client_defaults.last_name = match[2];
                    }
                }
            }
            if (prms.clear_member) {
                $scope.bb.clear_member = prms.clear_member;
                $sessionStorage.removeItem('login');
            }
            if (prms.app_id) {
                $scope.bb.app_id = prms.app_id;
            }
            if (prms.app_key) {
                $scope.bb.app_key = prms.app_key;
            }
            if (prms.on_conflict) {
                $scope.bb.on_conflict = prms.on_conflict;
            }
            if (prms.item_defaults) {
                $scope.bb.original_item_defaults = prms.item_defaults;
                $scope.bb.item_defaults = angular.copy($scope.bb.original_item_defaults);
            } else if ($scope.bb.original_item_defaults) {
                $scope.bb.item_defaults = angular.copy($scope.bb.original_item_defaults);
            }
            if ($scope.bb.selected_service && $scope.bb.selected_service.company_id === company_id) {
                $scope.bb.item_defaults.service = $scope.bb.selected_service.id;
            }
            if (prms.route_format) {
                $scope.bb.setRouteFormat(prms.route_format);
                if ($scope.bb_route_init) {
                    $scope.bb_route_init();
                }
            }
            if (prms.hide === true) {
                $scope.hide_page = true;
            } else {
                $scope.hide_page = false;
            }
            if (prms.from_datetime) {
                $scope.bb.from_datetime = prms.from_datetime;
            }
            if (prms.to_datetime) {
                $scope.bb.to_datetime = prms.to_datetime;
            }
            if (prms.min_date) {
                $scope.bb.min_date = prms.min_date;
            }
            if (prms.max_date) {
                $scope.bb.max_date = prms.max_date;
            }
            if (prms.hide_block) {
                $scope.bb.hide_block = prms.hide_block;
            }
            if (!prms.custom_partial_url) {
                $scope.bb.path_setup = true;
            }
            if (prms.extra_setup) {
                $scope.bb.extra_setup = prms.extra_setup;
                if (prms.extra_setup.step) {
                    $scope.bb.starting_step_number = parseInt(prms.extra_setup.step);
                }
                if (prms.extra_setup.return_url) {
                    $scope.bb.return_url = prms.extra_setup.return_url;
                }
                if (prms.extra_setup.destination) {
                    $scope.bb.destination = prms.extra_setup.destination;
                }
            }
            if (prms.booking_settings) {
                $scope.bb.booking_settings = prms.booking_settings;
            }
            if (prms.template) {
                $scope.bb.template = prms.template;
            }
            if (prms.login_required) {
                $scope.bb.login_required = true;
            }
            if (prms.private_note) {
                $scope.bb.private_note = prms.private_note;
            }
            if (prms.qudini_booking_id) {
                $scope.bb.qudini_booking_id = prms.qudini_booking_id;
            }
            this.waiting_for_conn_started_def = $q.defer();
            $scope.waiting_for_conn_started = this.waiting_for_conn_started_def.promise;
            if (company_id || $scope.bb.affiliate_id) {
                $scope.waiting_for_conn_started = $rootScope.connection_started;
            } else {
                this.waiting_for_conn_started_def.resolve();
            }
            widgetStarted.resolve();
            setup_promises2 = [];
            setup_promises = [];
            if ($scope.bb.affiliate_id) {
                aff_promise = halClient.$get($scope.bb.api_url + '/api/v1/affiliates/' + $scope.bb.affiliate_id);
                setup_promises.push(aff_promise);
                aff_promise.then(function (affiliate) {
                    var comp_p, comp_promise;
                    if ($scope.bb.$wait_for_routing) {
                        setup_promises2.push($scope.bb.$wait_for_routing.promise);
                    }
                    setAffiliate(new BBModel.Affiliate(affiliate));
                    $scope.bb.item_defaults.affiliate = $scope.affiliate;
                    if (prms.company_ref) {
                        comp_p = $q.defer();
                        comp_promise = $scope.affiliate.getCompanyByRef(prms.company_ref);
                        setup_promises2.push(comp_p.promise);
                        return comp_promise.then(function (company) {
                            return setCompany(company, prms.keep_basket).then(function (val) {
                                return comp_p.resolve(val);
                            }, function (err) {
                                return comp_p.reject(err);
                            });
                        }, function (err) {
                            return comp_p.reject(err);
                        });
                    }
                });
            }
            if (company_id) {
                if (prms.embed) {
                    embed_params = prms.embed;
                }
                embed_params || (embed_params = null);
                comp_category_id = null;
                if ($scope.bb.item_defaults.category != null) {
                    if ($scope.bb.item_defaults.category.id != null) {
                        comp_category_id = $scope.bb.item_defaults.category.id;
                    } else {
                        comp_category_id = $scope.bb.item_defaults.category;
                    }
                }
                comp_def = $q.defer();
                comp_promise = comp_def.promise;
                options = {};
                if ($sessionStorage.getItem('auth_token')) {
                    options.auth_token = $sessionStorage.getItem('auth_token');
                }
                if ($scope.bb.isAdmin) {
                    comp_url = new UriTemplate($scope.bb.api_url + $scope.company_admin_api_path).fillFromObject({
                        company_id: company_id,
                        category_id: comp_category_id,
                        embed: embed_params
                    });
                    halClient.$get(comp_url, options).then(function (company) {
                        return comp_def.resolve(company);
                    }, function (err) {
                        comp_url = new UriTemplate($scope.bb.api_url + $scope.company_api_path).fillFromObject({
                            company_id: company_id,
                            category_id: comp_category_id,
                            embed: embed_params
                        });
                        return halClient.$get(comp_url, options).then(function (company) {
                            return comp_def.resolve(company);
                        }, function (err) {
                            return comp_def.reject(err);
                        });
                    });
                } else {
                    comp_url = new UriTemplate($scope.bb.api_url + $scope.company_api_path).fillFromObject({
                        company_id: company_id,
                        category_id: comp_category_id,
                        embed: embed_params
                    });
                    halClient.$get(comp_url, options).then(function (company) {
                        if (company) {
                            return comp_def.resolve(company);
                        } else {
                            return comp_def.reject("Invalid company ID " + company_id);
                        }
                    }, function (err) {
                        return comp_def.reject(err);
                    });
                }
                setup_promises.push(comp_promise);
                comp_promise.then(function (company) {
                    var child, comp, cprom, parent_company;
                    if ($scope.bb.$wait_for_routing) {
                        setup_promises2.push($scope.bb.$wait_for_routing.promise);
                    }
                    comp = new BBModel.Company(company);
                    cprom = $q.defer();
                    setup_promises2.push(cprom.promise);
                    child = null;
                    if (comp.companies && $scope.bb.item_defaults.company) {
                        child = comp.findChildCompany($scope.bb.item_defaults.company);
                    }
                    if (child) {
                        parent_company = comp;
                        return halClient.$get($scope.bb.api_url + '/api/v1/company/' + child.id).then(function (company) {
                            comp = new BBModel.Company(company);
                            setupDefaults(comp.id);
                            $scope.bb.parent_company = parent_company;
                            return setCompany(comp, prms.keep_basket).then(function () {
                                return cprom.resolve();
                            }, function (err) {
                                return cprom.reject();
                            });
                        }, function (err) {
                            return cprom.reject();
                        });
                    } else {
                        setupDefaults(comp.id);
                        return setCompany(comp, prms.keep_basket).then(function () {
                            return cprom.resolve();
                        }, function (err) {
                            return cprom.reject();
                        });
                    }
                });
                if (prms.member_sso) {
                    params = {
                        company_id: company_id,
                        root: $scope.bb.api_url,
                        member_sso: prms.member_sso
                    };
                    sso_member_login = SSOService.memberLogin(params).then(function (client) {
                        return setClient(client);
                    });
                    setup_promises.push(sso_member_login);
                }
                if (prms.admin_sso) {
                    params = {
                        company_id: prms.parent_company_id ? prms.parent_company_id : company_id,
                        root: $scope.bb.api_url,
                        admin_sso: prms.admin_sso
                    };
                    sso_admin_login = SSOService.adminLogin(params).then(function (admin) {
                        return $scope.bb.admin = admin;
                    });
                    setup_promises.push(sso_admin_login);
                }
                if ($scope.bb.item_defaults && $scope.bb.item_defaults.purchase_total_long_id) {
                    total_id = $scope.bb.item_defaults.purchase_total_long_id;
                } else {
                    total_id = QueryStringService('total_id');
                }
                if (prms.total_id) {
                    // get the purchase total and define it on BB
                    // get the bookings from the total and then create a basket from those bookings
                    var _params = {
                        url_root: $scope.bb.api_url,
                        purchase_id: prms.total_id
                    };

                    var totalDefer = $q.defer();
                    PurchaseService.query(_params).then(function (total) {
                        $scope.bb.purchase = total;
                        total.$getBookings().then(function (bookings) {
                            bbWidgetBasket.createBasketFromBookings(bookings, $scope.bb.purchase.client, totalDefer);
                        }, function (err) {
                            $log.info(err);
                            totalDefer.reject(err);
                        });
                    }, function (err) {
                        $log.info(err);
                        totalDefer.reject(err);
                    });
                    // push the total promise so it is resolved before the first step is loaded
                    setup_promises.push(totalDefer.promise);
                }
                if (total_id) {
                    params = {
                        purchase_id: total_id,
                        url_root: $scope.bb.api_url
                    };
                    get_total = PurchaseService.query(params).then(function (total) {
                        $scope.bb.total = total;
                        if (total.paid > 0) {
                            return $scope.bb.payment_status = 'complete';
                        }
                    });
                    setup_promises.push(get_total);
                }
            }
            $scope.isLoaded = false;
            return $q.all(setup_promises).then(function () {
                return $q.all(setup_promises2).then(function () {
                    var base, clear_prom, def_clear;
                    if (!$scope.bb.basket) {
                        (base = $scope.bb).basket || (base.basket = new BBModel.Basket(null, $scope.bb));
                    }
                    if (!$scope.client) {
                        clearClient();
                    }
                    def_clear = $q.defer();
                    clear_prom = def_clear.promise;
                    if (!$scope.bb.current_item) {
                        clear_prom = bbWidgetBasket.clearBasketItem();
                    } else {
                        def_clear.resolve();
                    }
                    return clear_prom.then(function () {
                        var page;
                        if (!$scope.client_details) {
                            $scope.client_details = new BBModel.ClientDetails();
                        }
                        if (!$scope.bb.stacked_items) {
                            $scope.bb.stacked_items = [];
                        }
                        if ($scope.bb.company || $scope.bb.affiliate) {
                            bbTimeZone.determine();
                            connectionStarted.resolve();
                            $scope.done_starting = true;
                            if (!prms.no_route) {
                                page = null;
                                if (isFirstCall && $bbug.isEmptyObject($scope.bb.routeSteps)) {
                                    page = $scope.bb.firstStep;
                                }
                                if (prms.first_page) {
                                    page = prms.first_page;
                                }
                                isFirstCall = false;
                                return bbWidgetPage.decideNextPage(page);
                            }
                        }
                        $scope.isLoaded = true;
                    });
                }, function (err) {
                    connectionStarted.reject("Failed to start widget");
                    return LoadingService.setLoadedAndShowError($scope, err, 'Sorry, something went wrong');
                });
            }, function (err) {
                connectionStarted.reject("Failed to start widget");
                return LoadingService.setLoadedAndShowError($scope, err, 'Sorry, something went wrong');
            });
        }.bind(this);
        var setupDefaults = function setupDefaults(company_id) {
            guardScope();
            var category, clinic, def, event, event_chain, event_group, k, person, ref, resource, service, v;
            def = $q.defer();
            if (isFirstCall || $scope.bb.orginal_company_id && $scope.bb.orginal_company_id !== company_id) {
                $scope.bb.orginal_company_id = company_id;
                $scope.bb.default_setup_promises = [];
                if ($scope.bb.item_defaults.query) {
                    ref = $scope.bb.item_defaults.query;
                    for (k in ref) {
                        v = ref[k];
                        $scope.bb.item_defaults[k] = QueryStringService(v);
                    }
                }
                if ($scope.bb.item_defaults.resource) {
                    if ($scope.bb.isAdmin) {
                        resource = halClient.$get($scope.bb.api_url + '/api/v1/admin/' + company_id + '/resources/' + $scope.bb.item_defaults.resource);
                    } else {
                        resource = halClient.$get($scope.bb.api_url + '/api/v1/' + company_id + '/resources/' + $scope.bb.item_defaults.resource);
                    }
                    $scope.bb.default_setup_promises.push(resource);
                    resource.then(function (res) {
                        return $scope.bb.item_defaults.resource = new BBModel.Resource(res);
                    });
                }
                if ($scope.bb.item_defaults.person) {
                    if ($scope.bb.isAdmin) {
                        person = halClient.$get($scope.bb.api_url + '/api/v1/admin/' + company_id + '/people/' + $scope.bb.item_defaults.person);
                    } else {
                        person = halClient.$get($scope.bb.api_url + '/api/v1/' + company_id + '/people/' + $scope.bb.item_defaults.person);
                    }
                    $scope.bb.default_setup_promises.push(person);
                    person.then(function (res) {
                        return $scope.bb.item_defaults.person = new BBModel.Person(res);
                    });
                }
                if ($scope.bb.item_defaults.person_ref) {
                    if ($scope.bb.isAdmin) {
                        person = halClient.$get($scope.bb.api_url + '/api/v1/admin/' + company_id + '/people/find_by_ref/' + $scope.bb.item_defaults.person_ref);
                    } else {
                        person = halClient.$get($scope.bb.api_url + '/api/v1/' + company_id + '/people/find_by_ref/' + $scope.bb.item_defaults.person_ref);
                    }
                    $scope.bb.default_setup_promises.push(person);
                    person.then(function (res) {
                        return $scope.bb.item_defaults.person = new BBModel.Person(res);
                    });
                }
                if ($scope.bb.item_defaults.service) {
                    if ($scope.bb.isAdmin) {
                        service = halClient.$get($scope.bb.api_url + '/api/v1/admin/' + company_id + '/services/' + $scope.bb.item_defaults.service);
                    } else {
                        service = halClient.$get($scope.bb.api_url + '/api/v1/' + company_id + '/services/' + $scope.bb.item_defaults.service);
                    }
                    $scope.bb.default_setup_promises.push(service);
                    service.then(function (res) {
                        return $scope.bb.item_defaults.service = new BBModel.Service(res);
                    });
                }
                if ($scope.bb.item_defaults.service_ref) {
                    if ($scope.bb.isAdmin) {
                        service = halClient.$get($scope.bb.api_url + '/api/v1/admin/' + company_id + '/services?api_ref=' + $scope.bb.item_defaults.service_ref);
                    } else {
                        service = halClient.$get($scope.bb.api_url + '/api/v1/' + company_id + '/services?api_ref=' + $scope.bb.item_defaults.service_ref);
                    }
                    $scope.bb.default_setup_promises.push(service);
                    service.then(function (res) {
                        return $scope.bb.item_defaults.service = new BBModel.Service(res);
                    });
                }
                if ($scope.bb.item_defaults.event_group) {
                    if ($scope.bb.isAdmin) {
                        event_group = halClient.$get($scope.bb.api_url + '/api/v1/admin/' + company_id + '/event_groups/' + $scope.bb.item_defaults.event_group);
                    } else {
                        event_group = halClient.$get($scope.bb.api_url + '/api/v1/' + company_id + '/event_groups/' + $scope.bb.item_defaults.event_group);
                    }
                    $scope.bb.default_setup_promises.push(event_group);
                    event_group.then(function (res) {
                        return $scope.bb.item_defaults.event_group = new BBModel.EventGroup(res);
                    });
                }
                if ($scope.bb.item_defaults.event) {
                    if ($scope.bb.isAdmin) {
                        event = halClient.$get($scope.bb.api_url + '/api/v1/admin/' + company_id + '/event_chains/' + $scope.bb.item_defaults.event_chain + '/events/' + $scope.bb.item_defaults.event);
                    } else {
                        event = halClient.$get($scope.bb.api_url + '/api/v1/' + company_id + '/events/' + $scope.bb.item_defaults.event);
                    }
                    $scope.bb.default_setup_promises.push(event);
                    event.then(function (res) {
                        return $scope.bb.item_defaults.event = new BBModel.Event(res);
                    });
                }
                if ($scope.bb.item_defaults.event_chain) {
                    if ($scope.bb.isAdmin) {
                        event_chain = halClient.$get($scope.bb.api_url + '/api/v1/admin/' + company_id + '/event_chains/' + $scope.bb.item_defaults.event_chain);
                    } else {
                        event_chain = halClient.$get($scope.bb.api_url + '/api/v1/' + company_id + '/event_chains/' + $scope.bb.item_defaults.event_chain);
                    }
                    $scope.bb.default_setup_promises.push(event_chain);
                    event_chain.then(function (res) {
                        return $scope.bb.item_defaults.event_chain = new BBModel.EventChain(res);
                    });
                }
                if ($scope.bb.item_defaults.category) {
                    category = halClient.$get($scope.bb.api_url + '/api/v1/' + company_id + '/categories/' + $scope.bb.item_defaults.category);
                    $scope.bb.default_setup_promises.push(category);
                    category.then(function (res) {
                        return $scope.bb.item_defaults.category = new BBModel.Category(res);
                    });
                }
                if ($scope.bb.item_defaults.clinic) {
                    clinic = halClient.$get($scope.bb.api_url + '/api/v1/' + company_id + '/clinics/' + $scope.bb.item_defaults.clinic);
                    $scope.bb.default_setup_promises.push(clinic);
                    clinic.then(function (res) {
                        return $scope.bb.item_defaults.clinic = new BBModel.Clinic(res);
                    });
                }
                if ($scope.bb.item_defaults.duration) {
                    $scope.bb.item_defaults.duration = parseInt($scope.bb.item_defaults.duration);
                }
                $q.all($scope.bb.default_setup_promises)['finally'](function () {
                    return def.resolve();
                });
            } else {
                def.resolve();
            }
            return def.promise;
        };
        var setAffiliate = function setAffiliate(affiliate) {
            guardScope();
            $scope.bb.affiliate_id = affiliate.id;
            $scope.bb.affiliate = affiliate;
            $scope.affiliate = affiliate;
            return $scope.affiliate_id = affiliate.id;
        };
        var setCompany = function setCompany(company, keep_basket) {
            guardScope();
            var defer;
            defer = $q.defer();
            $scope.bb.company_id = company.id;
            $scope.bb.company = company;
            $scope.bb.item_defaults.company = $scope.bb.company;
            if (company.$has('settings')) {
                company.getSettings().then(function (settings) {
                    $scope.bb.company_settings = settings;
                    setActiveCompany(company, settings);
                    if ($scope.bb.company_settings.merge_resources) {
                        $scope.bb.item_defaults.merge_resources = true;
                    }
                    if ($scope.bb.company_settings.merge_people) {
                        $scope.bb.item_defaults.merge_people = true;
                    }
                    $rootScope.bb_currency = $scope.bb.company_settings.currency;
                    $scope.bb.currency = $scope.bb.company_settings.currency;
                    $scope.bb.has_prices = $scope.bb.company_settings.has_prices;
                    if (!$scope.bb.basket || $scope.bb.basket.company_id !== $scope.bb.company_id && !keep_basket) {
                        return bbWidgetBasket.restoreBasket().then(function () {
                            defer.resolve();
                            return $scope.$emit('company:setup');
                        });
                    } else {
                        defer.resolve();
                        return $scope.$emit('company:setup');
                    }
                });
            } else {
                if (!$scope.bb.basket || $scope.bb.basket.company_id !== $scope.bb.company_id && !keep_basket) {
                    bbWidgetBasket.restoreBasket().then(function () {
                        defer.resolve();
                        return $scope.$emit('company:setup');
                    });
                } else {
                    defer.resolve();
                    $scope.$emit('company:setup');
                }
                setActiveCompany(company);
            }
            return defer.promise;
        };
        var setClient = function setClient(client) {
            guardScope();
            $scope.client = client;
            if (client.postcode && !$scope.bb.postcode) {
                return $scope.bb.postcode = client.postcode;
            }
        };
        var clearClient = function clearClient() {
            guardScope();
            $scope.client = new BBModel.Client();
            if ($window.bb_setup) {
                $scope.client.setDefaults($window.bb_setup);
            }
            if ($scope.bb.client_defaults) {
                return $scope.client.setDefaults($scope.bb.client_defaults);
            }
        };
        var setActiveCompany = function setActiveCompany(company, settings) {
            guardScope();
            CompanyStoreService.currency_code = !settings ? company.currency_code : settings.currency;
            CompanyStoreService.time_zone = company.timezone;
            CompanyStoreService.country_code = company.country_code;
            return CompanyStoreService.settings = settings;
        };
        var initializeBBWidget = function initializeBBWidget() {
            guardScope();
            $scope.bb = new BBWidget();
            AppConfig.uid = $scope.bb.uid;
            $scope.bb.stacked_items = [];
            $scope.bb.company_set = $scope.bb.company_id != null;
            $scope.recordStep = $scope.bb.recordStep;
            determineBBApiUrl();
        };
        var determineBBApiUrl = function determineBBApiUrl() {
            guardScope();
            var base, base1;
            if ($scope.apiUrl) {
                $scope.bb || ($scope.bb = {});
                $scope.bb.api_url = $scope.apiUrl;
            }
            if ($rootScope.bb && $rootScope.bb.api_url) {
                $scope.bb.api_url = $rootScope.bb.api_url;
                if (!$rootScope.bb.partial_url) {
                    $scope.bb.partial_url = "";
                } else {
                    $scope.bb.partial_url = $rootScope.bb.partial_url;
                }
            }
            if ($location.port() !== 80 && $location.port() !== 443) {
                (base = $scope.bb).api_url || (base.api_url = $location.protocol() + "://" + $location.host() + ":" + $location.port());
            } else {
                (base1 = $scope.bb).api_url || (base1.api_url = $location.protocol() + "://" + $location.host());
            }
        };

        return {
            clearClient: clearClient,
            initWidget: initWidget,
            setAffiliate: setAffiliate,
            setActiveCompany: setActiveCompany,
            setCompany: setCompany,
            setClient: setClient,
            setScope: setScope,
            initializeBBWidget: initializeBBWidget,
            determineBBApiUrl: determineBBApiUrl
        };
    }
})();
'use strict';

(function () {

    'use strict';

    angular.module('BB').service('bbWidgetPage', BBWidgetPage);

    function BBWidgetPage(AlertService, BBModel, LoadingService, LoginService, $rootScope, $sce, $analytics) {

        var $scope = null;

        // Automatic Decide Next Page: this flag can be used for pages
        // which require to prevent the widget's built-in decide next page
        var automaticDNP = {};

        var setScope = function setScope($s) {
            $scope = $s;
        };
        var guardScope = function guardScope() {
            if ($scope === null) {
                throw new Error('please set scope');
            }
        };
        var clearPage = function clearPage() {
            guardScope();
            return $scope.bb_main = "";
        };
        var hidePage = function hidePage() {
            guardScope();
            return $scope.hide_page = true;
        };
        var jumpToPage = function jumpToPage(route) {
            guardScope();
            $scope.current_page = route;
            $scope.jumped = true;
            return $scope.bb_main = $sce.trustAsResourceUrl($scope.partial_url + route + $scope.page_suffix);
        };
        var setLoadingPage = function setLoadingPage(val) {
            guardScope();
            return $scope.loading_page = val;
        };
        var isLoadingPage = function isLoadingPage() {
            guardScope();
            return $scope.loading_page;
        };
        var setPageRoute = function setPageRoute(route) {
            guardScope();
            $scope.bb.current_page_route = route;
            if ($scope.bb.routeSteps && $scope.bb.routeSteps[route]) {
                showPage($scope.bb.routeSteps[route]);
                return true;
            }
            return false;
        };
        var showPage = function showPage(route, dont_record_page) {
            guardScope();
            $scope.bb.updateRoute(route);
            $scope.jumped = false;
            if (isLoadingPage()) {
                return;
            }
            setLoadingPage(true);
            if ($scope.bb.current_page === route) {
                $scope.bb_main = "";
                setTimeout(function () {
                    $scope.bb_main = $sce.trustAsResourceUrl($scope.bb.pageURL(route));
                    return $scope.$apply();
                }, 0);
            } else {
                AlertService.clear();
                $scope.bb.current_page = route;
                if (!dont_record_page) {
                    $scope.bb.recordCurrentPage();
                }
                LoadingService.notLoaded($scope);
                $scope.bb_main = $sce.trustAsResourceUrl($scope.bb.pageURL(route));
            }

            // reset this collection on each page change
            automaticDNP = {};

            $analytics.pageTrack($scope.bb.current_page);
            return $rootScope.$broadcast("page:loaded");
        };
        var setPageLoaded = function setPageLoaded() {
            return LoadingService.setLoaded($scope);
        };
        var decideNextPage = function decideNextPage(route) {
            guardScope();
            if (route) {
                if (route === 'none') {
                    return;
                } else {
                    if ($scope.bb.total && $scope.bb.payment_status === 'complete') {
                        if (setPageRoute($rootScope.Route.Confirmation)) {
                            return;
                        }
                        return showPage('confirmation');
                    } else {
                        return showPage(route);
                    }
                }
            }
            if ($scope.bb.nextSteps && $scope.bb.current_page && $scope.bb.nextSteps[$scope.bb.current_page] && !$scope.bb.routeSteps) {
                return showPage($scope.bb.nextSteps[$scope.bb.current_page]);
            }
            if (!$scope.client.valid() && LoginService.isLoggedIn()) {
                $scope.client = new BBModel.Client(LoginService.member()._data);
            }
            if ($scope.bb.company && $scope.bb.company.companies || !$scope.bb.company && $scope.affiliate) {
                if (setPageRoute($rootScope.Route.Company)) {
                    return;
                }
                return showPage('company_list');
            } else if ($scope.bb.total && $scope.bb.payment_status === "complete") {
                if (setPageRoute($rootScope.Route.Confirmation)) {
                    return;
                }
                return showPage('confirmation');
            } else if ($scope.bb.total && $scope.bb.payment_status === "pending") {
                return showPage('payment');
            } else if ($scope.bb.company.$has('event_groups') && !$scope.bb.current_item.event_group && !$scope.bb.current_item.service && !$scope.bb.current_item.product && !$scope.bb.current_item.deal || $scope.bb.company.$has('events') && $scope.bb.current_item.event_group && $scope.bb.current_item.event == null && !$scope.bb.current_item.product && !$scope.bb.current_item.deal) {
                if (setPageRoute($rootScope.Route.Event)) {
                    return;
                }
                return showPage('event_list');
            } else if ($scope.bb.company.$has('events') && $scope.bb.current_item.event && !$scope.bb.current_item.num_book && (!$scope.bb.current_item.tickets || !$scope.bb.current_item.tickets.qty) && !$scope.bb.current_item.product && !$scope.bb.current_item.deal) {
                return showPage('event');
            } else if ($scope.bb.company.$has('services') && !$scope.bb.current_item.service && $scope.bb.current_item.event == null && !$scope.bb.current_item.product && !$scope.bb.current_item.deal) {
                if (setPageRoute($rootScope.Route.Service)) {
                    return;
                }
                return showPage('service_list');
            } else if ($scope.bb.company.$has('resources') && !$scope.bb.current_item.resource && $scope.bb.current_item.event == null && !$scope.bb.current_item.product && !$scope.bb.current_item.deal) {
                if (setPageRoute($rootScope.Route.Resource)) {
                    return;
                }
                return showPage('resource_list');
            } else if ($scope.bb.company.$has('people') && !$scope.bb.current_item.person && $scope.bb.current_item.event == null && !$scope.bb.current_item.product && !$scope.bb.current_item.deal) {
                if (setPageRoute($rootScope.Route.Person)) {
                    return;
                }
                return showPage('person_list');
            } else if (!$scope.bb.current_item.duration && $scope.bb.current_item.event == null && !$scope.bb.current_item.product && !$scope.bb.current_item.deal) {
                if (setPageRoute($rootScope.Route.Duration)) {
                    return;
                }
                return showPage('duration_list');
            } else if ($scope.bb.current_item.days_link && !$scope.bb.current_item.date && $scope.bb.current_item.event == null && !$scope.bb.current_item.deal) {
                if ($scope.bb.company.$has('availability_slots')) {
                    if (setPageRoute($rootScope.Route.Slot)) {
                        return;
                    }
                    return showPage('slot_list');
                } else {
                    if (setPageRoute($rootScope.Route.Date)) {
                        return;
                    }
                    return showPage('calendar');
                }
            } else if ($scope.bb.current_item.days_link && !$scope.bb.current_item.time && $scope.bb.current_item.event == null && (!$scope.bb.current_item.service || $scope.bb.current_item.service.duration_unit !== 'day') && !$scope.bb.current_item.deal) {
                if (setPageRoute($rootScope.Route.Time)) {
                    return;
                }
                return showPage('time');
            } else if (!$scope.client.valid()) {
                if (setPageRoute($rootScope.Route.Client)) {
                    return;
                }
                return showPage('client');
            } else if ($scope.bb.current_item.item_details && $scope.bb.current_item.item_details.hasQuestions && !$scope.bb.current_item.asked_questions) {
                if (setPageRoute($rootScope.Route.Questions)) {
                    return;
                }
                return showPage('check_items');
            } else if ($scope.bb.moving_booking && $scope.bb.basket.itemsReady()) {
                return showPage('purchase');
            } else if (!$scope.bb.basket.readyToCheckout()) {
                if (setPageRoute($rootScope.Route.Summary)) {
                    return;
                }
                return showPage('basket_summary');
            } else if ($scope.bb.usingBasket && (!$scope.bb.confirmCheckout || $scope.bb.company_settings.has_vouchers || $scope.bb.company.$has('coupon'))) {
                if (setPageRoute($rootScope.Route.Basket)) {
                    return;
                }
                return showPage('basket');
            } else if ($scope.bb.basket.readyToCheckout() && $scope.bb.payment_status === null && !$scope.bb.basket.waiting_for_checkout) {
                if (setPageRoute($rootScope.Route.Checkout)) {
                    return;
                }
                return showPage('checkout');
            } else if ($scope.bb.payment_status === "complete") {
                if (setPageRoute($rootScope.Route.Confirmation)) {
                    return;
                }
                return showPage('confirmation');
            }
        };

        var canAutoDecideNextPage = function canAutoDecideNextPage(widget) {
            return automaticDNP.hasOwnProperty(widget) ? automaticDNP[widget] : true;
        };

        var setAutoDecideNextPage = function setAutoDecideNextPage(widget) {
            var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

            automaticDNP[widget] = state;
        };

        var getCurrentPage = function getCurrentPage() {
            return $scope.bb.current_page;
        };

        return {
            clearPage: clearPage,
            decideNextPage: decideNextPage,
            hidePage: hidePage,
            isLoadingPage: isLoadingPage,
            jumpToPage: jumpToPage,
            setLoadingPage: setLoadingPage,
            setPageLoaded: setPageLoaded,
            setPageRoute: setPageRoute,
            setScope: setScope,
            showPage: showPage,
            canAutoDecideNextPage: canAutoDecideNextPage,
            setAutoDecideNextPage: setAutoDecideNextPage,
            getCurrentPage: getCurrentPage
        };
    }
})();
'use strict';

(function () {

    'use strict';

    angular.module('BB').service('bbWidgetStep', BBWidgetStep);

    function BBWidgetStep(BBModel, LoginService, $rootScope, bbWidgetPage, $window, bbAnalyticsPiwik) {

        var $scope = null;

        var setScope = function setScope($s) {
            $scope = $s;
        };
        var guardScope = function guardScope() {
            if ($scope === null) {
                throw new Error('please set scope');
            }
        };
        var setStepTitle = function setStepTitle(title) {
            guardScope();
            return $scope.bb.steps[$scope.bb.current_step - 1].title = title;
        };
        var checkStepTitle = function checkStepTitle(title) {
            guardScope();
            if ($scope.bb.steps[$scope.bb.current_step - 1] && !$scope.bb.steps[$scope.bb.current_step - 1].title) {
                return setStepTitle(title);
            }
        };
        var getCurrentStepTitle = function getCurrentStepTitle() {
            var steps;
            guardScope();
            steps = $scope.bb.steps;
            if (!_.compact(steps).length || steps.length === 1 && steps[0].number !== $scope.bb.current_step) {
                steps = $scope.bb.allSteps;
            }
            if ($scope.bb.current_step) {
                return steps[$scope.bb.current_step - 1].title;
            }
        };
        var loadStep = function loadStep(stepClickedNumber) {
            guardScope();
            if (stepClickedNumber === $scope.bb.current_step) {
                return;
            }
            $scope.bb.calculatePercentageComplete(stepClickedNumber);
            var stepClickedPlusOne = $scope.bb.steps[stepClickedNumber];
            var stepClicked = $scope.bb.steps[stepClickedNumber - 1];

            if (stepClickedPlusOne && !stepClicked) {
                stepClicked = stepClickedPlusOne;
            }

            if (!stepClickedPlusOne) {
                stepClickedPlusOne = stepClicked;
            }
            if (stepClickedPlusOne && !$scope.bb.last_step_reached) {
                if (!stepClickedPlusOne.stacked_length || stepClickedPlusOne.stacked_length === 0) {
                    $scope.bb.stacked_items = [];
                }
                $scope.bb.current_item.loadStep(stepClickedPlusOne.current_item);
                if ($scope.bb.steps.length > 1) {
                    $scope.bb.steps.splice(stepClickedNumber, $scope.bb.steps.length - stepClickedNumber);
                }
                $scope.bb.current_step = stepClickedNumber;
                bbWidgetPage.showPage(stepClicked.page, true);
            }
            if ($scope.bb.allSteps) {

                $scope.bb.allSteps.map(function (step) {
                    step.active = false;
                    step.passed = step.number < $scope.bb.current_step;
                });

                if ($scope.bb.allSteps[$scope.bb.current_step - 1]) {
                    return $scope.bb.allSteps[$scope.bb.current_step - 1].active = true;
                }
            }
        };

        function setPiwik() {
            var category = $scope.bb.current_page;
            var title = "Load Previous Step";
            bbAnalyticsPiwik.push(['trackEvent', [category], title]);
        }

        /**
         * @ngdoc method
         * @name loadPreviousStep
         * @methodOf BB.Directives:bbWidget
         * @description
         * Loads the previous unskipped step
         *
         * @param {integer} steps_to_go_back: The number of steps to go back
         * @param {string} caller: The method that called this function
         */
        var loadPreviousStep = function loadPreviousStep(caller) {

            if (bbAnalyticsPiwik.isEnabled()) setPiwik();

            var last_step, pages_to_remove_from_history, past_steps, step_to_load;
            guardScope();
            past_steps = _.reject($scope.bb.steps, function (s) {
                return s.number >= $scope.bb.current_step;
            });
            step_to_load = 0;
            while (past_steps[0]) {
                last_step = past_steps.pop();
                if (!last_step) {
                    break;
                }
                if (!last_step.skipped) {
                    step_to_load = last_step.number;
                    break;
                }
            }
            if ($scope.bb.routeFormat) {
                pages_to_remove_from_history = step_to_load === 0 ? $scope.bb.current_step + 1 : $scope.bb.current_step - step_to_load;
                if (caller === "locationChangeStart") {
                    pages_to_remove_from_history--;
                }
                if (pages_to_remove_from_history > 0) {
                    window.history.go(pages_to_remove_from_history * -1);
                }
            }
            if (step_to_load > 0) {
                return loadStep(step_to_load);
            }
        };
        var loadStepByPageName = function loadStepByPageName(page_name) {
            var i, len, ref, step;
            guardScope();
            ref = $scope.bb.allSteps;
            for (i = 0, len = ref.length; i < len; i++) {
                step = ref[i];
                if (step.page === page_name) {
                    return loadStep(step.number);
                }
            }
            return loadStep(1);
        };
        var reset = function reset() {
            guardScope();
            $rootScope.$broadcast('clear:formData');
            $rootScope.$broadcast('widget:restart');
            setLastSelectedDate(null);
            if (!LoginService.isLoggedIn()) {
                $scope.client = new BBModel.Client();
            }
            $scope.bb.last_step_reached = false;
            return $scope.bb.steps.splice(1);
        };
        var restart = function restart() {
            guardScope();
            reset();
            return loadStep(1);
        };
        var setLastSelectedDate = function setLastSelectedDate(date) {
            guardScope();
            return $scope.last_selected_date = date;
        };

        /**
         * @ngdoc method
         * @name skipThisStep
         * @methodOf BB.Directives:bbWidget
         * @description
         * Marks the current step as skipped
         */
        var skipThisStep = function skipThisStep() {
            if ($scope.bb.steps[$scope.bb.steps.length - 1]) {
                return $scope.bb.steps[$scope.bb.steps.length - 1].skipped = true;
            }
        };

        return {
            checkStepTitle: checkStepTitle,
            getCurrentStepTitle: getCurrentStepTitle,
            loadPreviousStep: loadPreviousStep,
            loadStep: loadStep,
            loadStepByPageName: loadStepByPageName,
            reset: reset,
            restart: restart,
            setLastSelectedDate: setLastSelectedDate,
            setScope: setScope,
            setStepTitle: setStepTitle,
            skipThisStep: skipThisStep
        };
    }
})();
'use strict';

(function () {

    'use strict';

    angular.module('BB.Services').service('bbWidgetUtilities', BBWidgetUtilities);

    function BBWidgetUtilities($window, BBModel, bbWidgetPage, bbWidgetStep, AppService, $timeout, LoginService) {

        var $scope = null;
        var setScope = function setScope($s) {
            $scope = $s;
        };

        var isAdmin = function isAdmin() {
            return $scope.bb.isAdmin;
        };
        var showLoaderHandler = function showLoaderHandler() {
            $scope.loading = true;
        };
        var hideLoaderHandler = function hideLoaderHandler() {
            $scope.loading = false;
        };
        var locationChangeStartHandler = function locationChangeStartHandler(angular_event, new_url, old_url) {
            var step_number;
            if (!$scope.bb.routeFormat) {
                return;
            }
            if (!$scope.bb.routing || AppService.isModalOpen()) {
                step_number = $scope.bb.matchURLToStep();
                if (step_number > $scope.bb.current_step) {
                    bbWidgetStep.loadStep(step_number);
                } else if (step_number < $scope.bb.current_step) {
                    bbWidgetStep.loadPreviousStep('locationChangeStart');
                }
            }
            $scope.bb.routing = false;
        };
        var getPartial = function getPartial(file) {
            return $scope.bb.pageURL(file);
        };
        var logout = function logout(route) {
            if ($scope.client && $scope.client.valid()) {
                return LoginService.logout({
                    root: $scope.bb.api_url
                }).then(function () {
                    $scope.client = new BBModel.Client();
                    return bbWidgetPage.decideNextPage(route);
                });
            } else if ($scope.member) {
                return LoginService.logout({
                    root: $scope.bb.api_url
                }).then(function () {
                    $scope.member = new BBModel.Member.Member();
                    return bbWidgetPage.decideNextPage(route);
                });
            }
        };
        var setRoute = function setRoute(rdata) {
            return $scope.bb.setRoute(rdata);
        };
        var getUrlParam = function getUrlParam(param) {
            return $window.getURIparam(param);
        };
        var base64encode = function base64encode(param) {
            return $window.btoa(param);
        };
        var broadcastItemUpdate = function broadcastItemUpdate() {
            var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

            return $scope.$broadcast("currentItemUpdate", $scope.bb.current_item, state);
        };
        var isAdminIFrame = function isAdminIFrame() {
            var location;
            if (!$scope.bb.isAdmin) {
                return false;
            }
            try {
                location = $window.parent.location.href;
                if (location && $window.parent.reload_dashboard) {
                    return true;
                } else {
                    return false;
                }
            } catch (_error) {
                return false;
            }
        };
        var reloadDashboard = function reloadDashboard() {
            return $window.parent.reload_dashboard();
        };
        var $debounce = function $debounce(tim) {
            if ($scope._debouncing) {
                return false;
            }
            tim || (tim = 100);
            $scope._debouncing = true;
            return $timeout(function () {
                return $scope._debouncing = false;
            }, tim);
        };
        var supportsTouch = function supportsTouch() {
            return Modernizr.touch;
        };
        var isMemberLoggedIn = function isMemberLoggedIn() {
            return LoginService.isLoggedIn();
        };
        var scrollTo = function scrollTo(id) {
            $location.hash(id);
            return $anchorScroll();
        };
        var redirectTo = function redirectTo(url) {
            return $window.location.href = url;
        };

        return {
            setScope: setScope,
            isAdmin: isAdmin,
            showLoaderHandler: showLoaderHandler,
            hideLoaderHandler: hideLoaderHandler,
            locationChangeStartHandler: locationChangeStartHandler,
            getPartial: getPartial,
            logout: logout,
            setRoute: setRoute,
            getUrlParam: getUrlParam,
            base64encode: base64encode,
            broadcastItemUpdate: broadcastItemUpdate,
            isAdminIFrame: isAdminIFrame,
            reloadDashboard: reloadDashboard,
            $debounce: $debounce,
            supportsTouch: supportsTouch,
            isMemberLoggedIn: isMemberLoggedIn,
            scrollTo: scrollTo,
            redirectTo: redirectTo
        };
    }
})();
'use strict';

angular.module('BB.Directives').directive('bbApiUrl', function ($rootScope, $compile, $sniffer, $timeout, $window, $location) {
    return {
        restrict: 'A',
        scope: {
            'apiUrl': '@bbApiUrl'
        },
        compile: function compile(tElem, tAttrs) {
            return {
                pre: function pre(scope, element, attrs) {
                    if (!$rootScope.bb) {
                        $rootScope.bb = {};
                    }
                    $rootScope.bb.api_url = scope.apiUrl;
                    var url = document.createElement('a');
                    url.href = scope.apiUrl;

                    if ($sniffer.msie && $sniffer.msie <= 9 || $sniffer.webkit && $sniffer.webkit < 537) {
                        if (url.host !== '' && url.host !== $location.host() && url.host !== $location.host() + ':' + $location.port()) {
                            var src = void 0;
                            if (url.protocol[url.protocol.length - 1] === ':') {
                                src = url.protocol + '//' + url.host + '/ClientProxy.html';
                            } else {
                                src = url.protocol + '://' + url.host + '/ClientProxy.html';
                            }
                            $rootScope.iframe_proxy_ready = false;

                            return $compile('<iframe id=\'ieapiframefix\' name=\'' + url.hostname + ('\' src=\'' + src + '\' style=\'visibility:false;display:none;\'></iframe>'))(scope, function (cloned, scope) {
                                cloned.bind("load", function () {
                                    $rootScope.iframe_proxy_ready = true;
                                    return $rootScope.$broadcast('iframe_proxy_ready', { iframe_proxy_ready: true });
                                });
                                return element.append(cloned);
                            });
                        }
                    }
                }
            };
        }
    };
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbBlurOnReturn
 * @restrict A
 * @scope true
 *
 * @description
 * Removes focus from an input[type=text] element when return key is pressed
 * example
 * <input type='text' bb-blur-on-return></div>
 */ //
angular.module('BB.Directives').directive('bbBlurOnReturn', function ($timeout) {
    return {
        restrict: 'A',
        require: 'ngModel',
        link: function link(scope, el, attrs) {
            return el.keydown(function (e) {
                var key = e.which || e.keyCode;
                if (key === 13 || key === '13') {
                    return $timeout(function () {
                        if (e.target) {
                            return e.target.blur();
                        }
                    }, 10);
                }
            });
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('bbBookingExport', function () {
    return {
        restrict: 'AE',
        scope: {
            booking: '=bbBookingExport'
        },
        templateUrl: '_popout_export_booking.html',
        link: function link(scope, el, attrs) {
            var setHTML = void 0;
            scope.$watch('booking', function (new_val, old_val) {
                if (new_val) {
                    return setHTML();
                }
            });
            return setHTML = function setHTML() {
                return scope.content = '<div class=\'text-center\'><a href=\'' + scope.booking.webcalLink() + '\'><img src=\'images/outlook.png\' alt=\'outlook calendar icon\' height=\'30\' width=\'30\' /><div class=\'clearfix\'></div><span>Outlook</span></a></div><p></p>' + ('<div class=\'text-center\'><a href=\'' + scope.booking.gcalLink() + '\'><img src=\'images/google.png\' alt=\'google calendar icon\' height=\'30\' width=\'30\' /><div class=\'clearfix\'></div><span>Google</span></a></div><p></p>') + ('<div class=\'text-center\'><a href=\'' + scope.booking.icalLink() + '\'><img src=\'images/ical.png\' alt=\'ical calendar icon\' height=\'30\' width=\'30\' /><div class=\'clearfix\'></div><span>iCal</span></a></div>');
            };
        }
    };
});
'use strict';

// bbCapitaliseFirstLetter
angular.module('BB.Directives').directive('bbCapitaliseFirstLetter', function () {
    return {
        restrict: 'A',
        require: ['ngModel'],
        link: function link(scope, element, attrs, ctrls) {
            var ngModel = ctrls[0];

            return scope.$watch(attrs.ngModel, function (newval, oldval) {
                if (newval) {
                    var string = scope.$eval(attrs.ngModel);
                    string = string.charAt(0).toUpperCase() + string.slice(1);
                    ngModel.$setViewValue(string);
                    ngModel.$render();
                    return;
                }
            });
        }
    };
});
'use strict';

// bbCommPref
angular.module('BB.Directives').directive('bbCommPref', function () {
    return {
        restrict: 'A',
        require: ['ngModel'],
        link: function link(scope, element, attrs, ctrls) {

            var ng_model_ctrl = ctrls[0];

            // get the default communication preference
            var comm_pref = scope.$eval(attrs.bbCommPref) || false;

            // check if it's already been set
            if (scope.bb.current_item.settings.send_email_followup != null && scope.bb.current_item.settings.send_sms_followup != null) {
                comm_pref = scope.bb.current_item.settings.send_email_followup;
            } else {
                // set to the default
                scope.bb.current_item.settings.send_email_followup = comm_pref;
                scope.bb.current_item.settings.send_sms_followup = comm_pref;
            }

            // update the model
            ng_model_ctrl.$setViewValue(comm_pref);

            // register a parser to handle model changes
            var parser = function parser(value) {
                scope.bb.current_item.settings.send_email_followup = value;
                scope.bb.current_item.settings.send_sms_followup = value;
                return value;
            };

            return ng_model_ctrl.$parsers.push(parser);
        }
    };
});
'use strict';

// bbCountTicketTypes
// returns the number of tickets selected, grouped by name
angular.module('BB.Directives').directive('bbCountTicketTypes', function ($rootScope) {
    return {
        restrict: 'A',
        scope: false,
        link: function link(scope, element, attrs) {

            var countTicketTypes = void 0;
            $rootScope.connection_started.then(function () {
                return countTicketTypes();
            });

            scope.$on("basket:updated", function (event, basket) {
                return countTicketTypes();
            });

            return countTicketTypes = function countTicketTypes(items) {

                items = scope.bb.basket.timeItems();

                var counts = [];
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Array.from(items)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var item = _step.value;

                        if (item.tickets) {
                            if (counts[item.tickets.name]) {
                                counts[item.tickets.name] += item.tickets.qty;
                            } else {
                                counts[item.tickets.name] = item.tickets.qty;
                            }
                            item.number = counts[item.tickets.name];
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                return scope.counts = counts;
            };
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('bbDate', function () {
    return {
        restrict: 'AE',
        scope: true,
        link: function link(scope, element, attrs) {

            var date = void 0;
            var track_service = attrs.bbTrackService != null;

            // set the date, first test if bbDate has been set, otherwise use the current item's
            // date. If neither are set, set the date as today
            if (attrs.bbDate) {
                date = moment(scope.$eval(attrs.bbDate));
            } else if (scope.bb && scope.bb.current_item && scope.bb.current_item.date) {
                date = scope.bb.current_item.date.date;
            } else {
                date = moment();
            }

            // if we've been instructed to track the service, set the min/max date
            if (track_service && scope.bb.current_item && scope.bb.current_item.service) {
                scope.min_date = scope.bb.current_item.service.min_advance_datetime;
                scope.max_date = scope.bb.current_item.service.max_advance_datetime;
            }

            // broadcast a dateChanged event to ensure listeners are updated
            scope.$broadcast('dateChanged', moment(date));

            // bb_date
            scope.bb_date = {

                date: date,
                js_date: date.toDate(),

                addDays: function addDays(type, amount) {
                    this.date = moment(this.date).add(amount, type);
                    this.js_date = this.date.toDate();
                    return scope.$broadcast('dateChanged', moment(this.date));
                },
                subtractDays: function subtractDays(type, amount) {
                    return this.addDays(type, -amount);
                },
                setDate: function setDate(date) {
                    this.date = date;
                    this.js_date = date.toDate();
                    return scope.$broadcast('dateChanged', moment(this.date));
                }
            };

            // watch the current_item for updates
            scope.$on("currentItemUpdate", function (event) {

                // set the min/max date if a service has been set
                if (scope.bb.current_item.service && track_service) {
                    scope.min_date = scope.bb.current_item.service.min_advance_datetime;
                    scope.max_date = scope.bb.current_item.service.max_advance_datetime;

                    // if the bb_date is before/after the min/max date, move it to the min/max date
                    if (scope.bb_date.date.isBefore(scope.min_date, 'day')) {
                        scope.bb_date.setDate(scope.min_date.clone());
                    }
                    if (scope.bb_date.date.isAfter(scope.max_date, 'day')) {
                        return scope.bb_date.setDate(scope.max_date.clone());
                    }
                }
            });

            // if the js_date has changed, update the moment date representation
            // and broadcast an update
            return scope.$watch('bb_date.js_date', function (newval, oldval) {
                var ndate = moment(newval);
                if (!scope.bb_date.date.isSame(ndate)) {
                    scope.bb_date.date = ndate;
                    if (moment(ndate).isValid()) {
                        return scope.$broadcast('dateChanged', moment(ndate));
                    }
                }
            });
        }
    };
});
'use strict';

// bbDateSplit
angular.module('BB.Directives').directive('bbDateSplit', function ($parse) {
    return {
        restrict: 'A',
        require: ['ngModel'],
        link: function link(scope, element, attrs, ctrls) {

            var ngModel = ctrls[0];

            var question = scope.$eval(attrs.bbDateSplit);

            question.date = {
                day: null,
                month: null,
                year: null,
                date: null,

                joinDate: function joinDate() {
                    if (this.day && this.month && this.year) {
                        var date_string = this.day + '/' + this.month + '/' + this.year;
                        this.date = moment(date_string, "DD/MM/YYYY");
                        date_string = this.date.toISODate();

                        ngModel.$setViewValue(date_string);
                        return ngModel.$render();
                    }
                },
                splitDate: function splitDate(date) {
                    if (date && date.isValid()) {
                        this.day = date.date();
                        this.month = date.month() + 1;
                        this.year = date.year();
                        return this.date = date;
                    }
                }
            };

            // split the date if it's already set
            if (question.answer) {
                question.date.splitDate(moment(question.answer));
            }
            if (ngModel.$viewValue) {
                return question.date.splitDate(moment(ngModel.$viewValue));
            }
        }
    };
});

// watch self to split date when it changes
// scope.$watch attrs.ngModel, (newval) ->
//   if newval
//     new_date = moment(newval)
//     if !new_date.isSame(question.date)
//        question.date.splitDate(new_date)
'use strict';

angular.module('BB.Directives').directive('bbDebounce', function ($timeout) {
    return {
        restrict: 'A',
        link: function link(scope, element, attrs) {
            var delay = 400;
            if (attrs.bbDebounce) {
                delay = attrs.bbDebounce;
            }

            return element.bind('click', function () {
                $timeout(function () {
                    return element.attr('disabled', true);
                }, 0);
                return $timeout(function () {
                    return element.attr('disabled', false);
                }, delay);
            });
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('bbDynamicFooter', function ($timeout, $bbug) {
    return function (scope, el, attrs) {

        scope.$on("page:loaded", function () {
            return $bbug('.content').css('height', 'auto');
        });

        scope.$watch(function () {
            return $bbug('.content')[0].scrollHeight;
        }, function (new_val, old_val) {
            if (new_val !== old_val) {
                return scope.setContentHeight();
            }
        });

        scope.setContentHeight = function () {
            $bbug('.content').css('height', 'auto');
            var content_height = $bbug('.content')[0].scrollHeight;
            var min_content_height = $bbug(window).innerHeight() - $bbug('.content').offset().top - $bbug('.footer').height();
            if (content_height < min_content_height) {
                return $bbug('.content').css('height', min_content_height + 'px');
            }
        };

        return $bbug(window).on('resize', function () {
            return scope.setContentHeight();
        });
    };
});
'use strict';

// bbFormResettable
// Adds field clearing behaviour to forms.
angular.module('BB.Directives').directive('bbFormResettable', function ($parse) {
    return {
        restrict: 'A',
        controller: function controller($scope, $element, $attrs) {
            $scope.inputs = [];

            $scope.resetForm = function (options) {
                if (options && options.clear_submitted) {
                    $scope[$attrs.name].submitted = false;
                }
                return Array.from($scope.inputs).map(function (input) {
                    return input.getter.assign($scope, null), input.controller.$setPristine();
                });
            };

            return {
                registerInput: function registerInput(input, ctrl) {
                    var getter = $parse(input);
                    return $scope.inputs.push({ getter: getter, controller: ctrl });
                }
            };
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('bbHeader', function ($compile) {
    return {
        link: function link(scope, element, attr) {
            scope.bb.waitForRoutes();
            return scope.$watch('bb.path_setup', function (newval, oldval) {
                if (newval) {
                    element.attr('ng-include', '\'' + scope.getPartial(attr.bbHeader) + '\'');
                    element.attr('bb-header', null);
                    return $compile(element)(scope);
                }
            });
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('bbInclude', function ($compile, $rootScope, $analytics) {
    return {
        link: function link(scope, element, attr) {
            var track_page = attr.bbTrackPage != null ? true : false;
            return scope.$watch('bb.path_setup', function (newval, oldval) {
                if (newval) {
                    element.attr('ng-include', '\'' + scope.getPartial(attr.bbInclude) + '\'');
                    element.attr('bb-include', null);
                    $compile(element)(scope);
                    if (track_page) {
                        $analytics.pageTrack(attr.bbInclude);
                    }
                }
            });
        }
    };
});
'use strict';

// bbLocalNumber
// Adds a formatter that prepends the model value with an appropriate prefix. This is useful for
// nicely formatting numbers where the prefix has been stripped, i.e. '7875123456'
// Adds a parser to store the user entered value which is then used in the formatter
angular.module('BB.Directives').directive('bbLocalNumber', function ($filter) {
    return {
        restrict: 'A',
        scope: {},
        require: 'ngModel',
        link: function link(scope, element, attrs, ctrl) {

            scope.userinput_mobile = null;

            var storeNumber = function storeNumber(value) {
                if (value) {
                    scope.userinput_mobile = value;
                }
                return value;
            };

            var prettyifyNumber = function prettyifyNumber(value) {
                if (scope.userinput_mobile) {
                    return value = scope.userinput_mobile;
                } else {
                    return $filter('local_phone_number')(value);
                }
            };

            ctrl.$parsers.push(storeNumber);
            return ctrl.$formatters.push(prettyifyNumber);
        }
    };
});
'use strict';

// bbPadWithZeros
// Adds a formatter that prepends the model value with the specified number of zeros
angular.module('BB.Directives').directive('bbPadWithZeros', function () {
    return {
        restrict: 'A',
        require: 'ngModel',
        link: function link(scope, element, attrs, ctrl) {

            var options = scope.$eval(attrs.bbPadWithZeros) || {};
            var how_many = options.how_many || 2;

            var padNumber = function padNumber(value) {
                value = String(value);
                if (value && value.length < how_many) {
                    var padding = "";
                    for (var index = 1, end = how_many - value.length, asc = 1 <= end; asc ? index <= end : index >= end; asc ? index++ : index--) {
                        padding += "0";
                    }
                    value = padding.concat(value);
                }
                return value;
            };

            return ctrl.$formatters.push(padNumber);
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('bbPriceFilter', function (PathSvc) {
    return {
        restrict: 'AE',
        replace: true,
        scope: false,
        require: '^?bbServices',
        templateUrl: function templateUrl(element, attrs) {
            return PathSvc.directivePartial("_price_filter");
        },
        controller: function controller($scope, $attrs) {
            $scope.$watch('items', function (new_val, old_val) {
                if (new_val) {
                    return setPricefilter(new_val);
                }
            });

            var setPricefilter = function setPricefilter(items) {
                $scope.price_array = _.uniq(_.map(items, function (item) {
                    return item.price / 100 || 0;
                }));
                $scope.price_array.sort(function (a, b) {
                    return a - b;
                });
                return suitable_max();
            };

            var suitable_max = function suitable_max() {
                var top_number = _.last($scope.price_array);
                var max_number = function () {
                    switch (false) {
                        case top_number >= 1:
                            return 0;
                        case top_number >= 11:
                            return 10;
                        case top_number >= 51:
                            return 50;
                        case top_number >= 101:
                            return 100;
                        case top_number >= 1000:
                            return Math.ceil(top_number / 100) * 100;
                    }
                }();
                var min_number = 0;
                $scope.price_options = {
                    min: min_number,
                    max: max_number
                };
                return $scope.filters.price = { min: min_number, max: max_number };
            };

            $scope.$watch('filters.price.min', function (new_val, old_val) {
                if (new_val !== old_val) {
                    return $scope.filterChanged();
                }
            });

            return $scope.$watch('filters.price.max', function (new_val, old_val) {
                if (new_val !== old_val) {
                    return $scope.filterChanged();
                }
            });
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('bbPrintPage', function ($window, $timeout) {
    return {
        restrict: 'A',
        link: function link(scope, element, attr) {
            if (attr.bbPrintPage) {
                return scope.$watch(attr.bbPrintPage, function (newVal, oldVal) {
                    return $timeout(function () {
                        return $window.print();
                    }, 3000);
                });
            }
        }
    };
});
'use strict';

// Form directive to allow users to specify if they want the form to raise alerts when
// there is invalid input.
angular.module('BB.Directives').directive('bbRaiseAlertWhenInvalid', function ($compile) {
    return {
        require: '^form',
        link: function link(scope, element, attr, ctrl) {
            ctrl.raise_alerts = true;

            var options = scope.$eval(attr.bbRaiseAlertWhenInvalid);
            if (options && options.alert) {
                return ctrl.alert = options.alert;
            }
        }
    };
});
'use strict';

// bbResettable
// Registers inputs with the bbFormResettable controller allowing them to be cleared
angular.module('BB.Directives').directive('bbResettable', function () {
    return {
        restrict: 'A',
        require: ['ngModel', '^bbFormResettable'],
        link: function link(scope, element, attrs, ctrls) {
            var ngModelCtrl = ctrls[0];
            var formResettableCtrl = ctrls[1];
            return formResettableCtrl.registerInput(attrs.ngModel, ngModelCtrl);
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('ngConfirmClick', function () {
    return {
        link: function link(scope, element, attr) {
            var msg = attr.ngConfirmClick || "Are you sure?";
            var clickAction = attr.ngConfirmedClick;
            return element.bind('click', function (event) {
                if (window.confirm(msg)) {
                    return scope.$eval(clickAction);
                }
            });
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('ngDelayed', function ($compile) {
    return {
        link: function link(scope, element, attr) {
            return scope[attr.ngDelayedWatch].then(function (logged) {
                element.attr(attr.ngDelayed, attr.ngDelayedValue);
                element.attr('ng-delayed-value', null);
                element.attr('ng-delayed-watch', null);
                element.attr('ng-delayed', null);
                $compile(element)(scope);
                if (attr.ngDelayedReady) {
                    return scope[attr.ngDelayedReady].resolve(true);
                }
            });
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('ngInitial', function () {
    return {
        restrict: 'A',
        controller: ['$scope', '$element', '$attrs', '$parse', function ($scope, $element, $attrs, $parse) {
            var val = $attrs.ngInitial || $attrs.value;
            var getter = $parse($attrs.ngModel);
            var setter = getter.assign;
            if (val === "true") {
                val = true;
            } else if (val === "false") {
                val = false;
            }
            return setter($scope, val);
        }]
    };
});
'use strict';

angular.module('BB.Directives').directive('ngValidInclude', function ($compile) {
    return {
        link: function link(scope, element, attr) {
            return scope[attr.watchValue].then(function (logged) {
                element.attr('ng-include', attr.ngValidInclude);
                element.attr('ng-valid-include', null);
                return $compile(element)(scope);
            });
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('bbCurrencyField', function ($filter) {
    return {
        restrict: 'A',
        require: 'ngModel',
        link: function link(scope, element, attrs, ctrl) {

            var convertToCurrency = function convertToCurrency(value) {
                return value / 100;
            };

            var convertToInteger = function convertToInteger(value) {
                return value * 100;
            };

            ctrl.$formatters.push(convertToCurrency);
            return ctrl.$parsers.push(convertToInteger);
        }
    };
});
"use strict";

// Directive for testing if a input is focused
// Provided by http://www.ng-newsletter.com/posts/validations.html
angular.module('BB.Directives').directive("bbFocus", [function () {
    var FOCUS_CLASS = "bb-focused";
    return {
        restrict: "A",
        require: "ngModel",
        link: function link(scope, element, attrs, ctrl) {
            ctrl.$focused = false;
            return element.bind("focus", function (evt) {
                element.addClass(FOCUS_CLASS);
                return scope.$apply(function () {
                    return ctrl.$focused = true;
                });
            }).bind("blur", function (evt) {
                element.removeClass(FOCUS_CLASS);
                return scope.$apply(function () {
                    return ctrl.$focused = false;
                });
            });
        }
    };
}]);
'use strict';

/**
 * @ngdoc directive
 * @name BB.Directives:bbForm
 * @restrict A
 * @scope true
 *
 * @description
 * Use with forms to add enhanced validation.
 * When using with ng-form, submitForm needs to be called manually as submit event is not raised.
 *
 *
 * <div ng-form name="example_form" bb-form></div>
 * <form name="example_form" bb-form></form>
 */
var bbFormDirective = function bbFormDirective($bbug, $window, ValidatorService, $timeout, GeneralOptions, scrollIntercepter) {
    'ngInject';

    var link = function link(scope, elem, attrs, ctrls) {

        var $bbPageCtrl = null;
        var $formCtrl = null;

        var init = function init() {

            $formCtrl = ctrls[0];
            $bbPageCtrl = ctrls[1];
            scope.submitForm = submitForm;
            if (attrs.disableAutoSubmit == null) elem.on("submit", submitForm); // doesn't work with ng-form just regular form
        };

        // marks child forms as submitted
        // See https://github.com/angular/angular.js/issues/10071
        var setSubmitted = function setSubmitted(form) {

            form.$setSubmitted();
            form.submitted = true; // DEPRECATED - $submitted should be used in favour
            angular.forEach(form, function (item) {
                if (item && item.$$parentForm === form && item.$setSubmitted) setSubmitted(item);
            });
        };

        var submitForm = function submitForm() {

            setSubmitted($formCtrl);

            $timeout(scrollAndFocusOnInvalid, 100);

            var isValid = ValidatorService.validateForm($formCtrl);

            if (isValid && $bbPageCtrl != null && attrs.noRoute == null) serveBBPage();

            return isValid;
        };

        var serveBBPage = function serveBBPage() {

            var route = attrs.bbFormRoute;
            $bbPageCtrl.$scope.checkReady();

            if (route != null && route.length > 0) {
                $bbPageCtrl.$scope.routeReady(route);
            } else {
                $bbPageCtrl.$scope.routeReady();
            }
        };

        var scrollAndFocusOnInvalid = function scrollAndFocusOnInvalid() {

            var invalidFormGroup = elem.find('.has-error:first');

            if (invalidFormGroup && invalidFormGroup.length > 0 && !$formCtrl.raise_alerts) {

                scrollIntercepter.scrollToElement(invalidFormGroup, 1000, 'form:invalid');

                var invalidInput = invalidFormGroup.find('.ng-invalid');
                invalidInput.focus();
            }
        };

        init();
    };

    return {
        restrict: 'A',
        require: ['^form', '?^^bbPage'],
        scope: 'true',
        link: link
    };
};

angular.module('BB.Directives').directive('bbForm', bbFormDirective);
"use strict";

angular.module('BB.Directives').directive("bbInputGroup", function () {
    return {
        restrict: "A",
        require: 'ngModel',
        link: function link(scope, elem, attrs, ngModel) {

            // return if the input has already been registered
            if (scope.input_manger.inputs.indexOf(ngModel.$name) >= 0) {
                return;
            }

            // register the input
            scope.input_manger.registerInput(ngModel, attrs.bbInputGroup);

            // watch the input for changes
            return scope.$watch(attrs.ngModel, function (newval, oldval) {
                if (newval === !oldval) {
                    return scope.input_manger.validateInputGroup(attrs.bbInputGroup);
                }
            });
        }
    };
});
'use strict';

// bbInputGroupManager
// Allows you you register inputs
angular.module('BB.Directives').directive('bbInputGroupManager', function (ValidatorService) {
    return {
        restrict: 'A',
        controller: function controller($scope, $element, $attrs) {
            //$scope.
            $scope.input_manger = {

                input_groups: {},
                inputs: [],

                registerInput: function registerInput(input, name) {

                    // return if the input has already been registered
                    if (this.inputs.indexOf(input.$name) >= 0) {
                        return;
                    }

                    this.inputs.push(input.$name);

                    // group the input by the name provided
                    if (!this.input_groups[name]) {
                        this.input_groups[name] = {
                            inputs: [],
                            valid: false
                        };
                    }

                    return this.input_groups[name].inputs.push(input);
                },
                validateInputGroup: function validateInputGroup(name) {
                    var is_valid = false;
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = Array.from(this.input_groups[name].inputs)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var input = _step.value;

                            is_valid = input.$modelValue;
                            if (is_valid) {
                                break;
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }

                    if (is_valid === !this.input_groups[name].valid) {
                        var _iteratorNormalCompletion2 = true;
                        var _didIteratorError2 = false;
                        var _iteratorError2 = undefined;

                        try {

                            for (var _iterator2 = Array.from(this.input_groups[name].inputs)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                input = _step2.value;

                                input.$setValidity(input.$name, is_valid);
                            }
                        } catch (err) {
                            _didIteratorError2 = true;
                            _iteratorError2 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                    _iterator2.return();
                                }
                            } finally {
                                if (_didIteratorError2) {
                                    throw _iteratorError2;
                                }
                            }
                        }

                        return this.input_groups[name].valid = is_valid;
                    }
                }
            };

            // on form submit, validate all input groups
            return $element.on("submit", function () {
                return function () {
                    var result = [];
                    for (var input_group in $scope.input_manger.input_groups) {
                        result.push($scope.input_manger.validateInputGroup(input_group));
                    }
                    return result;
                }();
            });
        }
    };
});
"use strict";

// Input match test
angular.module('BB.Directives').directive("bbMatchInput", function () {
    return {
        restrict: "A",
        require: 'ngModel',
        link: function link(scope, element, attrs, ctrl, ngModel) {

            scope.$watch(attrs.bbMatchInput, function () {
                scope.val_1 = scope.$eval(attrs.bbMatchInput);
                return compare(ctrl.$viewValue);
            });

            var compare = function compare(value) {
                ctrl.$setValidity('match', scope.val_1 === value);
                return value;
            };

            return ctrl.$parsers.push(compare);
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('bbQuestionLabel', function ($compile) {
    return {
        transclude: false,
        restrict: 'A',
        scope: false,
        link: function link(scope, element, attrs) {
            return scope.$watch(attrs.bbQuestionLabel, function (question) {
                if (question) {
                    if (question.detail_type === "check" || question.detail_type === "check-price") {
                        return element.html("");
                    }
                }
            });
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('bbQuestionLine', function ($compile) {
    return {
        transclude: false,
        restrict: 'A',
        link: function link(scope, element, attrs) {
            if (scope.question.detail_type === "heading") {
                var elm = "";
                if (scope.question.name.length > 0) {
                    elm += '<div class=\'bb-question-heading\'>' + scope.question.name + '</div>';
                }
                if (scope.question.help_text && scope.question.help_text.length > 0) {
                    elm += '<div class=\'bb-question-help-text\'>' + scope.question.help_text + '</div>';
                }
                element.html(elm);
            }

            // are we using a completely custom question
            if (scope.idmaps && (scope.idmaps[scope.question.detail_type] && scope.idmaps[scope.question.detail_type].block || scope.idmaps[scope.question.id] && scope.idmaps[scope.question.id].block)) {
                var index = scope.idmaps[scope.question.id] ? scope.question.id : scope.question.detail_type;
                var html = scope.$parent.idmaps[index].html;

                return $compile(html)(scope, function (cloned, scope) {
                    return element.replaceWith(cloned);
                });
            }
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('bbQuestionLink', function ($compile) {
    return {
        transclude: false,
        restrict: 'A',
        scope: true,
        link: function link(scope, element, attrs) {
            var id = parseInt(attrs.bbQuestionLink);
            return scope.$watch("question_set", function (newval, oldval) {
                if (newval) {
                    return function () {
                        var result = [];
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = Array.from(scope.question_set)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var q = _step.value;

                                var item = void 0;
                                if (q.id === id) {
                                    scope.question = q;
                                    element.attr('ng-model', "question.answer");
                                    element.attr('bb-question-link', null);
                                    item = $compile(element)(scope);
                                }
                                result.push(item);
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return) {
                                    _iterator.return();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }

                        return result;
                    }();
                }
            });
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('bbQuestionSet', function ($compile) {
    return {
        transclude: false,
        restrict: 'A',
        scope: true,
        link: function link(scope, element, attrs) {
            var set = attrs.bbQuestionSet;
            element.addClass('ng-hide');
            return scope.$watch(set, function (newval, oldval) {
                if (newval) {
                    scope.question_set = newval;
                    return element.removeClass('ng-hide');
                }
            });
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('bbQuestionSetup', function () {
    return {
        restrict: 'A',
        terminal: true,
        priority: 1000,

        link: function link(scope, element, attrs) {
            var idmaps = {};
            var iterable = element.children();
            for (var index = 0; index < iterable.length; index++) {
                var child = iterable[index];
                var id = $(child).attr("bb-question-id");
                var block = false;
                if ($(child).attr("bb-replace-block")) {
                    block = true;
                }
                // replace form name with something unique to ensure custom questions get registered
                // with the form controller and subjected to validation
                child.innerHTML = child.innerHTML.replace(/question_form/g, 'question_form_' + index);
                idmaps[id] = { id: id, html: child.innerHTML, block: block };
            }
            scope.idmaps = idmaps;
            return element.replaceWith("");
        }
    };
});
'use strict';

angular.module('BB.Directives').directive("cardSecurityCode", function () {

    var linker = function linker(scope, element, attributes) {
        return scope.$watch('cardType', function (newValue) {
            if (newValue === 'american_express') {
                element.attr('maxlength', 4);
                return element.attr('placeholder', "••••");
            } else {
                element.attr('maxlength', 3);
                return element.attr('placeholder', "•••");
            }
        });
    };

    return {
        restrict: "AC",
        link: linker,
        scope: {
            'cardType': '='
        }
    };
});
'use strict';

angular.module('BB.Directives').directive("creditCardNumber", function () {

    var getCardType = function getCardType(ccnumber) {
        if (!ccnumber) {
            return '';
        }
        ccnumber = ccnumber.toString().replace(/\s+/g, '');
        if (/^(34)|^(37)/.test(ccnumber)) {
            return "american_express";
        }
        if (/^(62)|^(88)/.test(ccnumber)) {
            return "china_unionpay";
        }
        if (/^30[0-5]/.test(ccnumber)) {
            return "diners_club_carte_blanche";
        }
        if (/^(2014)|^(2149)/.test(ccnumber)) {
            return "diners_club_enroute";
        }
        if (/^36/.test(ccnumber)) {
            return "diners_club_international";
        }
        if (/^(6011)|^(622(1(2[6-9]|[3-9][0-9])|[2-8][0-9]{2}|9([01][0-9]|2[0-5])))|^(64[4-9])|^65/.test(ccnumber)) {
            return "discover";
        }
        if (/^35(2[89]|[3-8][0-9])/.test(ccnumber)) {
            return "jcb";
        }
        if (/^(6304)|^(6706)|^(6771)|^(6709)/.test(ccnumber)) {
            return "laser";
        }
        if (/^(5018)|^(5020)|^(5038)|^(5893)|^(6304)|^(6759)|^(6761)|^(6762)|^(6763)|^(0604)/.test(ccnumber)) {
            return "maestro";
        }
        if (/^5[1-5]/.test(ccnumber)) {
            return "master";
        }
        if (/^4/.test(ccnumber)) {
            return "visa";
        }
        if (/^(4026)|^(417500)|^(4405)|^(4508)|^(4844)|^(4913)|^(4917)/.test(ccnumber)) {
            return "visa_electron";
        }
    };

    var isValid = function isValid(ccnumber) {
        if (!ccnumber) {
            return false;
        }
        ccnumber = ccnumber.toString().replace(/\s+/g, '');
        var len = ccnumber.length;
        var mul = 0;
        var prodArr = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]];
        var sum = 0;
        while (len--) {
            sum += prodArr[mul][parseInt(ccnumber.charAt(len), 10)];
            mul ^= 1;
        }
        return sum % 10 === 0 && sum > 0;
    };

    var linker = function linker(scope, element, attributes, ngModel) {
        return scope.$watch(function () {
            return ngModel.$modelValue;
        }, function (newValue) {
            ngModel.$setValidity('card_number', isValid(newValue));
            scope.cardType = getCardType(newValue);
            if (newValue != null && newValue.length === 16) {
                if (ngModel.$invalid) {
                    element.parent().addClass('has-error');
                    return element.parent().removeClass('has-success');
                } else {
                    element.parent().removeClass('has-error');
                    return element.parent().addClass('has-success');
                }
            } else {
                return element.parent().removeClass('has-success');
            }
        });
    };

    return {
        restrict: "C",
        require: "ngModel",
        link: linker,
        scope: {
            'cardType': '='
        }
    };
});
"use strict";

// Min/Max directives for use with number inputs
// Although angular provides min/max directives when using a HTML number input, the control does not validate if the field is actually a number
// so we have to use a text input with a ng-pattern that only allows numbers.
// http://jsfiddle.net/g/s5gKC/


angular.module('BB.Directives').directive("ngMax", function () {
    return {
        restrict: "A",
        require: "ngModel",
        link: function link(scope, elem, attr, ctrl) {

            var maxValidator = function maxValidator(value) {
                var max = scope.$eval(attr.ngMax); // or Infinity
                ctrl.$setValidity("ngMax", angular.isUndefined(value) || value === "" || value === null || value !== value || value <= max);
                return value;
            };

            ctrl.$parsers.push(maxValidator);
            ctrl.$formatters.push(maxValidator);
        }
    };
});
"use strict";

// Min/Max directives for use with number inputs
// Although angular provides min/max directives when using a HTML number input, the control does not validate if the field is actually a number
// so we have to use a text input with a ng-pattern that only allows numbers.
// http://jsfiddle.net/g/s5gKC/

angular.module('BB.Directives').directive("ngMin", function () {
    return {
        restrict: "A",
        require: "ngModel",
        link: function link(scope, elem, attr, ctrl) {

            var minValidator = function minValidator(value) {
                var min = scope.$eval(attr.ngMin) || 0;
                ctrl.$setValidity("ngMin", angular.isUndefined(value) || value === "" || value === null || value !== value || value >= min);
                return value;
            };

            ctrl.$parsers.push(minValidator);
            ctrl.$formatters.push(minValidator);
        }
    };
});
'use strict';

// bbAddressMap
// Adds behaviour to select first invalid input
angular.module('BB.Directives').directive('bbAddressMap', function ($document) {
    return {
        restrict: 'A',
        scope: true,
        replace: true,
        controller: function controller($scope, $element, $attrs, uiGmapGoogleMapApi) {

            $scope.isDraggable = $document.width() > 480;

            return uiGmapGoogleMapApi.then(function (maps) {
                maps.visualRefresh = true;
                return $scope.$watch($attrs.bbAddressMap, function (new_val, old_val) {

                    if (!new_val) {
                        return;
                    }

                    var map_item = new_val;

                    $scope.map = {
                        center: {
                            latitude: map_item.lat,
                            longitude: map_item.long
                        },
                        zoom: 15
                    };

                    $scope.options = {
                        scrollwheel: false,
                        draggable: $scope.isDraggable
                    };

                    return $scope.marker = {
                        id: 0,
                        coords: {
                            latitude: map_item.lat,
                            longitude: map_item.long
                        }
                    };
                });
            });
        }
    };
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbBackgroundImage
 * @restrict A
 * @scope true
 *
 * @description
 * Adds a background-image to an element

 * @param
 * {string} url url
 *
 *
 * <div bb-background-image='images/example.jpg'></div>
 */ //
angular.module('BB.Directives').directive('bbBackgroundImage', function () {
    return {
        restrict: 'A',
        scope: true,
        link: function link(scope, el, attrs) {
            var killWatch = void 0;
            if (!attrs.bbBackgroundImage || attrs.bbBackgroundImage === "") {
                return;
            }
            return killWatch = scope.$watch(attrs.bbBackgroundImage, function (new_val, old_val) {
                if (new_val) {
                    killWatch();
                    return el.css('background-image', 'url("' + new_val + '")');
                }
            });
        }
    };
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbCapacityView
 * @restrict A
 * @description
 * Assigns an appropriate description of ticket availability based
 * on the value of the "Select spaces view" dropdown in the admin console
 * @param
 * {object} The event object
 * @attribute ticket-type-singular
 * {String} Custom name for the ticket
 *
 * <span bb-capacity-view='event' ticket-type-singular='seat'></span>
 *  _result
 * <span bb-capacity-view='event' ticket-type-singular='seat' class='ng-binding'>5 of 10 seats available</span>
 */ //
angular.module('BB.Directives').directive('bbCapacityView', function () {
    return {
        restrict: 'A',
        template: '{{capacity_view_description}}',
        link: function link(scope, el, attrs) {
            var killWatch = void 0;
            var ticket_type = attrs.ticketTypeSingular || "ticket";
            return killWatch = scope.$watch(attrs.bbCapacityView, function (item) {
                if (item) {
                    killWatch();

                    var num_spaces_plural = item.num_spaces > 1 ? "s" : "";
                    var spaces_left_plural = item.spaces_left > 1 ? "s" : "";

                    switch (item.chain.capacity_view) {
                        case "NUM_SPACES":
                            return scope.capacity_view_description = scope.ticket_spaces = item.num_spaces + " " + ticket_type + num_spaces_plural;
                        case "NUM_SPACES_LEFT":
                            return scope.capacity_view_description = scope.ticket_spaces = item.spaces_left + " " + ticket_type + spaces_left_plural + " available";
                        case "NUM_SPACES_AND_SPACES_LEFT":
                            return scope.capacity_view_description = scope.ticket_spaces = item.spaces_left + " of " + item.num_spaces + " " + ticket_type + num_spaces_plural + " available";
                    }
                }
            });
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('bbContent', function ($compile) {
    return {
        transclude: false,
        restrict: 'A',
        link: function link(scope, element, attrs) {
            element.attr('ng-include', "bb_main");
            element.attr('onLoad', "initPage()");
            element.attr('bb-content', null);
            element.attr('ng-hide', "hide_page");
            scope.initPage = function () {
                scope.setPageLoaded();
                return scope.setLoadingPage(false);
            };

            return $compile(element)(scope);
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('bbLoading', function ($compile, $timeout, $bbug, LoadingService) {
    return {
        link: function link(scope, element, attrs) {
            scope.scopeLoaded = LoadingService.areScopesLoaded(scope);
            element.attr("ng-hide", "scopeLoaded");
            element.attr("bb-loading", null);

            var positionLoadingIcon = function positionLoadingIcon() {
                var loading_icon = $bbug('.bb-loader').find('#loading_icon');
                var wait_graphic = $bbug('.bb-loader').find('#wait_graphic');
                var modal_open = $bbug('[ng-app]').find('#bb').hasClass('modal-open');

                if (modal_open) {
                    return $timeout(function () {
                        var center = $bbug('[ng-app]').find('.modal-dialog').height() || $bbug('[ng-app]').find('.modal-content').height() || $bbug('[ng-app]').find('.modal').height();
                        center = center / 2 - wait_graphic.height() / 2;
                        return loading_icon.css("padding-top", center + "px");
                    }, 50);
                } else {
                    var center = $(window).innerHeight() / 2 - wait_graphic.height() / 2;
                    return loading_icon.css("padding-top", center + "px");
                }
            };

            positionLoadingIcon();
            $bbug(window).on("resize", function () {
                return positionLoadingIcon();
            });
            scope.$on("page:loaded", function () {
                return positionLoadingIcon();
            });

            $compile(element)(scope);
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('bbMergeDuplicateQuestions', function () {
    return {
        restrict: 'A',
        scope: true,
        controller: function controller($scope, $rootScope) {

            $scope.questions = {};

            return $rootScope.$on("item_details:loaded", function () {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {

                    for (var _iterator = Array.from($scope.bb.stacked_items)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var item = _step.value;

                        if (item.item_details && item.item_details.questions) {
                            item.item_details.hide_questions = false;
                            var _iteratorNormalCompletion2 = true;
                            var _didIteratorError2 = false;
                            var _iteratorError2 = undefined;

                            try {
                                for (var _iterator2 = Array.from(item.item_details.questions)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                    var question = _step2.value;

                                    if ($scope.questions[question.id]) {
                                        // this is a duplicate, setup clone and hide it
                                        item.setCloneAnswers($scope.questions[question.id].item);
                                        item.item_details.hide_questions = true;
                                        break;
                                    } else {
                                        $scope.questions[question.id] = { question: question, item: item };
                                    }
                                }
                            } catch (err) {
                                _didIteratorError2 = true;
                                _iteratorError2 = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                        _iterator2.return();
                                    }
                                } finally {
                                    if (_didIteratorError2) {
                                        throw _iteratorError2;
                                    }
                                }
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                return $scope.has_questions = _.pluck($scope.questions, 'question').length > 0;
            });
        }
    };
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbModal
 * @restrict A
 * @scope true
 *
 * @description
 * Use with modal templates to ensure modal height does not exceed window height

 *
 *
 * <div bb-modal></div>
 */ //
angular.module('BB.Directives').directive('bbModal', function ($window, $bbug, $timeout) {
    return {
        restrict: 'A',
        scope: true,
        link: function link(scope, elem, attrs) {

            var deregisterWatcher = void 0;
            return $timeout(function () {
                return elem.parent().parent().parent().css("z-index", 999999);
            },
            // watch modal height to ensure it does not exceed window height
            deregisterWatcher = scope.$watch(function () {
                var modal_padding = void 0;
                var height = elem.height();
                if ($bbug(window).width() >= 769) {
                    modal_padding = 200;
                } else {
                    modal_padding = 20;
                }
                if (height > $bbug(window).height()) {
                    var new_height = $bbug(window).height() - modal_padding;
                    elem.css({
                        "height": new_height + "px",
                        "overflow-y": "scroll"
                    });
                    return deregisterWatcher();
                }
            }));
        }
    };
});
'use strict';

// bbScrollTo
// Allows you to scroll to a specific element
angular.module('BB.Directives').directive('bbScrollTo', function ($rootScope, AppConfig, BreadcrumbService, $bbug, $window, GeneralOptions, viewportSize, scrollIntercepter) {
    return {
        transclude: false,
        restrict: 'A',
        link: function link(scope, element, attrs) {

            var scrollToCallback = void 0;
            var evnts = attrs.bbScrollTo.split(',');
            var always_scroll = attrs.bbAlwaysScroll != null || false;
            var bb_transition_time = attrs.bbTransitionTime != null ? parseInt(attrs.bbTransitionTime, 10) : 500;

            if (angular.isArray(evnts)) {
                angular.forEach(evnts, function (evnt) {
                    return scope.$on(evnt, function (e) {
                        return scrollToCallback(evnt);
                    });
                });
            } else {
                scope.$on(evnts, function (e) {
                    return scrollToCallback(evnts);
                });
            }

            var isElementInView = function isElementInView(el) {
                return el.offset().top > $bbug('body').scrollTop() && el.offset().top < $bbug('body').scrollTop() + $bbug(window).height();
            };

            return scrollToCallback = function scrollToCallback(evnt) {
                var scroll_to_element = void 0;
                if (evnt === "page:loaded" && viewportSize.isXS() && $bbug('[data-scroll-id="' + AppConfig.uid + '"]').length) {
                    scroll_to_element = $bbug('[data-scroll-id="' + AppConfig.uid + '"]');
                } else {
                    scroll_to_element = $bbug(element);
                }

                var current_step = BreadcrumbService.getCurrentStep();

                // if the event is page:loaded or the element is not in view, scroll to it
                if (scroll_to_element) {
                    if (evnt === "page:loaded" && current_step > 1 || always_scroll || evnt === "widget:restart" || !isElementInView(scroll_to_element) && scroll_to_element.offset().top !== 0) {
                        scrollIntercepter.scrollToElement(scroll_to_element, bb_transition_time, evnt);
                    }
                }
            };
        }
    };
});
'use strict';

// bbSlotGrouper
// group time slots together based on a given start time and end time
angular.module('BB.Directives').directive('bbSlotGrouper', function () {
    return {
        restrict: 'A',
        scope: true,
        link: function link(scope, element, attrs) {
            var slots = scope.$eval(attrs.slots);
            if (!slots) {
                return;
            }
            scope.grouped_slots = [];
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = Array.from(slots)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var slot = _step.value;

                    if (slot.time >= scope.$eval(attrs.startTime) && slot.time < scope.$eval(attrs.endTime)) {
                        scope.grouped_slots.push(slot);
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return scope.has_slots = scope.grouped_slots.length > 0;
        }
    };
});
'use strict';

(function () {

    /***
     * @ngdoc directive
     * @name BB.Directives:bbTimeZone
     * @restrict A
     * @description
     * Timezone name helper
     * @param {String} time_zone_name The name of the time zone
     * @param {Boolean} is_time_zone_diff Indicates if the users time zone is different to the company time zone
     *
     * <div bb-time-zone></div>
     *  _result
     * <span bb-time-zone>All times are shown in British Summer Time.</span>
     */ //
    angular.module('BB.Directives').directive('bbTimeZone', bbTimeZoneDirective);

    function bbTimeZoneDirective() {
        return {
            restrict: 'A',
            controllerAs: '$tzCtrl',
            templateUrl: '_time_zone.html',
            controller: function controller(CompanyStoreService, bbTimeZone, bbi18nOptions) {

                var company_time_zone = CompanyStoreService.time_zone;
                this.time_zone_name = moment().tz(bbTimeZone.getDisplay()).format('zz');

                //  if not using local time zone and user time zone is not same as companies
                if (!bbi18nOptions.timeZone.useBrowser && bbTimeZone.getDisplay() !== company_time_zone) {
                    return this.is_time_zone_diff = true;
                }
            }
        };
    }
})();
'use strict';

angular.module('BB.Directives').directive('bbWaitFor', function ($compile) {
    return {
        transclude: false,
        restrict: 'A',
        priority: 800,
        link: function link(scope, element, attrs) {
            var name = attrs.bbWaitVar;
            if (!name) {
                name = "allDone";
            }
            scope[name] = false;
            var prom = scope.$eval(attrs.bbWaitFor);
            if (!prom) {
                scope[name] = true;
            } else {
                prom.then(function () {
                    return scope[name] = true;
                });
            }
        }
    };
});
'use strict';

// there is a some sort of 'redraw' bug in IE with select menus which display
// more than one option and the options are dynamically inserted. So only some of
// the text is displayed in the option until the select element recieves focus,
// at which point all the text is disaplyed. comment out the focus() calls below
// to see what happens.
angular.module('BB.Directives').directive('ngOptions', function ($sniffer, $rootScope) {
    return {
        restrict: 'A',
        link: function link(scope, el, attrs) {
            var size = parseInt(attrs['size'], 10);

            if (!isNaN(size) && size > 1 && $sniffer.msie) {
                return $rootScope.$on('loading:finished', function () {
                    el.focus();
                    return $('body').focus();
                });
            }
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('bbPaypal', function (PathSvc) {
    return {
        restrict: 'A',
        replace: true,
        scope: {
            ppDetails: "=bbPaypal"
        },
        templateUrl: PathSvc.directivePartial("paypal_button"),
        link: function link(scope, element, attrs) {
            scope.inputs = [];

            if (!scope.ppDetails) {
                return;
            }

            var keys = _.keys(scope.ppDetails);
            //  convert the paypal data to an array of input objects
            return _.each(keys, function (keyName) {
                var obj = {
                    name: keyName,
                    value: scope.ppDetails[keyName]
                };
                return scope.inputs.push(obj);
            });
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('bbPaypalExpressButton', function ($compile, $sce, $http, $templateCache, $q, $log, $window, UriTemplate) {

    return {
        restrict: 'EA',
        replace: true,
        template: '<a ng-href="{{href}}" ng-click="showLoader()">Pay</a>',
        scope: {
            total: '=',
            bb: '=',
            decideNextPage: '=',
            paypalOptions: '=bbPaypalExpressButton',
            notLoaded: '='
        },
        link: function link(scope, element, attributes) {
            var total = scope.total;
            var paypalOptions = scope.paypalOptions;

            scope.href = new UriTemplate(total.$link('paypal_express').href).fillFromObject(paypalOptions);

            return scope.showLoader = function () {
                if (scope.notLoaded) {
                    return scope.notLoaded(scope);
                }
            };
        }
    };
});
'use strict';

//  the default behavior for the 'click' event for the popover is to hide the
//  popover if the click occurs on the element but it doesn't hide if you click
//  anywhere else as the event has to occur on the element. so we add additional
//  check on the container to check if the popover is still open on a click
//  event. clearly this will fail if the event propogation is stopped in the
//  code, but that is bad practise so shouldn't be happening.
angular.module('BB.Directives').directive('popover', function () {
    var openElement = null;
    var openScope = null;

    $('div[ng-controller="BBCtrl"]').off('.bbtooltip').on('click.bbtooltip', function (e) {
        var target = $(e.target).closest('[popover]')[0];
        // if users clicks elsewhere, hide any open tooltip
        if (!target && openElement && openScope) {
            $(openElement).next('.popover').remove();
            openScope.tt_isOpen = false;
        }
        // return true unless coffeescript returns false which stops things working.
        return true;
    });

    return {
        restrict: 'EA',
        priority: -1000,
        link: function link(scope, element) {
            element.on('click.bbtooltip', function (e) {
                // do nothing if user clicks on the an element which is already
                // displaying a tooltip
                if (openElement === $(e.target).closest('[popover]')[0]) {
                    e.preventDefault();
                    return;
                }

                // remove any open tooltips
                if (openElement && openScope) {
                    $(openElement).next('.popover').remove();
                    openScope.tt_isOpen = false;
                }
                // then store this element as the element with the open tooltip
                openElement = element[0];
                return openScope = scope;
            });

            return scope.$on('$destroy', function () {
                return $(element).off('.bbtooltip');
            });
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('pricepicker', function () {

    var controller = function controller($scope) {
        return $scope.$watch('price', function (price) {
            if (price != null) {
                return $scope.updateModel(price);
            }
        });
    };

    var link = function link(scope, element, attrs, ngModel) {

        ngModel.$render = function () {
            if (ngModel.$viewValue) {
                return scope.price = ngModel.$viewValue;
            }
        };

        return scope.updateModel = function (value) {
            return ngModel.$setViewValue(value);
        };
    };

    return {
        require: 'ngModel',
        link: link,
        controller: controller,
        scope: {
            currency: '@'
        },
        template: '<span>{{0 | currency: currency | limitTo: 1}}</span>\n  <input type="number" ng-model="price" class="form-control" step="0.01">'
    };
});
'use strict';

// Adapted from https://github.com/PM5544/scoped-polyfill

angular.module("BB.Directives").directive('scoped', function ($document, $timeout) {
    var _this = this;

    this.compat = function () {
        var DOMStyle = void 0;
        var check = document.createElement('style');
        if (typeof check.sheet !== 'undefined') {
            DOMStyle = 'sheet';
        } else if (typeof check.getSheet !== 'undefined') {
            DOMStyle = 'getSheet';
        } else {
            DOMStyle = 'styleSheet';
        }
        var scopeSupported = undefined !== check.scoped;
        document.body.appendChild(check);
        var testSheet = check[DOMStyle];
        if (testSheet.addRule) {
            testSheet.addRule('c', 'blink');
        } else {
            testSheet.insertRule('c{}', 0);
        }
        var DOMRules = testSheet.rules ? 'rules' : 'cssRules';
        var testStyle = testSheet[DOMRules][0];
        try {
            testStyle.selectorText = 'd';
        } catch (e) {}
        var changeSelectorTextAllowed = 'd' === testStyle.selectorText.toLowerCase();
        check.parentNode.removeChild(check);
        return {
            scopeSupported: scopeSupported,
            rules: DOMRules,
            sheet: DOMStyle,
            changeSelectorTextAllowed: changeSelectorTextAllowed
        };
    }();

    var scopeIt = function scopeIt(element) {
        var styleNode = element[0];
        var sheet = styleNode[_this.compat.sheet];
        if (!sheet) {
            return;
        }
        var allRules = sheet[_this.compat.rules];
        var par = styleNode.parentNode;
        //let id = par.id || (par.id = `scopedByScopedPolyfill_${++idCounter}`);
        var glue = '';
        var index = allRules.length || 0;
        while (par) {
            if (par.id) {
                glue = '#' + par.id + ' ' + glue;
            }
            par = par.parentNode;
        }
        return function () {
            var result = [];
            while (index--) {
                var item = void 0;
                var rule = allRules[index];
                if (rule.selectorText) {
                    if (!rule.selectorText.match(new RegExp(glue))) {
                        var selector = glue + ' ' + rule.selectorText.split(',').join(', ' + glue);
                        selector = selector.replace(/[\ ]+:root/gi, '');
                        if (_this.compat.changeSelectorTextAllowed) {
                            item = rule.selectorText = selector;
                        } else {
                            if (!rule.type || 1 === rule.type) {
                                var styleRule = rule.style.cssText;
                                if (styleRule) {
                                    if (sheet.removeRule) {
                                        sheet.removeRule(index);
                                    } else {
                                        sheet.deleteRule(index);
                                    }
                                    if (sheet.addRule) {
                                        item = sheet.addRule(selector, styleRule);
                                    } else {
                                        item = sheet.insertRule(selector + '{' + styleRule + '}', index);
                                    }
                                }
                            }
                        }
                    }
                }
                result.push(item);
            }
            return result;
        }();
    };

    return {
        restrict: 'A',
        link: function link(scope, element, attrs) {
            scope.scopeSupported = this.compat.scopeSupported;
            if (!this.compat.scopeSupported) {
                return $timeout(function () {
                    return scopeIt(element);
                });
            }
        },
        controller: function controller($scope, $element, $timeout) {
            if (!$scope.scopeSupported) {
                this.updateCss = function () {
                    return $timeout(function () {
                        return scopeIt($element);
                    });
                };
            }
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('script', function ($compile, halClient) {
    return {
        transclude: false,
        restrict: 'E',
        link: function link(scope, element, attrs) {
            if (attrs.type === 'text/hal-object') {
                var body = element[0].innerText;
                var json = $bbug.parseJSON(body);
                return halClient.$parse(json);
            }
        }
    };
});
'use strict';

(function () {
    angular.module('toggle-switch').directive('toggleSwitch', function () {
        'ngInject';

        return {
            restrict: 'EA',
            replace: true,
            require: 'ngModel',
            scope: {
                disabled: '@',
                onLabel: '@',
                offLabel: '@',
                knobLabel: '@',
                labelAria: '@'
            },
            link: toggleSwitchLinkFn,
            template: ' <div tabindex="0" class="bb-toggle-switch ats-switch switch-primary" >\n                              <label  aria-label="{{labelAria}}">\n                                <input class="toggler" ng-checked="!model" type="checkbox" />\n                                <!-- use span for backwards compatibility-->\n                                <span class="slider " ng-class="{\'switch-left\':model, \'switch-right\':!model}">\n                                     <span ng-if="!model"  aria-live="polite" class="slide-no ">{{offLabel}}</span>\n                                     <span ng-if="model" aria-live="polite"  class="slide-checked ">{{onLabel}}</span>\n                                </span>\n                              </label>\n                           </div>'
        };

        function toggleSwitchLinkFn(scope, element, attrs, ngModelCtrl) {

            scope.model = scope.model ? !!scope.model : false;

            //use this elem because event being fired twice, on label and input causing event bubble buggy behaviour
            var elem = element.find('input')[0];
            element.on('click', function (e) {
                if (e.target.className === elem.className) {
                    scope.$apply(scope.toggle);
                }
            });

            element.on('keydown', function (e) {
                var key = e.which ? e.which : e.keyCode;
                if (key === 13 || key === 32) {
                    // call click instead of $applying here bcoz screen reader not responding when toggle triggered by keyboard. Click event works with screen reader.
                    elem.click();
                }
            });

            ngModelCtrl.$formatters.push(function (modelValue) {
                return modelValue;
            });

            ngModelCtrl.$parsers.push(function (viewValue) {
                return viewValue;
            });

            ngModelCtrl.$viewChangeListeners.push(function () {
                return scope.$eval(attrs.ngChange);
            });

            ngModelCtrl.$render = function () {
                return scope.model = ngModelCtrl.$viewValue;
            };

            scope.toggle = function () {
                if (!scope.disabled) {
                    scope.model = !scope.model;
                    ngModelCtrl.$setViewValue(scope.model);
                }
            };
        }
    });
})();
'use strict';

(function () {

    angular.module('BB.uiSelect').directive('uiSelectChoicesLazyload', uiSelectChoicesLazyLoadDirective);

    function uiSelectChoicesLazyLoadDirective($timeout, $parse, $compile, $document, $filter) {

        return function (scope, elm, attr) {
            var raw, refreshCallBack, scrollCompleted;
            scope.$on('UISelect:closeSelect', function () {
                return scope.$select.close();
            });
            raw = elm[0];
            scrollCompleted = true;
            if (!attr.allChoices) {
                throw new Error('ief:ui-select: Attribute all-choices is required in ui-select-choices so that we can handle pagination.');
            }
            scope.pagingOptions = {
                allOptions: scope.$eval(attr.allChoices)
            };

            attr.refresh = 'addMoreItems()';
            refreshCallBack = $parse(attr.refresh);
            elm.bind('scroll', function (event) {
                var callback, percent, remainingHeight, scrollTop;
                remainingHeight = raw.offsetHeight - raw.scrollHeight;
                scrollTop = raw.scrollTop;
                percent = Math.abs(scrollTop / remainingHeight * 100);
                if (percent >= 80) {
                    if (scrollCompleted) {
                        scrollCompleted = false;
                        event.preventDefault();
                        event.stopPropagation();
                        callback = function callback() {
                            scope.addingMore = true;
                            refreshCallBack(scope, {
                                $event: event
                            });
                            scrollCompleted = true;
                        };
                        $timeout(callback, 100);
                    }
                }
            });
            scope.addMoreItems = function (doneCalBack) {
                var $select, allItems, i, itemsThreshold, k, moreItems, pagingOptions, ref, search, searchDidNotChange;
                $select = scope.$select;
                allItems = scope.pagingOptions.allOptions;
                moreItems = [];
                itemsThreshold = 100;
                search = $select.search;
                pagingOptions = $select.pagingOptions = $select.pagingOptions || {
                    page: 0,
                    pageSize: 20,
                    items: $select.items
                };
                if (pagingOptions.page === 0) {
                    pagingOptions.items.length = 0;
                }
                if (!pagingOptions.originalAllItems) {
                    pagingOptions.originalAllItems = scope.pagingOptions.allOptions;
                }
                searchDidNotChange = search && pagingOptions.prevSearch && search === pagingOptions.prevSearch;
                if (pagingOptions.filteredItems && searchDidNotChange) {
                    allItems = pagingOptions.filteredItems;
                }
                pagingOptions.prevSearch = search;
                if (search && search.length > 0 && pagingOptions.items.length < allItems.length && !searchDidNotChange) {
                    pagingOptions.filteredItems = null;
                    moreItems = $filter('filter')(pagingOptions.originalAllItems, search);
                    if (moreItems.length > itemsThreshold) {

                        if (!pagingOptions.filteredItems) {
                            pagingOptions.page = 0;
                            pagingOptions.items.length = 0;
                        }

                        pagingOptions.page = 0;
                        pagingOptions.items.length = 0;
                        allItems = pagingOptions.filteredItems = moreItems;
                    } else {
                        allItems = moreItems;
                        pagingOptions.items.length = 0;
                        pagingOptions.filteredItems = null;
                    }
                }
                pagingOptions.page++;
                if (pagingOptions.page * pagingOptions.pageSize < allItems.length) {
                    moreItems = allItems.slice(pagingOptions.items.length, pagingOptions.page * pagingOptions.pageSize);
                } else {
                    moreItems = allItems;
                }
                for (k = i = 0, ref = moreItems.length; 0 <= ref ? i < ref : i > ref; k = 0 <= ref ? ++i : --i) {
                    if (pagingOptions.items.indexOf(moreItems[k]) === -1) {
                        pagingOptions.items.push(moreItems[k]);
                    }
                }
                scope.calculateDropdownPos();
                scope.$broadcast('uis:refresh');
                if (doneCalBack) {
                    return doneCalBack();
                }
            };
            scope.$on('$destroy', function () {
                elm.off('scroll');
            });

            scope.$watch(attr.allChoices, function (newValue, oldValue) {
                if (newValue.length !== oldValue.length) {
                    scope.pagingOptions.allOptions = newValue;
                    scope.addMoreItems();
                }
            });
        };
    }
})();
'use strict';

(function () {

    angular.module('BB.uiSelect').directive('uiSelectChoicesListener', uiSelectChoicesListenerDirective);

    function uiSelectChoicesListenerDirective() {

        return function (scope, elm, attr) {
            scope.$on('UISelect:closeSelect', function () {
                return scope.$select.close();
            });
        };
    }
})();
'use strict';

angular.module('BB.uib').run(function ($document, runtimeUibModal) {
    'ngInject';

    var init = function init() {
        setUibModalDefaults();
    };

    var setUibModalDefaults = function setUibModalDefaults() {
        runtimeUibModal.options.appendTo = angular.element($document[0].getElementById('bb'));
    };

    init();
});
'use strict';

(function () {
    angular.module('BB.Controllers').controller('Purchase', PurchaseCtrl);

    function PurchaseCtrl($scope, $rootScope, PurchaseService, $uibModal, $location, $timeout, BBModel, $q, QueryStringService, SSOService, AlertService, LoginService, $window, $sessionStorage, LoadingService, $translate, ReasonService, $document, bbAnalyticsPiwik) {

        $scope.$on('booking:moved', function (event, purchase) {
            $scope.purchase = purchase;
        });

        $scope.is_waitlist = false;
        $scope.make_payment = false;
        var loader = LoadingService.$loader($scope);

        var setPurchaseCompany = function setPurchaseCompany(company) {
            $scope.bb.company_id = company.id;
            $scope.bb.company = new BBModel.Company(company);
            $scope.company = $scope.bb.company;
            $scope.bb.item_defaults.company = $scope.bb.company;
            if (company.settings) {
                if (company.settings.merge_resources) {
                    $scope.bb.item_defaults.merge_resources = true;
                }
                if (company.settings.merge_people) {
                    return $scope.bb.item_defaults.merge_people = true;
                }
            }
        };

        var failMsg = function failMsg() {
            if ($scope.fail_msg) {
                return AlertService.danger({
                    msg: $scope.fail_msg
                });
            } else {
                return AlertService.add("danger", {
                    msg: $translate.instant('CORE.ALERTS.GENERIC')
                });
            }
        };

        $scope.init = function (options) {
            if (!options) {
                options = {};
            }

            loader.notLoaded();
            if (options.move_route) {
                $scope.move_route = options.move_route;
            }
            if (options.move_all) {
                $scope.move_all = options.move_all;
            }
            if (options.fail_msg) {
                $scope.fail_msg = options.fail_msg;
            }

            // is there a purchase total already in scope?
            if ($scope.bb.total) {
                return $scope.load($scope.bb.total.long_id);
            } else if ($scope.bb.purchase) {
                $scope.purchase = $scope.bb.purchase;
                $scope.bookings = $scope.bb.purchase.bookings;
                if ($scope.purchase.confirm_messages) {
                    $scope.messages = $scope.purchase.confirm_messages;
                }
                if (!$scope.cancel_reasons) {
                    $scope.cancel_reasons = $scope.bb.cancel_reasons;
                }
                if (!$scope.move_reasons) {
                    $scope.move_reasons = $scope.bb.move_reasons;
                }
                return loader.setLoaded();
            } else {
                if (options.member_sso) {
                    return SSOService.memberLogin(options).then(function (login) {
                        return $scope.load();
                    }, function (err) {
                        loader.setLoaded();
                        return failMsg();
                    });
                } else {
                    return $scope.load();
                }
            }
        };

        var getPurchase = function getPurchase(params) {

            var deferred = $q.defer();
            PurchaseService.query(params).then(function (purchase) {
                deferred.resolve(purchase);
                purchase.$get('company').then(function (company) {
                    return setPurchaseCompany(company);
                });
                $scope.purchase = purchase;
                $scope.bb.purchase = purchase;
                return $scope.price = !($scope.purchase.price === 0);
            }, function (err) {
                //get purchase
                loader.setLoaded();
                if (err && err.status === 401) {
                    if (LoginService.isLoggedIn()) {
                        // TODO don't show fail message, display message that says you're logged in as someone else and offer switch user function (logout and show login)
                        return failMsg();
                    } else {
                        return loginRequired();
                    }
                } else {
                    return failMsg();
                }
            });
            return deferred.promise;
        };

        var getBookings = function getBookings(purchase) {

            $scope.purchase.$getBookings().then(function (bookings) {
                $scope.bookings = bookings;

                if (bookings[0]) {
                    bookings[0].$getCompany().then(function (company) {
                        $scope.purchase.bookings[0].company = company;
                        if (company.$has("reasons")) {
                            getReasons(company).then(function (reasons) {
                                setCancelReasons();
                                setMoveReasons();
                                setMoveReasonsToBB();
                                return setCancelReasonsToBB();
                            });
                        }
                        return company.$getAddress().then(function (address) {
                            return $scope.purchase.bookings[0].company.address = address;
                        });
                    });
                }

                loader.setLoaded();
                checkIfMoveBooking(bookings);
                checkIfWaitlistBookings(bookings);

                return Array.from($scope.bookings).map(function (booking) {
                    return booking.$getAnswers().then(function (answers) {
                        return booking.answers = answers;
                    });
                });
            }, function (err) {
                //get booking
                loader.setLoaded();
                return failMsg();
            });

            if (purchase.$has('client')) {
                purchase.$get('client').then(function (client) {
                    return $scope.setClient(new BBModel.Client(client));
                });
            }
            return $scope.purchase.getConfirmMessages().then(function (messages) {
                $scope.purchase.confirm_messages = messages;
                return $scope.messages = messages;
            });
        };

        $scope.load = function (id) {

            loader.notLoaded();

            if (!id) {
                id = getPurchaseID();
            }

            if (!$scope.loaded && !!id) {
                $rootScope.widget_started.then(function () {
                    return $scope.waiting_for_conn_started.then(function () {
                        var company_id = getCompanyID();
                        if (company_id) {
                            var options = {
                                root: $scope.bb.api_url
                            };
                            BBModel.Company.$query(company_id, options).then(function (company) {
                                return setPurchaseCompany(company);
                            });
                        }
                        var params = {
                            purchase_id: id,
                            url_root: $scope.bb.api_url
                        };
                        var auth_token = $sessionStorage.getItem('auth_token');
                        if (auth_token) {
                            params.auth_token = auth_token;
                        }

                        return getPurchase(params).then(function (purchase) {
                            return getBookings(purchase);
                        });
                    }, function (err) {
                        return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
                    });
                }, function (err) {
                    return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
                });
            } else {
                loader.setLoaded();
            }

            return $scope.loaded = true;
        };

        var checkIfMoveBooking = function checkIfMoveBooking(bookings) {

            var id = void 0;
            var matches = /^.*(?:\?|&)move_booking=(.*?)(?:&|$)/.exec($location.absUrl());
            if (matches) {
                id = parseInt(matches[1]);
            }
            if (id) {
                var move_booking = Array.from(bookings).filter(function (b) {
                    return b.id === id;
                }).map(function (b) {
                    return b;
                });
                if (move_booking.length > 0 && $scope.isMovable(bookings[0])) {
                    return $scope.move(move_booking[0]);
                }
            }
        };

        var checkIfWaitlistBookings = function checkIfWaitlistBookings(bookings) {
            return $scope.waitlist_bookings = Array.from(bookings).filter(function (booking) {
                return booking.on_waitlist && booking.settings.sent_waitlist === 1;
            }).map(function (booking) {
                return booking;
            });
        };

        var loginRequired = function loginRequired() {
            if (!$scope.bb.login_required) {
                return window.location = window.location.href + "&login=true";
            }
        };

        var getCompanyID = function getCompanyID() {
            var company_id = void 0;
            var matches = /^.*(?:\?|&)company_id=(.*?)(?:&|$)/.exec($location.absUrl());
            if (matches) {
                company_id = matches[1];
            }
            return company_id;
        };

        var getPurchaseID = function getPurchaseID() {
            var id = void 0;
            var matches = /^.*(?:\?|&)id=(.*?)(?:&|$)/.exec($location.absUrl());
            if (!matches) {
                matches = /^.*print_purchase\/(.*?)(?:\?|$)/.exec($location.absUrl());
            }
            if (!matches) {
                matches = /^.*print_purchase_jl\/(.*?)(?:\?|$)/.exec($location.absUrl());
            }

            if (matches) {
                id = matches[1];
            } else {
                if (QueryStringService('ref')) {
                    id = QueryStringService('ref');
                }
            }
            if (QueryStringService('booking_id')) {
                id = QueryStringService('booking_id');
            }
            return id;
        };

        function setPiwik(category, title) {
            bbAnalyticsPiwik.push(['trackEvent', [category], title]);
        }

        $scope.bookWaitlistItem = function (booking) {
            loader.notLoaded();
            var params = {
                purchase: $scope.purchase,
                booking: booking
            };
            return PurchaseService.bookWaitlistItem(params).then(function (purchase) {
                $scope.purchase = purchase;
                $scope.total = $scope.purchase;
                $scope.bb.purchase = purchase;
                return $scope.purchase.$getBookings().then(function (bookings) {
                    $scope.bookings = bookings;
                    $scope.waitlist_bookings = function () {
                        var result = [];
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = Array.from($scope.bookings)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                booking = _step.value;

                                if (booking.on_waitlist && booking.settings.sent_waitlist === 1) {
                                    result.push(booking);
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return) {
                                    _iterator.return();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }

                        return result;
                    }();
                    if ($scope.purchase.$has('new_payment') && $scope.purchase.due_now > 0) {
                        $scope.make_payment = true;
                    }
                    return loader.setLoaded();
                }, function (err) {
                    loader.setLoaded();
                    return failMsg();
                });
            }, function (err) {
                return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
            });
        };

        // delete a single booking
        $scope.delete = function (_booking) {
            // BB analytics Event
            if (bbAnalyticsPiwik.isEnabled()) setPiwik("View Booking", "Cancel Booking");
            var modalInstance = $uibModal.open({
                templateUrl: $scope.getPartial("_cancel_modal"),
                controller: ModalDelete,
                resolve: {
                    booking: function booking() {
                        return _booking;
                    },
                    cancel_reasons: function cancel_reasons() {
                        return $scope.cancel_reasons;
                    }
                }
            });

            return modalInstance.result.then(function (booking) {
                var cancel_reason = null;
                if (booking.cancel_reason) {
                    cancel_reason = booking.cancel_reason;
                }
                var data = {
                    cancel_reason: cancel_reason
                };
                return booking.$del('self', {}, data).then(function (service) {
                    $scope.bookings = _.without($scope.bookings, booking);
                    return $rootScope.$broadcast("booking:cancelled");
                });
            });
        };

        // delete all bookings assoicated to the purchase
        $scope.deleteAll = function () {
            var modalInstance = $uibModal.open({
                templateUrl: $scope.getPartial("_cancel_modal"),
                controller: ModalDeleteAll,
                resolve: {
                    purchase: function purchase() {
                        return $scope.purchase;
                    }
                }
            });
            return modalInstance.result.then(function (purchase) {
                return PurchaseService.deleteAll(purchase).then(function (purchase) {
                    $scope.purchase = purchase;
                    $scope.bookings = [];
                    return $rootScope.$broadcast("booking:cancelled");
                });
            });
        };

        $scope.isMovable = function (booking) {

            if (booking.min_cancellation_time) {
                return moment().isBefore(booking.min_cancellation_time);
            }
            return booking.datetime.isAfter(moment());
        };

        $scope.createBasketItem = function (booking) {

            var item = new BBModel.BasketItem(booking, $scope.bb);
            item.setSrcBooking(booking);
            return item;
        };

        $scope.checkAnswer = function (answer) {
            return typeof answer.value === 'boolean' || typeof answer.value === 'string' || typeof answer.value === "number";
        };

        $scope.changeAttendees = function (route) {
            return $scope.moveAll(route);
        };

        var getReasons = function getReasons(company) {
            return ReasonService.query(company).then(function (reasons) {
                $scope.company_reasons = reasons;
                return $scope.company_reasons;
            }, function (err) {
                return loader.setLoadedAndShowError(err, 'Sorry, something went wrong retrieving reasons');
            });
        };

        var setCancelReasons = function setCancelReasons() {

            $scope.cancel_reasons = _.filter($scope.company_reasons, function (r) {
                return r.reason_type === 3;
            });
            return $scope.cancel_reasons;
        };

        var setMoveReasons = function setMoveReasons() {

            $scope.move_reasons = _.filter($scope.company_reasons, function (r) {
                return r.reason_type === 5;
            });
            return $scope.move_reasons;
        };

        var setMoveReasonsToBB = function setMoveReasonsToBB() {
            if ($scope.move_reasons) {
                return $scope.bb.move_reasons = $scope.move_reasons;
            }
        };

        var setCancelReasonsToBB = function setCancelReasonsToBB() {

            if ($scope.cancel_reasons) {
                return $scope.bb.cancel_reasons = $scope.cancel_reasons;
            }
        };
    }

    // Simple modal controller for handling the 'delete' modal
    var ModalDelete = function ModalDelete($scope, $rootScope, $uibModalInstance, booking, AlertService, cancel_reasons) {
        $scope.booking = booking;
        $scope.cancel_reasons = cancel_reasons;
        $scope.confirmDelete = function () {
            AlertService.clear();
            return $uibModalInstance.close(booking);
        };

        return $scope.cancel = function () {
            return $uibModalInstance.dismiss("cancel");
        };
    };

    // Simple modal controller for handling the 'delete all' modal
    var ModalDeleteAll = function ModalDeleteAll($scope, $rootScope, $uibModalInstance, purchase) {
        $scope.purchase = purchase;
        $scope.confirmDelete = function () {
            return $uibModalInstance.close(purchase);
        };
        return $scope.cancel = function () {
            return $uibModalInstance.dismiss("cancel");
        };
    };
})();
'use strict';

(function () {
	angular.module('BB.Directives').directive('bbPurchase', bbPurchase);

	function bbPurchase() {
		return {
			restrict: 'AE',
			replace: true,
			scope: true,
			controller: 'Purchase',
			link: function link(scope, element, attrs) {
				scope.init(scope.$eval(attrs.bbPurchase));
			}
		};
	}
})();
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

angular.module('BB.Models').factory("Purchase.BookingModel", function ($q, $window, BBModel, BaseModel, $bbug) {
    return function (_BaseModel) {
        _inherits(Purchase_Booking, _BaseModel);

        function Purchase_Booking(data) {
            _classCallCheck(this, Purchase_Booking);

            var _this = _possibleConstructorReturn(this, _BaseModel.call(this, data));

            _this.ready = false;

            _this.datetime = moment.parseZone(_this.datetime);
            if (_this.time_zone) {
                _this.datetime.tz(_this.time_zone);
            }

            _this.original_datetime = moment(_this.datetime);

            _this.end_datetime = moment.parseZone(_this.end_datetime);
            if (_this.time_zone) {
                _this.end_datetime.tz(_this.time_zone);
            }

            _this.min_cancellation_time = moment(_this.min_cancellation_time);
            _this.min_cancellation_hours = _this.datetime.diff(_this.min_cancellation_time, 'hours');
            return _this;
        }

        Purchase_Booking.prototype.getGroup = function getGroup() {
            var _this2 = this;

            if (this.group) {
                return this.group;
            }
            if (this._data.$has('event_groups')) {
                return this._data.$get('event_groups').then(function (group) {
                    _this2.group = group;
                    return _this2.group;
                });
            }
        };

        Purchase_Booking.prototype.getColour = function getColour() {
            if (this.getGroup()) {
                return this.getGroup().colour;
            } else {
                return "#FFFFFF";
            }
        };

        Purchase_Booking.prototype.getCompany = function getCompany() {
            var _this3 = this;

            if (this.company) {
                return this.company;
            }
            if (this.$has('company')) {
                return this._data.$get('company').then(function (company) {
                    _this3.company = new BBModel.Company(company);
                    return _this3.company;
                });
            }
        };

        Purchase_Booking.prototype.$getAnswers = function $getAnswers() {
            var _this4 = this;

            var defer = $q.defer();
            if (this.answers != null) {
                defer.resolve(this.answers);
            } else {
                this.answers = [];
                if (this._data.$has('answers')) {
                    this._data.$get('answers').then(function (answers) {
                        _this4.answers = Array.from(answers).map(function (a) {
                            return new BBModel.Answer(a);
                        });
                        return defer.resolve(_this4.answers);
                    });
                } else {
                    defer.resolve([]);
                }
            }
            return defer.promise;
        };

        Purchase_Booking.prototype.$getSurveyAnswers = function $getSurveyAnswers() {
            var _this5 = this;

            var defer = $q.defer();
            if (this.survey_answers) {
                defer.resolve(this.survey_answers);
            }
            if (this._data.$has('survey_answers')) {
                this._data.$get('survey_answers').then(function (survey_answers) {
                    _this5.survey_answers = Array.from(survey_answers).map(function (a) {
                        return new BBModel.Answer(a);
                    });
                    return defer.resolve(_this5.survey_answers);
                });
            } else {
                defer.resolve([]);
            }
            return defer.promise;
        };

        Purchase_Booking.prototype.answer = function answer(q) {
            if (this.answers != null) {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Array.from(this.answers)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var a = _step.value;

                        if (a.name && a.name === q) {
                            return a.answer;
                        }
                        if (a.question_text && a.question_text === q) {
                            return a.value;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            } else {
                this.$getAnswers();
            }
            return null;
        };

        Purchase_Booking.prototype.getPostData = function getPostData() {
            var data = {};

            data.attended = this.attended;
            data.client_id = this.client_id;
            data.company_id = this.company_id;
            data.time = this.datetime.hour() * 60 + this.datetime.minute();
            data.date = this.datetime.toISODate();
            data.deleted = this.deleted;
            data.describe = this.describe;
            data.duration = this.duration;
            data.end_datetime = this.end_datetime;

            // is the booking being moved (i.e. new time/new event) or are we just updating
            // the existing booking
            if (this.time && this.time.event_id && !this.isEvent()) {
                data.event_id = this.time.event_id;
            } else if (this.event) {
                data.event_id = this.event.id;
            } else {
                data.event_id = this.slot_id;
            }

            data.full_describe = this.full_describe;
            data.id = this.id;
            data.min_cancellation_time = this.min_cancellation_time;
            data.on_waitlist = this.on_waitlist;
            data.paid = this.paid;
            data.person_name = this.person_name;
            data.price = this.price;
            data.purchase_id = this.purchase_id;
            data.purchase_ref = this.purchase_ref;
            data.quantity = this.quantity;
            data.self = this.self;
            if (this.move_item_id) {
                data.move_item_id = this.move_item_id;
            }
            if (this.srcBooking) {
                data.move_item_id = this.srcBooking.id;
            }
            if (this.person) {
                data.person_id = this.person.id;
            }
            if (this.service) {
                data.service_id = this.service.id;
            }
            if (this.resource) {
                data.resource_id = this.resource.id;
            }
            if (this.item_details) {
                data.questions = this.item_details.getPostData();
            }
            if (this.move_reason) {
                data.move_reason = this.move_reason;
            }
            data.service_name = this.service_name;
            data.settings = this.settings;
            if (this.status) {
                data.status = this.status;
            }
            if (this.email != null) {
                data.email = this.email;
            }
            if (this.email_admin != null) {
                data.email_admin = this.email_admin;
            }
            if (this.first_name) {
                data.first_name = this.first_name;
            }
            if (this.last_name) {
                data.last_name = this.last_name;
            }

            var formatted_survey_answers = [];
            if (this.survey_questions) {
                data.survey_questions = this.survey_questions;
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = Array.from(this.survey_questions)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var q = _step2.value;

                        formatted_survey_answers.push({
                            value: q.answer,
                            outcome: q.outcome,
                            detail_type_id: q.id,
                            price: q.price
                        });
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }

                data.survey_answers = formatted_survey_answers;
            }

            return data;
        };

        Purchase_Booking.prototype.checkReady = function checkReady() {
            if (this.datetime && this.id && this.purchase_ref) {
                return this.ready = true;
            }
        };

        Purchase_Booking.prototype.printed_price = function printed_price() {
            if (parseFloat(this.price) % 1 === 0) {
                return '\xA3' + parseInt(this.price);
            }
            return $window.sprintf("£%.2f", parseFloat(this.price));
        };

        Purchase_Booking.prototype.getDateString = function getDateString() {
            return this.datetime.toISODate();
        };

        // return the time of day in total minutes


        Purchase_Booking.prototype.getTimeInMins = function getTimeInMins() {
            return this.datetime.hour() * 60 + this.datetime.minute();
        };

        Purchase_Booking.prototype.getAttachments = function getAttachments() {
            var _this6 = this;

            if (this.attachments) {
                return this.attachments;
            }
            if (this.$has('attachments')) {
                return this._data.$get('attachments').then(function (atts) {
                    _this6.attachments = atts.attachments;
                    return _this6.attachments;
                });
            }
        };

        Purchase_Booking.prototype.canCancel = function canCancel() {
            return moment(this.min_cancellation_time).isAfter(moment());
        };

        Purchase_Booking.prototype.canMove = function canMove() {
            return this.canCancel();
        };

        Purchase_Booking.prototype.getAttendeeName = function getAttendeeName() {
            return this.first_name + ' ' + this.last_name;
        };

        Purchase_Booking.prototype.isEvent = function isEvent() {
            return this.event_chain != null;
        };

        Purchase_Booking.$addSurveyAnswersToBooking = function $addSurveyAnswersToBooking(booking) {
            return PurchaseBookingService.addSurveyAnswersToBooking(booking);
        };

        return Purchase_Booking;
    }(BaseModel);
});
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

angular.module('BB.Models').factory("Purchase.CourseBookingModel", function ($q, BBModel, BaseModel) {
    return function (_BaseModel) {
        _inherits(Purchase_Course_Booking, _BaseModel);

        function Purchase_Course_Booking(data) {
            _classCallCheck(this, Purchase_Course_Booking);

            return _possibleConstructorReturn(this, _BaseModel.call(this, data));
        }

        Purchase_Course_Booking.prototype.getBookings = function getBookings() {
            var _this2 = this;

            var defer = $q.defer();
            if (this.bookings) {
                defer.resolve(this.bookings);
            }
            if (this._data.$has('bookings')) {
                this._data.$get('bookings').then(function (bookings) {
                    _this2.bookings = function () {
                        var result = [];
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = Array.from(bookings)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var b = _step.value;

                                result.push(new BBModel.Purchase.Booking(b));
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return) {
                                    _iterator.return();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }

                        return result;
                    }();
                    _this2.bookings.sort(function (a, b) {
                        return a.datetime.unix() - b.datetime.unix();
                    });
                    return defer.resolve(_this2.bookings);
                });
            } else {
                this.bookings = [];
                defer.resolve(this.bookings);
            }
            return defer.promise;
        };

        return Purchase_Course_Booking;
    }(BaseModel);
});
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

angular.module('BB.Models').factory("Purchase.TotalModel", function ($q, $window, BBModel, BaseModel, $sce) {
    return function (_BaseModel) {
        _inherits(Purchase_Total, _BaseModel);

        function Purchase_Total(data) {
            _classCallCheck(this, Purchase_Total);

            var _this = _possibleConstructorReturn(this, _BaseModel.call(this, data));

            _this.getItems().then(function (items) {
                return _this.items = items;
            });
            _this.getClient().then(function (client) {
                return _this.client = client;
            });
            _this.getMember().then(function (member) {
                return _this.member = member;
            });
            return _this;
        }

        Purchase_Total.prototype.id = function id() {
            return this.get('id');
        };

        Purchase_Total.prototype.icalLink = function icalLink() {
            return this._data.$href('ical');
        };

        Purchase_Total.prototype.webcalLink = function webcalLink() {
            return this._data.$href('ical');
        };

        Purchase_Total.prototype.gcalLink = function gcalLink() {
            return this._data.$href('gcal');
        };

        Purchase_Total.prototype.getItems = function getItems() {
            var defer = $q.defer();
            if (this.items) {
                defer.resolve(this.items);
            }
            $q.all([this.$getBookings(), this.$getCourseBookings(), this.getPackages(), this.getProducts(), this.getDeals()]).then(function (result) {
                var items = _.flatten(result);
                return defer.resolve(items);
            });
            return defer.promise;
        };

        Purchase_Total.prototype.$getBookings = function $getBookings() {
            var _this2 = this;

            var defer = $q.defer();
            if (this.bookings) {
                defer.resolve(this.bookings);
            }
            if (this._data.$has('bookings')) {
                this._data.$get('bookings').then(function (bookings) {
                    _this2.bookings = function () {
                        var result = [];
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = Array.from(bookings)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var b = _step.value;

                                result.push(new BBModel.Purchase.Booking(b));
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return) {
                                    _iterator.return();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }

                        return result;
                    }();
                    _this2.bookings.sort(function (a, b) {
                        return a.datetime.unix() - b.datetime.unix();
                    });
                    return defer.resolve(_this2.bookings);
                });
            } else {
                defer.resolve([]);
            }
            return defer.promise;
        };

        Purchase_Total.prototype.$getCourseBookings = function $getCourseBookings() {
            var _this3 = this;

            var defer = $q.defer();
            if (this.course_bookings) {
                defer.resolve(this.course_bookings);
            }
            if (this._data.$has('course_bookings')) {
                this._data.$get('course_bookings').then(function (bookings) {
                    _this3.course_bookings = function () {
                        var result = [];
                        var _iteratorNormalCompletion2 = true;
                        var _didIteratorError2 = false;
                        var _iteratorError2 = undefined;

                        try {
                            for (var _iterator2 = Array.from(bookings)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                var b = _step2.value;

                                result.push(new BBModel.Purchase.CourseBooking(b));
                            }
                        } catch (err) {
                            _didIteratorError2 = true;
                            _iteratorError2 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                    _iterator2.return();
                                }
                            } finally {
                                if (_didIteratorError2) {
                                    throw _iteratorError2;
                                }
                            }
                        }

                        return result;
                    }();
                    return $q.all(_.map(_this3.course_bookings, function (b) {
                        return b.getBookings();
                    })).then(function () {
                        return defer.resolve(_this3.course_bookings);
                    });
                });
            } else {
                defer.resolve([]);
            }
            return defer.promise;
        };

        Purchase_Total.prototype.getPackages = function getPackages() {
            var _this4 = this;

            var defer = $q.defer();
            if (this.packages) {
                defer.resolve(this.packages);
            }
            if (this._data.$has('packages')) {
                this._data.$get('packages').then(function (packages) {
                    _this4.packages = packages;
                    return defer.resolve(_this4.packages);
                });
            } else {
                defer.resolve([]);
            }
            return defer.promise;
        };

        Purchase_Total.prototype.getProducts = function getProducts() {
            var _this5 = this;

            var defer = $q.defer();
            if (this.products) {
                defer.resolve(this.products);
            }
            if (this._data.$has('products')) {
                this._data.$get('products').then(function (products) {
                    _this5.products = products;
                    return defer.resolve(_this5.products);
                });
            } else {
                defer.resolve([]);
            }
            return defer.promise;
        };

        Purchase_Total.prototype.getDeals = function getDeals() {
            var _this6 = this;

            var defer = $q.defer();
            if (this.deals) {
                defer.resolve(this.deals);
            }
            if (this._data.$has('deals')) {
                this._data.$get('deals').then(function (deals) {
                    _this6.deals = deals;
                    return defer.resolve(_this6.deals);
                });
            } else {
                defer.resolve([]);
            }
            return defer.promise;
        };

        Purchase_Total.prototype.getMessages = function getMessages(booking_texts, msg_type) {
            var defer = $q.defer();
            booking_texts = Array.from(booking_texts).filter(function (bt) {
                return bt.message_type === msg_type;
            }).map(function (bt) {
                return bt;
            });
            if (booking_texts.length === 0) {
                defer.resolve([]);
            } else {
                this.getItems().then(function (items) {
                    var msgs = [];
                    var _iteratorNormalCompletion3 = true;
                    var _didIteratorError3 = false;
                    var _iteratorError3 = undefined;

                    try {
                        for (var _iterator3 = Array.from(booking_texts)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                            var booking_text = _step3.value;
                            var _iteratorNormalCompletion4 = true;
                            var _didIteratorError4 = false;
                            var _iteratorError4 = undefined;

                            try {
                                for (var _iterator4 = Array.from(items)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                                    var item = _step4.value;
                                    var _arr = ['company', 'person', 'resource', 'service'];

                                    for (var _i = 0; _i < _arr.length; _i++) {
                                        var type = _arr[_i];
                                        if (item.$has(type) && item.$href(type) === booking_text.$href('item')) {
                                            if (msgs.indexOf(booking_text.message) === -1) {
                                                msgs.push(booking_text.message);
                                            }
                                        }
                                    }
                                }
                            } catch (err) {
                                _didIteratorError4 = true;
                                _iteratorError4 = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion4 && _iterator4.return) {
                                        _iterator4.return();
                                    }
                                } finally {
                                    if (_didIteratorError4) {
                                        throw _iteratorError4;
                                    }
                                }
                            }
                        }
                    } catch (err) {
                        _didIteratorError3 = true;
                        _iteratorError3 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion3 && _iterator3.return) {
                                _iterator3.return();
                            }
                        } finally {
                            if (_didIteratorError3) {
                                throw _iteratorError3;
                            }
                        }
                    }

                    return defer.resolve(msgs);
                });
            }
            return defer.promise;
        };

        Purchase_Total.prototype.getClient = function getClient() {
            var _this7 = this;

            var defer = $q.defer();
            if (this._data.$has('client')) {
                this._data.$get('client').then(function (client) {
                    _this7.client = new BBModel.Client(client);
                    return defer.resolve(_this7.client);
                });
            } else {
                defer.reject('No client');
            }
            return defer.promise;
        };

        Purchase_Total.prototype.getMember = function getMember() {
            var _this8 = this;

            var defer = $q.defer();
            if (this._data.$has('member')) {
                this._data.$get('member').then(function (member) {
                    _this8.member = new BBModel.Client(member);
                    return defer.resolve(_this8.member);
                });
            } else {
                defer.reject('No member');
            }
            return defer.promise;
        };

        Purchase_Total.prototype.getConfirmMessages = function getConfirmMessages() {
            var _this9 = this;

            var defer = $q.defer();
            if (this._data.$has('confirm_messages')) {
                this._data.$get('confirm_messages').then(function (msgs) {
                    return _this9.getMessages(msgs, 'Confirm').then(function (filtered_msgs) {
                        return defer.resolve(filtered_msgs);
                    });
                });
            } else {
                defer.reject('no messages');
            }
            return defer.promise;
        };

        Purchase_Total.prototype.printed_total_price = function printed_total_price() {
            if (parseFloat(this.total_price) % 1 === 0) {
                return '\xA3' + parseInt(this.total_price);
            }
            return $window.sprintf("£%.2f", parseFloat(this.total_price));
        };

        Purchase_Total.prototype.newPaymentUrl = function newPaymentUrl() {
            if (this._data.$has('new_payment')) {
                return $sce.trustAsResourceUrl(this._data.$href('new_payment'));
            }
        };

        Purchase_Total.prototype.totalDuration = function totalDuration() {
            var duration = 0;
            var _iteratorNormalCompletion5 = true;
            var _didIteratorError5 = false;
            var _iteratorError5 = undefined;

            try {
                for (var _iterator5 = Array.from(this.items)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                    var item = _step5.value;

                    if (item.duration) {
                        duration += item.duration;
                    }
                }
            } catch (err) {
                _didIteratorError5 = true;
                _iteratorError5 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion5 && _iterator5.return) {
                        _iterator5.return();
                    }
                } finally {
                    if (_didIteratorError5) {
                        throw _iteratorError5;
                    }
                }
            }

            return duration;
        };

        Purchase_Total.prototype.containsWaitlistItems = function containsWaitlistItems() {
            var waitlist = [];
            var _iteratorNormalCompletion6 = true;
            var _didIteratorError6 = false;
            var _iteratorError6 = undefined;

            try {
                for (var _iterator6 = Array.from(this.items)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                    var item = _step6.value;

                    if (item.on_waitlist === true) {
                        waitlist.push(item);
                    }
                }
            } catch (err) {
                _didIteratorError6 = true;
                _iteratorError6 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion6 && _iterator6.return) {
                        _iterator6.return();
                    }
                } finally {
                    if (_didIteratorError6) {
                        throw _iteratorError6;
                    }
                }
            }

            return waitlist.length > 0 ? true : false;
        };

        return Purchase_Total;
    }(BaseModel);
});
'use strict';

(function () {

    angular.module('BB.Services').factory("PurchaseBookingService", PurchaseBookingService);

    function PurchaseBookingService($q, halClient, BBModel) {
        return {
            update: function update(booking) {
                var deferred = $q.defer();
                var data = booking.getPostData();
                booking.$put('self', {}, data).then(function (booking) {
                    return deferred.resolve(new BBModel.Purchase.Booking(booking));
                }, function (err) {
                    return deferred.reject(err, new BBModel.Purchase.Booking(booking));
                });
                return deferred.promise;
            },
            addSurveyAnswersToBooking: function addSurveyAnswersToBooking(booking) {
                var deferred = $q.defer();
                var data = booking.getPostData();
                data.notify = false;
                data.notify_admin = false;
                booking.$put('self', {}, data).then(function (booking) {
                    return deferred.resolve(new BBModel.Purchase.Booking(booking));
                }, function (err) {
                    return deferred.reject(err, new BBModel.Purchase.Booking(booking));
                });
                return deferred.promise;
            }
        };
    }
})();
'use strict';

(function () {

    angular.module('BB.Services').factory('PurchaseService', PurchaseService);

    function PurchaseService($q, halClient, BBModel, $window, UriTemplate) {
        var query = function query(params) {
            var defer = $q.defer();
            var uri = params.url_root + "/api/v1/purchases/" + params.purchase_id;
            halClient.$get(uri, params).then(function (purchase) {
                purchase = new BBModel.Purchase.Total(purchase);
                return defer.resolve(purchase);
            }, function (err) {
                return defer.reject(err);
            });
            return defer.promise;
        };

        var bookingRefQuery = function bookingRefQuery(params) {
            var defer = $q.defer();
            var uri = new UriTemplate(params.url_root + "/api/v1/purchases/booking_ref/{booking_ref}{?raw}").fillFromObject(params);
            halClient.$get(uri, params).then(function (purchase) {
                purchase = new BBModel.Purchase.Total(purchase);
                return defer.resolve(purchase);
            }, function (err) {
                return defer.reject(err);
            });
            return defer.promise;
        };

        var update = function update(params) {
            var booking = void 0;
            var defer = $q.defer();

            if (!params.purchase) {
                defer.reject("No purchase present");
                return defer.promise;
            }

            // only send email on the last item we're moving - otherwise we'll send an email on each item!
            var data = {};

            if (params.bookings) {
                var bdata = [];
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Array.from(params.bookings)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        booking = _step.value;

                        bdata.push(booking.getPostData());
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                data.bookings = bdata;
            }

            if (params.move_reason) {
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = Array.from(data.bookings)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        booking = _step2.value;

                        booking.move_reason = params.move_reason;
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }
            }

            params.purchase.$put('self', {}, data).then(function (purchase) {
                purchase = new BBModel.Purchase.Total(purchase);
                return defer.resolve(purchase);
            }, function (err) {
                return defer.reject(err);
            });
            return defer.promise;
        };

        var bookWaitlistItem = function bookWaitlistItem(params) {
            var defer = $q.defer();

            if (!params.purchase && !params.purchase_id) {
                defer.reject("No purchase or purchase_id present");
            }

            var data = {};
            //data.booking = params.booking.getPostData() if params.booking
            data.booking_id = params.booking.id;

            if (params.purchase) {

                params.purchase.$put('book_waitlist_item', {}, data).then(function (purchase) {
                    purchase = new BBModel.Purchase.Total(purchase);
                    return defer.resolve(purchase);
                }, function (err) {
                    return defer.reject(err);
                });
            } else if (params.purchase_id && params.url_root) {

                var uri = params.url_root + "/api/v1/purchases/" + params.purchase_id + '/book_waitlist_item';

                halClient.$put(uri, {}, data).then(function (purchase) {
                    purchase = new BBModel.Purchase.Total(purchase);
                    return defer.resolve(purchase);
                }, function (err) {
                    return defer.reject(err);
                });
            }

            return defer.promise;
        };

        var deleteAll = function deleteAll(purchase) {
            var defer = $q.defer();

            if (!purchase) {
                defer.reject("No purchase present");
                return defer.promise;
            }

            purchase.$del('self').then(function (purchase) {
                purchase = new BBModel.Purchase.Total(purchase);
                return defer.resolve(purchase);
            }, function (err) {
                return defer.reject(err);
            });

            return defer.promise;
        };

        var deleteItem = function deleteItem(params) {
            var defer = $q.defer();
            var uri = params.api_url + "/api/v1/purchases/" + params.long_id + "/purchase_item/" + params.purchase_item_id;
            halClient.$del(uri, {}).then(function (purchase) {
                purchase = new BBModel.Purchase.Total(purchase);
                return defer.resolve(purchase);
            }, function (err) {
                return defer.reject(err);
            });
            return defer.promise;
        };

        var updateBBPurchase = function updateBBPurchase(purchase, booking) {
            purchase.bookings.forEach(function (purchaseBooking, index) {
                if (booking.id === purchaseBooking.id) {
                    purchase.bookings[index] = booking;
                }
            });
            purchase.items.forEach(function (purchaseItem, index) {
                if (booking.id === purchaseItem.id) {
                    purchase.items[index] = booking;
                }
            });
            return purchase;
        };

        return {
            query: query,
            bookingRefQuery: bookingRefQuery,
            update: update,
            bookWaitlistItem: bookWaitlistItem,
            deleteAll: deleteAll,
            deleteItem: deleteItem,
            updateBBPurchase: updateBBPurchase
        };
    }
})();
'use strict';

/***
 * @ngdoc service
 * @name BB.Services.TimeSlotPermutationService
 * @requires DateTimeUtilitiesService
 * @description
 * handles finding a permutation of slots  for services to be carried out back to back
 * The permutations are found using the following conditions
 * - the order does not matter
 * - there are no repeating services / slots
 * - all services must have a slot (no services are left out from a permutation)
 */
angular.module('BB.Services').service("TimeSlotPermutationService", function (DateTimeUtilitiesService) {

    var service = this;

    /***
     * @ngdoc method
     * @name permute
     * @methodOf BB.Services.TimeSlotPermutationService
     * @description
     * Finds all valid sequences using Steinhaus–Johnson–Trotter algorithm
     * 
     * http://stackoverflow.com/questions/9960908/permutations-in-javascript
     * http://en.wikipedia.org/wiki/Steinhaus%E2%80%93Johnson%E2%80%93Trotter_algorithm
     * @param {array} inputArray The array of objects you wish to find all permutations for
     */
    service.permute = function (inputArray) {
        var permutations = [];
        var usedInput = [];

        var main = function main() {
            var input = void 0;
            var loopIndex = 0;

            while (loopIndex < inputArray.length) {
                input = inputArray.splice(loopIndex, 1)[0];
                usedInput.push(input);

                if (inputArray.length === 0) {
                    permutations.push(usedInput.slice());
                }

                main();
                inputArray.splice(loopIndex, 0, input);
                usedInput.pop();
                loopIndex++;
            }

            return permutations;
        };

        return main();
    };

    /***
     * @ngdoc method
     * @name addExistingDateTimes
     * @methodOf BB.Services.TimeSlotPermutationService
     * @description
     * Add date times previously selected to slots
     *
     * @param {array} stackedItems The array of BasketItems that will be checked out
     * @param {array} slots The array of Slot objects that are currently loaded
     */
    service.addExistingDateTimes = function (stackedItems, slots) {

        for (var itemIndex in stackedItems) {
            var item = stackedItems[itemIndex];

            if (slots.length && (item.datetime || item.date && item.time)) {

                var timeSlot = void 0;

                var datetime = item.datetime || DateTimeUtilitiesService.convertTimeToMoment(item.date.date, item.time.time);
                var item_slots = slots[itemIndex];
                var daySlotsForItem = item_slots[datetime.toISODate()];

                if (daySlotsForItem) {

                    timeSlot = _.findWhere(daySlotsForItem, { time: item.time.time });

                    if (!timeSlot) {
                        timeSlot = item.time;
                        daySlotsForItem.splice(0, 0, timeSlot);
                    }
                }

                // ensure only the first time slot is marked as selected
                if (item.self === stackedItems[0].self) {
                    timeSlot.selected = true;
                }
            }
        }
    };

    /***
     * @ngdoc method
     * @name isItemSlotsValid
     * @methodOf BB.Services.TimeSlotPermutationService
     * @description
     * checks the items have a matching slots
     * and sorts and assigns slot times to items if valid
     *
     * @param {array} items The array of BasketItems
     * @param {array} itemSlots An array of array of slots. Where the first set of arrays correspond to the first item
     */
    service.isItemSlotsValid = function (items, itemsSlots) {
        var isSlotsValid = false;

        for (var itemIndex in items) {

            for (var itemSlotIndex in itemsSlots[itemIndex]) {
                if (itemsSlots[itemIndex][itemSlotIndex] && itemsSlots[itemIndex][itemSlotIndex].length !== 0) {
                    isSlotsValid = true;
                }
            }

            if (isSlotsValid) {

                // set item slot by time
                items[itemIndex].slots = {};

                for (var slotIndex in itemsSlots[itemIndex]) {
                    items[itemIndex].slots[slotIndex] = _.indexBy(itemsSlots[itemIndex][slotIndex], 'time');
                }
            }
        }

        return isSlotsValid;
    };

    /***
     * @ngdoc method
     * @name isItemsSlotPermutationValid
     * @methodOf BB.Services.TimeSlotPermutationService
     * @description
     * Checks the slot has been set correctly with the correct time
     * Also sets the slot.next object to point to the next slot in the permutation
     *
     * @param {array} items A array of BasketItems
     * @param {object} slot A Slot object
     * @param {string} daySlot A string representing a date. Used for defining attribute for slots
     * @param {array} permutation An array representing the combination of slots
     * @param {int} maxGapBetweenSlots An integer representing minutes of maximum allowed gap between consecutive slots
     */
    service.isItemsSlotPermutationValid = function (items, slot, daySlot, permutation) {
        var maxGapBetweenSlots = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;


        var isValid = false;

        if (items.length && permutation.length && items[permutation[0]]) {
            var time = slot.time;
            var durationOfFirst = items[permutation[0]].service.duration;
            var next = time + durationOfFirst;

            // now loop around the remaining items in the sequence looking for a slot
            for (var i = 1; i < permutation.length; i++) {

                for (var daySlotIndex in items[permutation[i]].slots[daySlot]) {

                    if (daySlotIndex >= next && daySlotIndex <= next + maxGapBetweenSlots) {
                        if (!_.isEmpty(items[permutation[i]].slots[daySlot]) && items[permutation[i]].slots[daySlot][daySlotIndex]) {

                            isValid = true;

                            // set slot's next permutation
                            slot.next = angular.copy(items[permutation[i]].slots[daySlot][daySlotIndex]);
                            slot = slot.next;
                            next = daySlotIndex + items[permutation[i]].service.duration;
                        }
                    }
                }
            }
        }

        return isValid;
    };

    // 
    /***
     * @ngdoc method
     * @name findValidSlots
     * @methodOf BB.Services.TimeSlotPermutationService
     * @description
     * finds valid time slot sequences where services can be performed back to back
     *
     * @param {array} items A array of BasketItems
     * @param {array} itemsSlots A Slot object
     * @param {int} maxGapBetweenSlots A string representing a date. Used for defining attribute for slots
     */
    service.findValidSlots = function (items, itemsSlots) {
        var maxGapBetweenSlots = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

        var daysBySlots = {};

        // splice the selected time back into the result
        service.addExistingDateTimes(items, itemsSlots);

        if (service.isItemSlotsValid(items, itemsSlots)) {

            // build days object, indexed by dates from the first set of slots
            // for (let [slotIndex, slot] of Object.entries(items[0].slots)) {
            for (var slotIndex in items[0].slots) {
                daysBySlots[slotIndex] = { date: moment(slotIndex) };
            }

            // check each sequence permutation for a set of valid start times where each service can performed back to back
            // find the permutations from the range given the number of items 
            var range = _.range(0, items.length);
            var permutations = service.permute(range);

            for (var daySlotIndex in daysBySlots) {

                daysBySlots[daySlotIndex].slots = {};

                if (items.length > 1) {

                    for (var permutationIndex in permutations) {

                        var permutation = permutations[permutationIndex];

                        if (_.isEmpty(items[permutation[0]].slots[daySlotIndex])) {
                            break;
                        }

                        for (var timeIndex in items[permutation[0]].slots[daySlotIndex]) {

                            var slot = angular.copy(items[permutation[0]].slots[daySlotIndex][timeIndex]);

                            // add the slot if it's valid and isn't already in the dataset
                            if (service.isItemsSlotPermutationValid(items, slot, daySlotIndex, permutation, maxGapBetweenSlots)) {
                                daysBySlots[daySlotIndex].slots[slot.time] = slot;
                            }
                        }
                    }
                } else {
                    // if there's just one basket item, just set the slots on that
                    for (var _timeIndex in items[0].slots[daySlotIndex]) {
                        var _slot = items[0].slots[daySlotIndex][_timeIndex];
                        daysBySlots[daySlotIndex].slots[_slot.time] = _slot;
                    }
                }
            }
        }

        return daysBySlots;
    };
});
'use strict';

//
// Basket Directive
// Example usage;
// <div bb-basket></div>
// <div bb-basket mini></div>
//
angular.module('BB.Directives').directive('bbBasket', function (PathSvc) {
    return {
        restrict: 'A',
        replace: true,
        scope: true,
        templateUrl: function templateUrl(element, attrs) {
            if (_.has(attrs, 'mini')) {
                return PathSvc.directivePartial("_basket_mini");
            } else {
                return PathSvc.directivePartial("basket");
            }
        },

        controllerAs: 'BasketCtrl',

        controller: function controller($scope, $uibModal, $translate, $document, BasketService) {
            $scope.setUsingBasket(true);

            this.empty = function () {
                return $scope.$eval('emptyBasket()');
            };

            this.view = function () {
                return $scope.$eval('viewBasket()');
            };

            $scope.showBasketDetails = function () {
                if ($scope.bb.current_page === "basket" || $scope.bb.current_page === "checkout") {
                    return false;
                } else {
                    return $uibModal.open({
                        templateUrl: $scope.getPartial("_basket_details"),
                        scope: $scope,
                        controller: BasketInstanceCtrl,
                        resolve: {
                            basket: function basket() {
                                return $scope.bb.basket;
                            }
                        }
                    });
                }
            };

            var BasketInstanceCtrl = function BasketInstanceCtrl($scope, $rootScope, $uibModalInstance, basket) {
                $scope.basket = basket;

                return $scope.cancel = function () {
                    return $uibModalInstance.dismiss("cancel");
                };
            };

            $scope.$watch(function () {
                var len = void 0;
                $scope.basketItemCount = len = $scope.bb.basket ? $scope.bb.basket.length() : 0;
                $scope.basketStatus = $translate.instant("PUBLIC_BOOKING.BASKET_DETAILS.BASKET_STATUS", { N: len }, "messageformat");
            });
        },
        link: function link(scope, element, attrs) {
            // stop the default action of links inside directive. you can pass the $event
            // object in from the view to the function bound to ng-click but this keeps
            // the markup tidier
            return element.bind('click', function (e) {
                return e.preventDefault();
            });
        }
    };
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbMiniBasket
 * @restrict AE
 * @scope true
 *
 * @description
 * Loads a list of mini basket for the currently in scope company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @property {boolean} setUsingBasket Set using basket  or not
 */ //


angular.module('BB.Directives').directive('bbMiniBasket', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: function controller($scope, $rootScope, BasketService, $q) {
            $scope.setUsingBasket(true);
            $rootScope.connection_started.then(function () {});

            /***
             * @ngdoc method
             * @name basketDescribe
             * @methodOf BB.Directives:bbMiniBasket
             * @description
             * Basked describe in according of basket length
             *
             * @param {string} nothing Nothing to describe
             * @param {string} single The single describe
             * @param {string} plural The plural describe
             */
            return $scope.basketDescribe = function (nothing, single, plural) {
                if (!$scope.bb.basket || $scope.bb.basket.length() === 0) {
                    return nothing;
                } else if ($scope.bb.basket.length() === 1) {
                    return single;
                } else {
                    return plural.replace("$0", $scope.bb.basket.length());
                }
            };
        }
    };
});
'use strict';

angular.module('BB.Directives').directive('bbMinSpend', function () {
    return {
        restrict: 'A',
        scope: true,
        controller: function controller($scope, $element, $attrs, AlertService, $translate) {

            var checkMinSpend = void 0;
            var options = $scope.$eval($attrs.bbMinSpend || {});
            $scope.min_spend = options.min_spend || 0;
            //$scope.items = options.items or {}

            $scope.setReady = function () {
                return checkMinSpend();
            };

            return checkMinSpend = function checkMinSpend() {
                var price = 0;
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Array.from($scope.bb.stacked_items)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var item = _step.value;

                        price += item.service.price;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                if (price >= $scope.min_spend) {
                    AlertService.clear();
                    return true;
                } else {
                    AlertService.clear();
                    AlertService.add("warning", { msg: $translate.instant('CORE.ALERTS.SPEND_AT_LEAST', { min_spend: $scope.min_spend }) });
                    return false;
                }
            };
        }
    };
});
'use strict';

(function () {
    angular.module('BB.Controllers').controller('BBQuestionController', BBQuestionController);

    function BBQuestionController($scope, $compile, $element) {
        var _this = this;

        this.$onInit = function () {

            this.isTemplate = true;

            setDateFormats();

            if (this.question) determineTemplate();
        };

        this.recalc = function () {
            if (angular.isDefined($scope.recalc_price)) {
                if (!_this.question.outcome) {
                    $scope.recalc_price();
                }
            }
            if (angular.isDefined($scope.recalc_question)) {
                return $scope.recalc_question();
            }
        };

        var setDateFormats = function setDateFormats() {
            _this.date_format = 'DD/MM/YYYY';
            _this.date_format_2 = 'dd/MM/yyyy';
            if (_this.dateFormatLocale === 'US') {
                _this.date_format = 'MM/DD/YYYY';
                _this.date_format_2 = 'MM/dd/yyyy';
            }
        };

        var determineTemplate = function determineTemplate() {
            _this.name = null;
            _this.placeholder = '';

            var html = '';

            if (_this.defaultPlaceholder) {
                if (_this.question.detail_type === "text_area" || _this.question.detail_type === "text_field") {
                    if (_this.question.default) _this.placeholder = _this.question.default;
                    if (_this.question.answer === _this.question.default) _this.question.answer = "";
                }
            }

            if ($scope.idmaps && ($scope.idmaps[_this.question.detail_type] || $scope.idmaps[_this.question.id])) {
                var index = $scope.idmaps[_this.question.id] ? _this.question.id : _this.question.detail_type;
                html = $scope.idmaps[index].html;
            } else if (_this.question.detail_type === "select" || _this.question.detail_type === "select-price") {
                _this.templateUrl = "bb-question/_question_select.html";
            } else if (_this.question.detail_type === "text_area") {
                _this.templateUrl = "bb-question/_question_text_area.html";
            } else if (_this.question.detail_type === "radio") {
                _this.templateUrl = "bb-question/_question_radio.html";
            } else if (_this.question.detail_type === "check") {
                // stop the duplication of question names for muliple checkboxes by
                // checking the question name against the previous question name.
                _this.name = _this.question.name;
                _this.templateUrl = "bb-question/_question_check.html";
            } else if (_this.question.detail_type === "check-price") {
                _this.templateUrl = "bb-question/_question_check_price.html";
            } else if (_this.question.detail_type === "radio-price") {
                _this.templateUrl = "bb-question/_question_radio_price.html";
            } else if (_this.question.detail_type === "date") {
                _this.templateUrl = "bb-question/_question_date.html";
            } else {
                _this.templateUrl = "bb-question/_question_default.html";
            }

            compileTemplate(html);
        };

        var compileTemplate = function compileTemplate(html) {
            if (!html) return;

            _this.isTemplate = false;
            $compile(html)($scope, function (cloned, $scope) {
                $element.replaceWith(cloned);
            });
        };
    }
})(angular);
'use strict';

angular.module('BB.Directives').directive('bbQuestion', function ($compile, $timeout, $templateRequest, $templateCache) {
    return {
        replace: true,
        transclude: true,
        restrict: 'A',
        bindToController: {
            question: '=bbQuestion',
            adminRequired: '=bbAdminRequired',
            dateFormatLocale: '=bbDateFormat',
            defaultPlaceholder: '='
        },
        template: "<div ng-if=\"$bbQuestionCtrl.isTemplate\"><div ng-include=\"$bbQuestionCtrl.templateUrl\"></div></div>",
        controller: 'BBQuestionController',
        controllerAs: '$bbQuestionCtrl'
    };
});
'use strict';

angular.module('BB.Controllers').controller('BasketList', function ($scope, $rootScope, $element, $attrs, $q, AlertService, FormDataStoreService, LoginService, LoadingService, BBModel) {

    var params = void 0;
    $scope.setUsingBasket(true);
    var loader = LoadingService.$loader($scope);
    $scope.show_wallet = $scope.bb.company_settings.hasOwnProperty('has_wallets') && $scope.bb.company_settings.has_wallets && $scope.client.valid() && LoginService.isLoggedIn() && LoginService.member().id === $scope.client.id && $scope.client.has_active_wallet;

    // bb.basket.options - added 10-11-2015 @16:19
    // For ex. bb-basket-list="{requires_deal: true}"
    $scope.bb.basket.setSettings($scope.$eval($attrs.bbBasketList) || {});

    $rootScope.connection_started.then(function () {

        if ($scope.client) {
            $scope.bb.basket.setClient($scope.client);
        }
        if ($scope.client.$has('pre_paid_bookings') && $scope.bb.basket.timeItems().length > 0) {

            loader.notLoaded();
            var promises = [];

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = Array.from($scope.bb.basket.timeItems())[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var basket_item = _step.value;

                    var _params = { event_id: basket_item.getEventId() };
                    promises.push($scope.client.$getPrePaidBookings(_params));
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return $q.all(promises).then(function (result) {
                var prepaid_booking = void 0;
                var booking_left = {};

                //populate the prepaid_booking available for all the bookings
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = Array.from(result)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        basket_item = _step2.value;
                        var _iteratorNormalCompletion3 = true;
                        var _didIteratorError3 = false;
                        var _iteratorError3 = undefined;

                        try {
                            for (var _iterator3 = Array.from(basket_item)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                                prepaid_booking = _step3.value;

                                booking_left[prepaid_booking.id] = prepaid_booking.number_of_bookings_remaining;
                            }
                        } catch (err) {
                            _didIteratorError3 = true;
                            _iteratorError3 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                                    _iterator3.return();
                                }
                            } finally {
                                if (_didIteratorError3) {
                                    throw _iteratorError3;
                                }
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }

                var iterable = $scope.bb.basket.timeItems();
                for (var index = 0; index < iterable.length; index++) {
                    basket_item = iterable[index];
                    var prepaid_bookings = result[index];
                    if ($scope.bb.basket.settings && $scope.bb.basket.settings.auto_use_prepaid_bookings && prepaid_bookings.length > 0 && basket_item.price > 0) {
                        for (index = 0; index < prepaid_bookings.length; index++) {
                            prepaid_booking = prepaid_bookings[index];
                            if (booking_left[prepaid_booking.id] > 0) {
                                basket_item.setPrepaidBooking(prepaid_booking);
                                booking_left[prepaid_booking.id] -= 1;
                                break;
                            }
                        }
                    }
                }

                if ($scope.bb.basket.settings.auto_use_prepaid_bookings) {
                    return $scope.updateBasket().then(function () {
                        return groupBasketItems($scope.bb.basket.timeItems());
                    }, function (err) {
                        return loader.setLoaded();
                    });
                } else {
                    return groupBasketItems($scope.bb.basket.timeItems());
                }
            });
        } else {
            return groupBasketItems($scope.bb.basket.timeItems());
        }
    });

    $scope.deleteGroupItem = function (items) {
        $scope.deleteBasketItems(items);
        return $scope.multi_basket_grouping = _.without($scope.multi_basket_grouping, items);
    };

    $scope.editGroupItem = function (items, route) {
        $scope.bb.current_item = items[0];
        return $scope.decideNextPage(route);
    };

    $scope.groupPrice = function (items) {
        var group_price = 0;
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
            for (var _iterator4 = Array.from(items)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var item = _step4.value;

                group_price += item.total_price;
            }
        } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion4 && _iterator4.return) {
                    _iterator4.return();
                }
            } finally {
                if (_didIteratorError4) {
                    throw _iteratorError4;
                }
            }
        }

        return group_price;
    };

    $scope.groupTicketQty = function (items) {
        var group_ticket_qty = 0;
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
            for (var _iterator5 = Array.from(items)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                var item = _step5.value;

                group_ticket_qty += item.tickets.qty;
            }
        } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion5 && _iterator5.return) {
                    _iterator5.return();
                }
            } finally {
                if (_didIteratorError5) {
                    throw _iteratorError5;
                }
            }
        }

        return group_ticket_qty;
    };

    var groupBasketItems = function groupBasketItems(items) {
        // TODO only group events
        $scope.multi_basket_grouping = _.groupBy($scope.bb.basket.timeItems(), 'event_id');
        // (item) -> "#{item.event.date.unix()}_#{item.event_id}"
        $scope.multi_basket_grouping = _.values($scope.multi_basket_grouping);
        return loader.setLoaded();
    };

    var updateLocalBasket = function updateLocalBasket(basket) {
        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
            for (var _iterator6 = Array.from(basket.items)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                var item = _step6.value;

                item.storeDefaults($scope.bb.item_defaults);
            }
        } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion6 && _iterator6.return) {
                    _iterator6.return();
                }
            } finally {
                if (_didIteratorError6) {
                    throw _iteratorError6;
                }
            }
        }

        basket.setSettings($scope.bb.basket.settings);
        return $scope.setBasket(basket);
    };

    /***
     * @ngdoc method
     * @name addAnother
     * @methodOf BB.Directives:bbMiniBasket
     * @description
     * Add another basket item in acording of route parameter
     *
     * @param {string} route A route of the added another item
     */
    // THIS IS FOR SORTING FOR MULTI EVENTS

    $scope.addAnother = function (route) {
        $scope.clearBasketItem();
        $scope.bb.emptyStackedItems();
        //    $scope.bb.current_item.setCompany($scope.bb.company)
        return $scope.decideNextPage(route);
    };

    /***
     * @ngdoc method
     * @name checkout
     * @methodOf BB.Directives:bbMiniBasket
     * @description
     * Reset the basket to the last item whereas the curren_item is not complete and should not be in the basket and that way, we can proceed to checkout instead of hard-coding it on the html page.
     *
     * @param {string} route A route of the added another item
     */
    $scope.checkout = function (route) {

        if ($scope.bb.basket.settings && $scope.bb.basket.settings.requires_deal && !$scope.bb.basket.hasDeal()) {
            AlertService.raise('GIFT_CERTIFICATE_REQUIRED');
            return false;
        }

        if ($scope.bb.basket.items.length > 0) {
            $scope.setReadyToCheckout(true);
            if ($scope.$parent.$has_page_control) {
                return true;
            } else {
                return $scope.decideNextPage(route);
            }
        } else {
            AlertService.raise('EMPTY_BASKET_FOR_CHECKOUT');
            return false;
        }
    };

    /***
     * @ngdoc method
     * @name setReady
     * @methodOf BB.Directives:bbMiniBasket
     * @description
     * Set this page section as ready
     */
    $scope.setReady = function () {
        return $scope.checkout();
    };

    /***
     * @ngdoc method
     * @name applyCoupon
     * @methodOf BB.Directives:bbMiniBasket
     * @description
     * Apply the coupon of basket item in according of coupon parameter
     *
     * @param {string} coupon The applied coupon
     */
    $scope.applyCoupon = function (coupon) {
        AlertService.clear();
        loader.notLoaded();
        params = { bb: $scope.bb, coupon: coupon };

        // first update the basket item on the server
        return BBModel.Basket.$updateBasket($scope.bb.company, params.bb.basket).then(function () {
            return BBModel.Basket.$applyCoupon($scope.bb.company, params).then(function (basket) {
                updateLocalBasket(basket);
                return loader.setLoaded();
            }, function (err) {
                if (err && err.data && err.data.error) {
                    AlertService.clear();
                    AlertService.raise('COUPON_APPLY_FAILED');
                }
                return loader.setLoaded();
            });
        });
    };

    /***
     * @ngdoc method
     * @name applyDeal
     * @methodOf BB.Directives:bbMiniBasket
     * @description
     * Apply the coupon of basket item in according of deal code parameter
     *
     * @param {string} deal code The deal code
     */
    $scope.applyDeal = function (deal_code) {
        AlertService.clear();
        if ($scope.client) {
            params = { bb: $scope.bb, deal_code: deal_code, member_id: $scope.client.id };
        } else {
            params = { bb: $scope.bb, deal_code: deal_code, member_id: null };
        }

        // first update the basket item on the server
        return BBModel.Basket.$updateBasket($scope.bb.company, params.bb.basket).then(function () {
            return BBModel.Basket.$applyDeal($scope.bb.company, params).then(function (basket) {
                updateLocalBasket(basket);
                $scope.items = $scope.bb.basket.items;
                return $scope.deal_code = null;
            }, function (err) {
                if (err && err.data && err.data.error) {
                    AlertService.clear();
                    return AlertService.raise('DEAL_APPLY_FAILED');
                }
            });
        });
    };

    /***
     * @ngdoc method
     * @name removeDeal
     * @methodOf BB.Directives:bbMiniBasket
     * @description
     * Remove the deal in according of deal code parameter
     *
     * @param {string} deal code The deal code
     */
    $scope.removeDeal = function (deal_code) {
        params = { bb: $scope.bb, deal_code_id: deal_code.id };

        // first update the basket item on the server
        return BBModel.Basket.$updateBasket($scope.bb.company, params.bb.basket).then(function () {
            return BBModel.Basket.$removeDeal($scope.bb.company, params).then(function (basket) {
                updateLocalBasket(basket);
                return $scope.items = $scope.bb.basket.items;
            }, function (err) {
                if (err && err.data && err.data.error) {
                    AlertService.clear();
                    return AlertService.raise('DEAL_REMOVE_FAILED');
                }
            });
        });
    };

    return $scope.topUpWallet = function () {
        return $scope.decideNextPage("basket_wallet");
    };
});
'use strict';

angular.module('BB.Directives').directive('bbBasketList', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'BasketList'
    };
});
'use strict';

angular.module('BB.Controllers').controller('BasketSummary', function ($scope) {

    $scope.basket_items = $scope.bb.basket.items;

    /***
     * @ngdoc method
     * @name confirm
     * @methodOf BB.Directives:bbBasketSummary
     * @description
     * Marks the basket as reviewed and invokes the next step
     */
    return $scope.confirm = function () {
        $scope.bb.basket.reviewed = true;
        return $scope.decideNextPage();
    };
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbBasketSummary
 * @restrict AE
 * @scope true
 *
 * @description
 * Loads a summary of the bookings and allows the user to  review and
 * confirm the previously entered information
 */ //


angular.module('BB.Directives').directive('bbBasketSummary', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'BasketSummary'
    };
});
'use strict';

angular.module('BB.Controllers').controller('BulkPurchase', function ($scope, $rootScope, BBModel) {

    $rootScope.connection_started.then(function () {
        if ($scope.bb.company) {
            return $scope.init($scope.bb.company);
        }
    });

    $scope.init = function (company) {
        if (!$scope.booking_item) {
            $scope.booking_item = $scope.bb.current_item;
        }
        return BBModel.BulkPurchase.$query(company).then(function (bulk_purchases) {
            return $scope.bulk_purchases = bulk_purchases;
        });
    };

    /***
     * @ngdoc method
     * @name selectItem
     * @methodOf BB.Directives:bbBulkPurchases
     * @description
     * Select a bulk purchase into the current booking journey and route on to the next page dpending on the current page control
     *
     * @param {object} package Bulk_purchase or BookableItem to select
     * @param {string=} route A specific route to load
     */
    $scope.selectItem = function (item, route) {
        if ($scope.$parent.$has_page_control) {
            $scope.bulk_purchase = item;
            return false;
        } else {
            $scope.booking_item.setBulkPurchase(item);
            $scope.decideNextPage(route);
            return true;
        }
    };

    /***
     * @ngdoc method
     * @name setReady
     * @methodOf BB.Directives:bbBulkPurchases
     * @description
     * Set this page section as ready - see {@link BB.Directives:bbPage Page Control}
     */
    return $scope.setReady = function () {
        if ($scope.bulk_purchase) {
            $scope.booking_item.setBulkPurchase($scope.bulk_purchase);
            return true;
        } else {
            return false;
        }
    };
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbBulkPurchases
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Loads a list of bulk purchases for the currently in scroe company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @param {hash}  bbBulkPurchases   A hash of options
 * @property {array} bulk_purchases An array of all services
 * @property {array} bookable_items An array of all BookableItems - used if the current_item has already selected a resource or person
 * @property {bulk_purchase} bulk_purchase The currectly selected bulk_purchase
 *
 *  <example module="BB">
 *    <file name="index.html">
 *   <div bb-api-url='https://uk.bookingbug.com'>
 *   <div  bb-widget='{company_id:21}'>
 *     <div bb-bulk-purchases>
 *        <ul>
 *          <li ng-repeat='bulk in bulk_purchases'> {{bulk.name}}</li>
 *        </ul>
 *     </div>
 *     </div>
 *     </div>
 *   </file>
 *  </example>
 *
 */ //

angular.module('BB.Directives').directive('bbBulkPurchases', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'BulkPurchase'
    };
});
'use strict';

angular.module('BB.Controllers').controller('CategoryList', function ($scope, $rootScope, $q, LoadingService, BBModel) {

    var loader = LoadingService.$loader($scope).notLoaded();

    $rootScope.connection_started.then(function () {
        if ($scope.bb.company) {
            return $scope.init($scope.bb.company);
        }
    }, function (err) {
        return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
    });

    $scope.init = function (comp) {
        return BBModel.Category.$query(comp).then(function (items) {
            $scope.items = items;
            if (items.length === 1) {
                $scope.skipThisStep();
                $rootScope.categories = items;
                $scope.selectItem(items[0], $scope.nextRoute);
            }
            return loader.setLoaded();
        }, function (err) {
            return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
        });
    };

    /***
     * @ngdoc method
     * @name selectItem
     * @methodOf BB.Directives:bbCategories
     * @description
     * Select an item
     *
     * @param {object} item The Service or BookableItem to select
     * @param {string=} route A specific route to load
     */
    return $scope.selectItem = function (item, route) {
        $scope.bb.current_item.setCategory(item);
        return $scope.decideNextPage(route);
    };
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbCategories
 * @restrict AE
 * @scope true
 *
 * @description
 * Loads a list of categories for the currently in scope company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @property {string} name The category name
 * @property {integer} id The category id
 *
 *  <example module="BB">
 *    <file name="index.html">
 *   <div bb-api-url='https://uk.bookingbug.com'>
 *   <div  bb-widget='{company_id:21}'>
 *     <div bb-categories>
 *        <ul>
 *          <li ng-repeat='category in items'>name: {{category.name}}</li>
 *        </ul>
 *     </div>
 *     </div>
 *     </div>
 *   </file>
 *  </example>
 *
 */ //


angular.module('BB.Directives').directive('bbCategories', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'CategoryList'
    };
});
'use strict';

angular.module('BB.Controllers').controller('Checkout', function ($scope, $rootScope, $attrs, $q, $location, $window, $timeout, $bbug, FormDataStoreService, LoadingService, BBModel) {

    var loader = LoadingService.$loader($scope).notLoaded();

    $scope.options = $scope.$eval($attrs.bbCheckout) || {};

    // clear the form data store as we no longer need the data
    FormDataStoreService.destroy($scope);

    $rootScope.connection_started.then(function () {
        return $scope.checkout();
    });

    $scope.checkout = function () {
        $scope.bb.basket.setClient($scope.client);
        if ($scope.options.no_notifications) {
            $scope.bb.no_notifications = $scope.options.no_notifications;
        }
        $scope.loadingTotal = BBModel.Basket.$checkout($scope.bb.company, $scope.bb.basket, { bb: $scope.bb });
        return $scope.loadingTotal.then(function (total) {
            $scope.total = total;

            // if no payment is required, route to the next step unless instructed otherwise
            if (!total.$has('new_payment')) {
                $scope.$emit("checkout:success", total);
                $scope.bb.total = $scope.total;
                $scope.bb.payment_status = 'complete';
                if (!$scope.options.disable_confirmation) {
                    $scope.skipThisStep();
                    $scope.decideNextPage();
                } else {
                    // Reset ready for another booking
                    $scope.reset();
                }
            }

            $scope.checkoutSuccess = true;
            return loader.setLoaded();
        }
        // currently just close the window and refresh the parent if we're in an admin popup
        , function (err) {
            loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
            $scope.checkoutFailed = true;
            return $scope.$emit("checkout:fail", err);
        });
    };

    /***
     * @ngdoc method
     * @name print
     * @methodOf BB.Directives:bbCheckout
     * @description
     * Print booking details using print_purchase.html template
     *
     */
    // Deprecated - use window.print or $scope.printElement
    // Print booking details using print_purchase.html template
    $scope.print = function () {
        $window.open($scope.bb.partial_url + 'print_purchase.html?id=' + $scope.total.long_id, '_blank', 'width=700,height=500,toolbar=0,menubar=0,location=0,status=1,scrollbars=1,resizable=1,left=0,top=0');
        return true;
    };

    /***
     * @ngdoc method
     * @name printElement
     * @methodOf BB.Directives:bbCheckout
     * @description
     * Print by creating popup containing the contents of the specified element
     *
     * @param {integer} id The id of the specified element
     * @param {string} stylesheet The stylesheet of popup
     */
    // Print by creating popup containing the contents of the specified element
    // TODO move print methods to a service
    return $scope.printElement = function (id, stylesheet) {
        var data = $bbug('#' + id).html();
        // window.open(URL,name,specs,replace)
        // IE8 fix: URL and name params are deliberately left as blank
        // http://stackoverflow.com/questions/710756/ie8-var-w-window-open-message-invalid-argument
        var mywindow = $window.open('', '', 'height=600,width=800');

        return $timeout(function () {
            mywindow.document.write('<html><head><title>Booking Confirmation</title>');

            if (stylesheet) {
                mywindow.document.write('<link rel="stylesheet" href="' + stylesheet + '" type="text/css" />');
            }
            mywindow.document.write('</head><body>');
            mywindow.document.write(data);
            mywindow.document.write('</body></html>');
            //mywindow.document.close()

            return $timeout(function () {
                mywindow.document.close();
                // necessary for IE >= 10
                mywindow.focus();
                // necessary for IE >= 10
                mywindow.print();
                return mywindow.close();
            }, 100);
        }, 2000);
    };
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbCheckout
 * @restrict AE
 * @scope true
 *
 * @description
 * Loads a list of checkouts for the currently in scope company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @param {hash}  bbCheckout   A hash of options
 * @property {string} loadingTotal The loading total
 * @property {string} skipThisStep The skip this step
 * @property {string} decideNextPage The decide next page
 * @property {boolean} checkoutSuccess The checkout success
 * @property {string} setLoaded The set loaded
 * @property {string} setLoadedAndShowError The set loaded and show error
 * @property {boolean} checkoutFailed The checkout failed
 */ //


angular.module('BB.Directives').directive('bbCheckout', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'Checkout'
    };
});
'use strict';

angular.module('BB.Controllers').controller('ClientDetails', function ($scope, $attrs, $rootScope, LoginService, ValidatorService, AlertService, LoadingService, BBModel) {

    var handleError = void 0;
    var loader = LoadingService.$loader($scope).notLoaded();

    console.warn('Deprecation warning: validator.validateForm() will be removed from bbClientDetails in an upcoming major release, please update your template to use bbForm and submitForm() instead. See https://github.com/bookingbug/bookingbug-angular/issues/638');
    $scope.validator = ValidatorService;

    $scope.existing_member = false;
    $scope.login_error = false;

    var options = $scope.$eval($attrs.bbClientDetails) || {};
    $scope.suppress_client_create = $attrs.bbSuppressCreate != null || options.suppress_client_create;

    $rootScope.connection_started.then(function () {
        return $scope.initClientDetails();
    }, function (err) {
        return loader.setLoadedAndShowError($scope, err, 'Sorry, something went wrong');
    });

    $rootScope.$watch('member', function (oldmem, newmem) {
        if (!$scope.client.valid() && LoginService.isLoggedIn()) {
            return $scope.setClient(new BBModel.Client(LoginService.member()._data));
        }
    });

    /***
     * @ngdoc method
     * @name initClientDetails
     * @methodOf BB.Directives:bbClientDetails
     * @description
     * initialise the client object
     */
    $scope.initClientDetails = function () {

        if (!$scope.client.valid() && LoginService.isLoggedIn()) {
            // make sure we set the client to the currently logged in member
            // we should also just check the logged in member is a member of the company they are currently booking with
            $scope.setClient(new BBModel.Client(LoginService.member()._data));
        }

        if (LoginService.isLoggedIn() && LoginService.member().$has("child_clients") && LoginService.member()) {
            LoginService.member().$getChildClients().then(function (children) {
                $scope.bb.parent_client = new BBModel.Client(LoginService.member()._data);
                $scope.bb.child_clients = children;
                return $scope.bb.basket.parent_client_id = $scope.bb.parent_client.id;
            });
        }

        if ($scope.client.client_details) {
            $scope.client_details = $scope.client.client_details;
            if ($scope.client_details.questions) {
                BBModel.Question.$checkConditionalQuestions($scope.client_details.questions);
            }
            return loader.setLoaded();
        } else {
            return BBModel.ClientDetails.$query($scope.bb.company).then(function (details) {
                $scope.client_details = details;
                if ($scope.client) {
                    $scope.client.pre_fill_answers($scope.client_details);
                }
                if ($scope.client_details.questions) {
                    BBModel.Question.$checkConditionalQuestions($scope.client_details.questions);
                }
                return loader.setLoaded();
            }, function (err) {
                return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
            });
        }
    };

    /***
     * @ngdoc method
     * @name validateClient
     * @methodOf BB.Directives:bbClientDetails
     * @description
     * Validate the client
     *
     * @param {string=} route A specific route to load
     */
    $scope.validateClient = function (route) {
        loader.notLoaded();
        $scope.existing_member = false;

        // we need to validate teh client information has been correctly entered here
        if ($scope.bb && $scope.bb.parent_client) {
            $scope.client.parent_client_id = $scope.bb.parent_client.id;
        }
        $scope.client.setClientDetails($scope.client_details);

        return BBModel.Client.$create_or_update($scope.bb.company, $scope.client).then(function (client) {

            loader.setLoaded();
            $scope.setClient(client);
            if ($scope.bb.isAdmin) {
                $scope.client.setValid(true);
            }
            $scope.existing_member = false;
            return $scope.decideNextPage(route);
        }, function (err) {
            return handleError(err);
        });
    };

    /***
     * @ngdoc method
     * @name clientLogin
     * @methodOf BB.Directives:bbClientDetails
     * @description
     * Client login
     */
    $scope.clientLogin = function () {
        $scope.login_error = false;
        if ($scope.login) {
            return LoginService.companyLogin($scope.bb.company, {}, {
                email: $scope.login.email,
                password: $scope.login.password
            }).then(function (client) {
                $scope.setClient(new BBModel.Client(client));
                $scope.login_error = false;
                return $scope.decideNextPage();
            }, function (err) {
                $scope.login_error = true;
                loader.setLoaded();
                return AlertService.raise('LOGIN_FAILED');
            });
        }
    };

    /***
     * @ngdoc method
     * @name setReady
     * @methodOf BB.Directives:bbClientDetails
     * @description
     * Set this page section as ready - see {@link BB.Directives:bbPage Page Control}
     */
    $scope.setReady = function () {

        $scope.client.setClientDetails($scope.client_details);

        if (!$scope.suppress_client_create) {

            var prom = BBModel.Client.$create_or_update($scope.bb.company, $scope.client);

            prom.then(function (client) {

                loader.setLoaded();
                $scope.setClient(client);

                // this method sets the login for newly created user
                LoginService.setLogin(client);

                if (client.waitingQuestions) {
                    return client.gotQuestions.then(function () {
                        return $scope.client_details = client.client_details;
                    });
                }
            }, function (err) {
                return handleError(err);
            });
            return prom;
        } else {

            return true;
        }
    };

    /***
     * @ngdoc method
     * @name clientSearch
     * @methodOf BB.Directives:bbClientDetails
     * @description
     * Client search
     */
    $scope.clientSearch = function () {
        if ($scope.client != null && $scope.client.email != null && $scope.client.email !== "") {
            loader.notLoaded();
            return BBModel.Client.$query_by_email($scope.bb.company, $scope.client.email).then(function (client) {
                if (client != null) {
                    $scope.setClient(client);
                    $scope.client = client;
                }
                return loader.setLoaded();
            }, function (err) {
                return loader.setLoaded();
            });
        } else {
            $scope.setClient({});
            return $scope.client = {};
        }
    };

    /***
     * @ngdoc method
     * @name switchNumber
     * @methodOf BB.Directives:bbClientDetails
     * @description
     * Switch number
     *
     * @param {array} to Switch number to mobile
     */
    $scope.switchNumber = function (to) {
        $scope.no_mobile = !$scope.no_mobile;
        if (to === 'mobile') {
            $scope.bb.basket.setSettings({ send_sms_reminder: true });
            return $scope.client.phone = null;
        } else {
            $scope.bb.basket.setSettings({ send_sms_reminder: false });
            return $scope.client.mobile = null;
        }
    };

    /***
     * @ngdoc method
     * @name getQuestion
     * @methodOf BB.Directives:bbClientDetails
     * @description
     * Get question by id
     *
     * @param {integer} id The id question
     */
    $scope.getQuestion = function (id) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = Array.from($scope.client_details.questions)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var question = _step.value;

                if (question.id === id) {
                    return question;
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        return null;
    };

    /***
     * @ngdoc method
     * @name useClient
     * @methodOf BB.Directives:bbClientDetails
     * @description
     * Use client by client
     *
     * @param {array} client The client
     */
    $scope.useClient = function (client) {
        return $scope.setClient(client);
    };

    /***
     * @ngdoc method
     * @name recalc_question
     * @methodOf BB.Directives:bbClientDetails
     * @description
     * Recalculate question
     */
    $scope.recalc_question = function () {
        if ($scope.client_details.questions) {
            return BBModel.Question.$checkConditionalQuestions($scope.client_details.questions);
        }
    };

    return handleError = function handleError(error) {
        if (error.data.error === "Please Login") {
            $scope.existing_member = true;
            AlertService.raise('ALREADY_REGISTERED');
        } else if (error.data.error === "Invalid Password") {
            AlertService.raise('PASSWORD_INVALID');
        }
        return loader.setLoaded();
    };
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbClientDetails
 * @restrict AE
 * @scope true
 *
 * @description
 * Loads a list of client details for the currently in scope company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @property {array} questions Questions of the client
 * @property {integer} company_id The company id of the client company
 * @property {object} validator The validator service - see {@link BB.Services:Validator Validator Service}
 * @property {object} alert The alert service - see {@link BB.Services:Alert Alert Service}

 *  <example module="BB">
 *    <file name="index.html">
 *   <div bb-api-url='https://uk.bookingbug.com'>
 *   <div  bb-widget='{company_id:21}'>
 *     <div bb-client-details>
 *        <p>company_id: {{client_details.company_id}}</p>
 *        <p>offer_login: {{client_details.offer_login}}</p>
 *        <p>ask_address: {{client_details.ask_address}}</p>
 *        <p>no_phone: {{client_details.no_phone}}</p>
 *      </div>
 *     </div>
 *     </div>
 *   </file>
 *  </example>
 *
 */ //


angular.module('BB.Directives').directive('bbClientDetails', function ($q, $templateCache, $compile) {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        transclude: true,
        controller: 'ClientDetails',
        link: function link(scope, element, attrs, controller, transclude) {

            return transclude(scope, function (clone) {
                // if there's content compile that or grab the client_details template
                var has_content = clone.length > 1 || clone.length === 1 && (!clone[0].wholeText || /\S/.test(clone[0].wholeText));
                if (has_content) {
                    return element.html(clone).show();
                } else {
                    return $q.when($templateCache.get('_client_details.html')).then(function (template) {
                        element.html(template).show();
                        return $compile(element.contents())(scope);
                    });
                }
            });
        }
    };
});
'use strict';

var CompanyListBase = function CompanyListBase($scope, $rootScope, $q, $attrs, LoadingService) {

    var loader = LoadingService.$loader($scope).notLoaded();

    var options = $scope.$eval($attrs.bbCompanies);

    $rootScope.connection_started.then(function () {
        if ($scope.bb.company.companies) {
            $scope.init($scope.bb.company);
            return $rootScope.parent_id = $scope.bb.company.id;
        } else if ($rootScope.parent_id) {
            $scope.initWidget({ company_id: $rootScope.parent_id, first_page: $scope.bb.current_page });
            return;
        } else {
            return $scope.init($scope.bb.company);
        }
    }, function (err) {
        return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
    });

    $scope.init = function (comp) {

        $scope.companies = $scope.bb.company.companies;
        if (!$scope.companies || $scope.companies.length === 0) {
            $scope.companies = [$scope.bb.company];
        }

        if ($scope.companies.length === 1) {
            $scope.skipThisStep();
            $scope.selectItem($scope.companies[0]);
        } else {
            if (options && options.hide_not_live_stores) {
                $scope.items = $scope.companies.filter(function (c) {
                    return c.live;
                });
            } else {
                $scope.items = $scope.companies;
            }
        }
        return loader.setLoaded();
    };

    $scope.selectItem = function (item, route) {

        // if company id is passed in, set the company id to this number
        var company_id = void 0;
        if (angular.isNumber(item)) {
            company_id = item;
        } else {
            company_id = item.id;
        }

        loader.notLoaded();
        var prms = { company_id: company_id };
        return $scope.initWidget(prms);
    };

    // TODO move this into a mothercare js file
    return $scope.splitString = function (company) {
        var arr = company.name.split(' ');
        return arr[2] ? arr[2] : "";
    };
};

angular.module('BB.Controllers').controller('CompanyList', CompanyListBase);
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbCompanies
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Loads a list of companies for the currently in scope company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @property {integer} id The company id
 * @property {string} name The company name
 * @property {integer} address_id Company address id
 * @property {string} country_code Company country code
 * @property {string} currency_code The company currency code
 * @property {string} timezone The company time zone
 * @property {integer} numeric_widget_id The numeric widget id of the company
 * @property {object} validator The validator service - see {@link BB.Services:Validator Validator Service}
 * @property {object} alert The alert service - see {@link BB.Services:Alert Alert Service}
 *
 *  <example module="BB">
 *    <file name="index.html">
 *   <div bb-api-url='https://uk.bookingbug.com'>
 *   <div  bb-widget='{company_id:21}'>
 *     <div bb-company>
 *       <p>id: {{company.id}}</p>
 *        <p>name: {{company.name}}</p>
 *        <p>address_id: {{company.address_id}}</p>
 *        <p>country_code: {{company.country_code}}</p>
 *        <p>currency_code: {{company.country_code}}</p>
 *        <p>timezone: {{company.timezone}}</p>
 *        <p>numeric_widget_id: {{company.numeric_widget_id}}</p>
 *      </div>
 *     </div>
 *     </div>
 *   </file>
 *  </example>
 */ //

angular.module('BB.Directives').directive('bbCompanies', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'CompanyList'
    };
});
'use strict';

(function () {

    angular.module('BB.Controllers').controller('DayList', dayListController);

    function dayListController($scope, $rootScope, DayService, bbAnalyticsPiwik) {
        'ngInject';
        // Load up some day based data

        $rootScope.connection_started.then(function () {

            // Re-scoping the lost moment object inside the template
            $scope.moment = moment;

            if (!$scope.current_date && $scope.last_selected_date) {
                $scope.selected_date = $scope.last_selected_date.clone();
                setCurrentDate($scope.last_selected_date.clone().startOf('week'));
            } else if (!$scope.current_date) {
                setCurrentDate(moment().startOf('week'));
            }
            return $scope.loadData();
        }, function (err) {
            return $scope.setLoadedAndShowError($scope, err, 'Sorry, something went wrong');
        });

        $scope.$on('BBTimeZoneOptions:timeZoneChanged', function () {
            if (!$scope.bb.current_item.date) return;
            $scope.selectDay($scope.bb.current_item.date);
        });

        $scope.selectDay = function (day) {
            if (!day.spaces || day.spaces && day.spaces === 0) {
                return;
            }
            $scope.setLastSelectedDate(day.date);
            $scope.selected_date = day.date;
            $scope.bb.current_item.setDate(day);
            return $scope.$broadcast('dateChanged', day.date);
        };

        var setCurrentDate = function setCurrentDate(date) {
            $scope.current_date = date;
            return $scope.current_date_js = $scope.current_date.toDate();
        };

        function setPiwik(amount) {
            var category = "Calendar";
            var title = "Load Next Week";
            if (amount < 0) {
                title = "Load Previous Week";
            }
            bbAnalyticsPiwik.push(['trackEvent', [category], title]);
        }

        $scope.add = function (type, amount) {
            if (bbAnalyticsPiwik.isEnabled()) setPiwik(amount);
            setCurrentDate($scope.current_date.add(amount, type));
            return $scope.loadData();
        };

        $scope.subtract = function (type, amount) {
            return $scope.add(type, -amount);
        };

        $scope.currentDateChanged = function () {
            var date = moment($scope.current_date_js).startOf('week');
            setCurrentDate(date);
            return $scope.loadData();
        };

        // disable any day but monday
        $scope.isDateDisabled = function (date, mode) {
            date = moment(date);
            var result = mode === 'day' && (date.day() !== 1 || date.isBefore(moment(), 'day'));
            return result;
        };

        // calculate if the current earlist date is in the past - in which case we might want to disable going backwards
        $scope.isPast = function () {
            if (!$scope.current_date) {
                return true;
            }
            return moment().isAfter($scope.current_date);
        };

        return $scope.loadData = function () {
            $scope.day_data = {};
            $scope.notLoaded($scope);
            $scope.end_date = moment($scope.current_date).add(5, 'weeks');

            var promise = DayService.query({
                company: $scope.bb.company,
                cItem: $scope.bb.current_item,
                date: $scope.current_date.toISODate(),
                edate: $scope.end_date.toISODate(),
                client: $scope.client
            });

            return promise.then(function (days) {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Array.from(days)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var day = _step.value;

                        $scope.day_data[day.string_date] = { spaces: day.spaces, date: day.date };
                    }

                    // group the day data by week
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                $scope.weeks = _.groupBy($scope.day_data, function (day) {
                    return day.date.week();
                });
                $scope.weeks = _.toArray($scope.weeks);

                $scope.$emit('bbDayList:loaded');

                return $scope.setLoaded($scope);
            }, function (err) {
                return $scope.setLoadedAndShowError($scope, err, 'Sorry, something went wrong');
            });
        };
    }
})();
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbDayList
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Next 5 week calendar with time selection
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *ice}
 */ //


angular.module('BB.Directives').directive('bbDayList', function () {
    return {
        restrict: 'A',
        replace: true,
        scope: true,
        controller: 'DayList'
    };
});
'use strict';

angular.module('BB.Controllers').controller('DealList', function ($scope, $rootScope, $uibModal, $document, AlertService, FormDataStoreService, ValidatorService, LoadingService, BBModel, $translate) {

    FormDataStoreService.init('DealList', $scope, ['deals']);
    var loader = LoadingService.$loader($scope).notLoaded();

    console.warn('Deprecation warning: validator.validateForm() will be removed from bbDealList in an upcoming major release, please update your template to use bbForm and submitForm() instead. See https://github.com/bookingbug/bookingbug-angular/issues/638');
    $scope.validator = ValidatorService;

    $rootScope.connection_started.then(function () {
        return init();
    }, function (err) {
        return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
    });

    var init = function init() {
        loader.notLoaded();
        if (!$scope.deals) {
            var deal_promise = BBModel.Deal.$query($scope.bb.company);
            return deal_promise.then(function (deals) {
                $scope.deals = deals;
                return loader.setLoaded();
            });
        }
    };

    /***
     * @ngdoc method
     * @name selectDeal
     * @methodOf BB.Directives:bbDeals
     * @description
     * Select the deal and open modal
     *
     * @param {array} deal The deals array
     */
    $scope.selectDeal = function (deal) {
        var iitem = new BBModel.BasketItem(null, $scope.bb);
        iitem.setDefaults($scope.bb.item_defaults);
        iitem.setDeal(deal);
        if (!$scope.bb.company_settings.no_recipient) {
            var modalInstance = $uibModal.open({
                templateUrl: $scope.getPartial('_add_recipient'),
                scope: $scope,
                controller: ModalInstanceCtrl,
                resolve: {
                    item: function item() {
                        return iitem;
                    }
                }
            });

            return modalInstance.result.then(function (item) {
                loader.notLoaded();
                $scope.setBasketItem(item);
                return $scope.addItemToBasket().then(function () {
                    return loader.setLoaded();
                }, function (err) {
                    return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
                });
            });
        } else {
            loader.notLoaded();
            $scope.setBasketItem(iitem);
            return $scope.addItemToBasket().then(function () {
                return loader.setLoaded();
            }, function (err) {
                return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
            });
        }
    };

    var ModalInstanceCtrl = function ModalInstanceCtrl($scope, $uibModalInstance, item, ValidatorService) {
        $scope.item = item;
        $scope.recipient = false;

        /***
         * @ngdoc method
         * @name addToBasket
         * @methodOf BB.Directives:bbDeals
         * @description
         * Add to basket in according of form parameter
         *
         * @param {object} form The form where is added deal list to basket
         */
        $scope.addToBasket = function (form) {
            if (!ValidatorService.validateForm(form)) {
                return;
            }
            return $uibModalInstance.close($scope.item);
        };

        return $scope.cancel = function () {
            return $uibModalInstance.dismiss('cancel');
        };
    };

    /***
     * @ngdoc method
     * @name purchaseDeals
     * @methodOf BB.Directives:bbDeals
     * @description
     * Purchase deals if basket items and basket items length is bigger than 0 else display a alert message
     */
    $scope.purchaseDeals = function () {
        if ($scope.bb.basket.items && $scope.bb.basket.items.length > 0) {
            return $scope.decideNextPage();
        } else {
            return AlertService.add('danger', { msg: $translate.instant('PUBLIC_BOOKING.DEAL_LIST.CERT_NOT_SELECTED_ALERT') });
        }
    };

    /***
     * @ngdoc method
     * @name setReady
     * @methodOf BB.Directives:bbDeals
     * @description
     * Set this page section as ready
     */
    return $scope.setReady = function () {
        if ($scope.bb.basket.items && $scope.bb.basket.items.length > 0) {
            return true;
        } else {
            return AlertService.add('danger', { msg: $translate.instant('PUBLIC_BOOKING.DEAL_LIST.CERT_NOT_SELECTED_ALERT') });
        }
    };
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbDeals
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Loads a list of deals for the currently in scope company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @property {array} deals The deals list
 * @property {object} validator The validator service - see {@link BB.Services:Validator Validator Service}
 * @property {object} alert The alert service - see {@link BB.Services:Alert Alert Service}
 */ //


angular.module('BB.Directives').directive('bbDeals', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'DealList'
    };
});
'use strict';

angular.module('BB.Controllers').controller('DurationList', function ($scope, $attrs, $rootScope, $q, $filter, AlertService, ValidatorService, LoadingService, $translate, routeStates) {

    var duration = void 0;
    var loader = LoadingService.$loader($scope).notLoaded();

    var options = $scope.$eval($attrs.bbDurations) || {};

    $rootScope.connection_started.then(function () {
        return $scope.loadData();
    }, function (err) {
        return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
    });

    $scope.loadData = function () {
        var service = $scope.bb.current_item.service;

        if (service) {
            $scope.durations = Array.from(_.zip(service.durations, service.prices)).map(function (d) {
                return { value: d[0], price: d[1] };
            });

            var initial_duration = $scope.$eval($attrs.bbInitialDuration);

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = Array.from($scope.durations)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    duration = _step.value;

                    // does the current item already have a duration?
                    if ($scope.bb.current_item.duration && duration.value === $scope.bb.current_item.duration) {
                        $scope.duration = duration;
                    } else if (initial_duration && initial_duration === duration.value) {
                        $scope.duration = duration;
                        $scope.bb.current_item.setDuration(duration.value);
                    }

                    duration.pretty = $filter('time_period')(duration.value);
                    if (options.show_prices) {
                        duration.pretty += ' (' + $filter('currency')(duration.price) + ')';
                    }
                }
                // If the duration is still not defined set it to the first duration in durations
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            if (!$scope.duration) {
                $scope.duration = $scope.durations[0];
            }
            if ($scope.durations.length === 1) {
                $scope.skipThisStep();
                $scope.selectDuration($scope.durations[0], $scope.nextRoute);
            }
        }

        return loader.setLoaded();
    };

    /***
     * @ngdoc method
     * @name selectItem
     * @methodOf BB.Directives:bbDurations
     * @description
     * Select duration of the list in according of dur and route parameter
     *
     * @param {object} dur The duration list
     * @param {string=} route A specific route to load
     */
    $scope.selectDuration = function (dur, route) {
        if ($scope.$parent.$has_page_control) {
            $scope.duration = dur;
            return;
        } else {
            $scope.bb.current_item.setDuration(dur.value);
            $scope.decideNextPage(route);
            return true;
        }
    };

    /***
     * @ngdoc method
     * @name durationChanged
     * @methodOf BB.Directives:bbDurations
     * @description
     * Change the list duration and update item
     */
    $scope.durationChanged = function () {
        $scope.bb.current_item.setDuration($scope.duration.value);
        $scope.broadcastItemUpdate(routeStates.Duration);
    };

    /***
     * @ngdoc method
     * @name setReady
     * @methodOf BB.Directives:bbDurations
     * @description
     * Set this page section as ready
     */
    $scope.setReady = function () {
        if ($scope.duration) {
            $scope.bb.current_item.setDuration($scope.duration.value);
            return true;
        } else {
            AlertService.clear();
            AlertService.add("danger", { msg: $translate.instant('PUBLIC_BOOKING.DURATION_LIST.DURATON_NOT_SELECTED_ALERT') });
            return false;
        }
    };

    $scope.$on("currentItemUpdate", reloadIfDurationChanged);

    function reloadIfDurationChanged(event, currentItem, payload) {
        if (payload === null || payload !== routeStates.Duration) $scope.loadData();
    }
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbDurations
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Loads a list of durations for the currently in scope company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @property {array} duration The duration list
 * @property {object} alert The alert service - see {@link BB.Services:Alert Alert Service}
 */ //


angular.module('BB.Directives').directive('bbDurations', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'DurationList'
    };
});
'use strict';

angular.module('BB.Controllers').controller('Event', function ($scope, $attrs, $rootScope, EventService, $q, BBModel, ValidatorService, FormDataStoreService, LoadingService) {

    var initTickets = void 0;
    var loader = LoadingService.$loader($scope).notLoaded();

    console.warn('Deprecation warning: validator.validateForm() will be removed from bbEvent in an upcoming major release, please update your template to use bbForm and submitForm() instead. See https://github.com/bookingbug/bookingbug-angular/issues/638');
    $scope.validator = ValidatorService;

    $scope.event_options = $scope.$eval($attrs.bbEvent) || {};

    var ticket_refs = [];

    FormDataStoreService.init('Event', $scope, ['selected_tickets', 'event_options']);

    $rootScope.connection_started.then(function () {

        if ($scope.bb.company) {
            return init($scope.bb.company);
        }
    }, function (err) {
        return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
    });

    var init = function init(comp) {

        // clear selected tickets if there are no stacked items (i.e. because a new event has been selected)
        if ($scope.bb.stacked_items && $scope.bb.stacked_items.length === 0) {
            delete $scope.selected_tickets;
        }

        $scope.event = $scope.bb.current_item.event;

        $scope.event_options.use_my_details = $scope.event_options.use_my_details == null ? true : $scope.event_options.use_my_details;

        var promises = [$scope.bb.current_item.event_group.$getImages(), $scope.event.prepEvent()];

        if ($scope.client) {
            promises.push($scope.getPrePaidsForEvent($scope.client, $scope.event));
        }

        return $q.all(promises).then(function (result) {

            var images = void 0;
            if (result[0] && result[0].length > 0) {
                images = result[0];
            }
            var event = result[1];
            if (result[2] && result[2].length > 0) {
                //let prepaids = result[2];
            }

            $scope.event = event;

            if (images) {
                initImage(images);
            }

            if ($scope.bb.current_item.tickets && $scope.bb.current_item.tickets.qty > 0) {

                // flag that we're editing tickets already in the basket so that view can indicate this
                $scope.edit_mode = true;

                // already added to the basket
                loader.setLoaded();
                $scope.selected_tickets = true;

                // set tickets and current tickets items as items with the same event id
                $scope.current_ticket_items = _.filter($scope.bb.basket.timeItems(), function (item) {
                    return item.event_id === $scope.event.id;
                });

                $scope.tickets = function () {
                    var result1 = [];
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = Array.from($scope.current_ticket_items)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var item = _step.value;

                            result1.push(item.tickets);
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }

                    return result1;
                }();

                $scope.$watch('current_ticket_items', function (items, olditems) {
                    return $scope.bb.basket.total_price = $scope.bb.basket.totalPrice();
                }, true);
                return;
            } else {

                initTickets();
            }

            $scope.$broadcast("bbEvent:initialised");

            return loader.setLoaded();
        }, function (err) {
            return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
        });
    };

    /***
     * @ngdoc method
     * @name selectTickets
     * @methodOf BB.Directives:bbEvent
     * @description
     * Processes the selected tickets and adds them to the basket
     */
    $scope.selectTickets = function () {

        var item = void 0,
            ref = void 0;
        loader.notLoaded();
        $scope.bb.emptyStackedItems();
        // NOTE: basket is not cleared here as we might already have one!

        var base_item = $scope.bb.current_item;

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
            for (var _iterator2 = Array.from($scope.event.tickets)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var ticket = _step2.value;

                if (ticket.qty) {
                    switch ($scope.event.chain.ticket_type) {
                        case "single_space":
                            for (var c = 1, end = ticket.qty, asc = 1 <= end; asc ? c <= end : c >= end; asc ? c++ : c--) {
                                item = new BBModel.BasketItem();
                                var _item = item;
                                ref = _item.ref;

                                angular.extend(item, base_item);
                                item.ref = ref;
                                ticket_refs.push(item.ref);
                                delete item.id;
                                item.tickets = angular.copy(ticket);
                                item.tickets.qty = 1;
                                $scope.bb.stackItem(item);
                            }
                            break;
                        case "multi_space":
                            item = new BBModel.BasketItem();
                            var _item2 = item;
                            ref = _item2.ref;

                            angular.extend(item, base_item);
                            item.ref = ref;
                            ticket_refs.push(item.ref);
                            item.tickets = angular.copy(ticket);
                            delete item.id;
                            item.tickets.qty = ticket.qty;
                            $scope.bb.stackItem(item);
                            break;
                    }
                }
            }

            // ok so we have them as stacked items
            // now push the stacked items to a basket
        } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                }
            } finally {
                if (_didIteratorError2) {
                    throw _iteratorError2;
                }
            }
        }

        if ($scope.bb.stacked_items.length === 0) {
            loader.setLoaded();
            return;
        }

        $scope.bb.pushStackToBasket();

        return $scope.updateBasket().then(function () {

            // basket has been saved
            loader.setLoaded();
            $scope.selected_tickets = true;
            $scope.stopTicketWatch();

            // set tickets and current tickets items as the newly created basket items
            $scope.current_ticket_items = _.filter($scope.bb.basket.timeItems(), function (item) {
                return _.contains(ticket_refs, item.ref);
            });

            $scope.tickets = function () {
                var result = [];
                var _iteratorNormalCompletion3 = true;
                var _didIteratorError3 = false;
                var _iteratorError3 = undefined;

                try {
                    for (var _iterator3 = Array.from($scope.current_ticket_items)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                        item = _step3.value;

                        result.push(item.tickets);
                    }
                } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion3 && _iterator3.return) {
                            _iterator3.return();
                        }
                    } finally {
                        if (_didIteratorError3) {
                            throw _iteratorError3;
                        }
                    }
                }

                return result;
            }();

            // watch the basket items so the price is updated
            return $scope.$watch('current_ticket_items', function (items, olditems) {
                return $scope.bb.basket.total_price = $scope.bb.basket.totalPrice();
            }, true);
        }, function (err) {
            return $scope.setLoadedAndShowError($scope, err, 'Sorry, something went wrong');
        });
    };

    /***
     * @ngdoc method
     * @name selectItem
     * @methodOf BB.Directives:bbEvent
     * @description
     * Select an item event in according of item and route parameter
     *
     * @param {array} item The Event or BookableItem to select
     * @param {string=} route A specific route to load
     */
    $scope.selectItem = function (item, route) {
        if ($scope.$parent.$has_page_control) {
            $scope.event = item;
            return false;
        } else {
            $scope.bb.current_item.setEvent(item);
            $scope.bb.current_item.ready = false;
            $scope.decideNextPage(route);
            return true;
        }
    };

    /***
     * @ngdoc method
     * @name setReady
     * @methodOf BB.Directives:bbEvent
     * @description
     * Set this page section as ready
     */
    $scope.setReady = function () {
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {

            for (var _iterator4 = Array.from($scope.current_ticket_items)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var item = _step4.value;

                item.setEvent($scope.event);
            }
        } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion4 && _iterator4.return) {
                    _iterator4.return();
                }
            } finally {
                if (_didIteratorError4) {
                    throw _iteratorError4;
                }
            }
        }

        $scope.bb.event_details = {
            name: $scope.event.chain.name,
            image: $scope.event.image,
            address: $scope.event.chain.address,
            datetime: $scope.event.date,
            end_datetime: $scope.event.end_datetime,
            duration: $scope.event.duration,
            tickets: $scope.event.tickets
        };

        if ($scope.event_options.suppress_basket_update) {
            return true;
        } else {
            return $scope.updateBasket();
        }
    };

    /***
     * @ngdoc method
     * @name getPrePaidsForEvent
     * @methodOf BB.Directives:bbEvent
     * @description
     * Get pre paids for event in according of client and event parameter
     *
     * @param {array} client The client
     * @param {array} event The event
     */
    $scope.getPrePaidsForEvent = function (client, event) {
        var defer = $q.defer();
        var params = { event_id: event.id };
        client.$getPrePaidBookings(params).then(function (prepaids) {
            $scope.pre_paid_bookings = prepaids;
            return defer.resolve(prepaids);
        }, function (err) {
            return defer.reject(err);
        });
        return defer.promise;
    };

    var initImage = function initImage(images) {
        var image = images[0];
        if (image) {
            image.background_css = { 'background-image': 'url(' + image.url + ')' };
            return $scope.event.image = image;
        }
    };
    // TODO pick most promiment image
    // colorThief = new ColorThief()
    // colorThief.getColor image.url


    return initTickets = function initTickets() {

        // no need to init tickets if some have been selected already
        if ($scope.selected_tickets) {
            return;
        }

        // if a default number of tickets is provided, set only the first ticket type to that default
        $scope.event.tickets[0].qty = $scope.event_options.default_num_tickets ? $scope.event_options.default_num_tickets : 0;

        // for multiple ticket types (adult entry/child entry etc), default all to zero except for the first ticket type
        if ($scope.event.tickets.length > 1) {
            var _iteratorNormalCompletion5 = true;
            var _didIteratorError5 = false;
            var _iteratorError5 = undefined;

            try {
                for (var _iterator5 = Array.from($scope.event.tickets.slice(1))[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                    var ticket = _step5.value;

                    ticket.qty = 0;
                }
            } catch (err) {
                _didIteratorError5 = true;
                _iteratorError5 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion5 && _iterator5.return) {
                        _iterator5.return();
                    }
                } finally {
                    if (_didIteratorError5) {
                        throw _iteratorError5;
                    }
                }
            }
        }

        // lock the ticket number dropdown box if only 1 ticket is available to puchase at a time (one-on-one training etc)
        if ($scope.event_options.default_num_tickets && $scope.event_options.auto_select_tickets && $scope.event.tickets.length === 1 && $scope.event.tickets[0].max_num_bookings === 1) {
            $scope.selectTickets();
        }

        $scope.tickets = $scope.event.tickets;
        $scope.bb.basket.total_price = $scope.bb.basket.totalPrice();
        return $scope.stopTicketWatch = $scope.$watch('tickets', function (tickets, oldtickets) {
            $scope.bb.basket.total_price = $scope.bb.basket.totalPrice();
            return $scope.event.updatePrice();
        }, true);
    };
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbEvent
 * @restrict AE
 * @scope true
 *
 * @description
 * Loads a list of event for the currently in scope company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @property {integer} total_entries The total entries of the event
 * @property {array} events The events array
 * @property {object} validator The validator service - see {@link BB.Services:Validator Validator Service}
 */ //


angular.module('BB.Directives').directive('bbEvent', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'Event'
    };
});
'use strict';

angular.module('BB.Controllers').controller('EventGroupList', function ($scope, $rootScope, $q, $attrs, ItemService, FormDataStoreService, ValidatorService, LoadingService) {

    FormDataStoreService.init('EventGroupList', $scope, ['event_group']);
    var loader = LoadingService.$loader($scope).notLoaded();

    $rootScope.connection_started.then(function () {
        if ($scope.bb.company) {
            return $scope.init($scope.bb.company);
        }
    }, function (err) {
        return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
    });

    $scope.init = function (comp) {
        if (!$scope.booking_item) {
            $scope.booking_item = $scope.bb.current_item;
        }
        var ppromise = comp.getEventGroups();

        return ppromise.then(function (items) {
            // not all service lists need filtering. check for attribute first
            var item = void 0;
            var filterItems = $attrs.filterServices === 'false' ? false : true;

            if (filterItems) {
                if ($scope.booking_item.service_ref && !$scope.show_all) {
                    items = items.filter(function (x) {
                        return x.api_ref === $scope.booking_item.service_ref;
                    });
                } else if ($scope.booking_item.category && !$scope.show_all) {
                    // if we've selected a category for the current item - limit the list
                    // of services to ones that are relevant
                    items = items.filter(function (x) {
                        return x.$has('category') && x.$href('category') === $scope.booking_item.category.self;
                    });
                }
            }

            if (items.length === 1 && !$scope.allowSinglePick) {
                if (!$scope.selectItem(items[0], $scope.nextRoute)) {
                    setEventGroupItem(items);
                } else {
                    $scope.skipThisStep();
                }
            } else {
                setEventGroupItem(items);
            }

            // if there's a default - pick it and move on
            var default_event_group = $scope.booking_item.defaultService();
            if (default_event_group) {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Array.from(items)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        item = _step.value;

                        if (item.self === default_event_group.self) {
                            $scope.selectItem(item, $scope.nextRoute);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }

            // if there's one selected - just select it
            if ($scope.booking_item.event_group) {
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = Array.from(items)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        item = _step2.value;

                        item.selected = false;
                        if (item.self === $scope.booking_item.event_group.self) {
                            $scope.event_group = item;
                            item.selected = true;
                            $scope.booking_item.setEventGroup($scope.event_group);
                        }
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }
            }

            loader.setLoaded();

            if ($scope.booking_item.event_group || !$scope.booking_item.person && !$scope.booking_item.resource) {
                // the "bookable services" are the event_group unless we've pre-selected something!
                return $scope.bookable_services = $scope.items;
            }
        }, function (err) {
            return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
        });
    };

    /***
     * @ngdoc method
     * @name setEventGroupItem
     * @methodOf BB.Directives:bbEventGroups
     * @description
     * Set event group item in accroding of items parameter
     *
     * @param {array} items Items of event group
     */
    // set the event_group item so the correct item is displayed in the dropdown menu.
    // without doing this the menu will default to 'please select'
    var setEventGroupItem = function setEventGroupItem(items) {
        $scope.items = items;
        if ($scope.event_group) {
            return _.each(items, function (item) {
                if (item.id === $scope.event_group.id) {
                    return $scope.event_group = item;
                }
            });
        }
    };

    /***
     * @ngdoc method
     * @name selectItem
     * @methodOf BB.Directives:bbEventGroups
     * @description
     * Select an item from event group in according of item and route parameters
     *
     * @param {array} item The event group or BookableItem to select
     * @param {string=} route A specific route to load
     */
    $scope.selectItem = function (item, route) {
        if ($scope.$parent.$has_page_control) {
            $scope.event_group = item;
            return false;
        } else {
            $scope.booking_item.setEventGroup(item);
            $scope.decideNextPage(route);
            return true;
        }
    };

    $scope.$watch('event_group', function (newval, oldval) {
        if ($scope.event_group) {
            if (!$scope.booking_item.event_group || $scope.booking_item.event_group.self !== $scope.event_group.self) {
                // only set and broadcast if it's changed
                $scope.booking_item.setEventGroup($scope.event_group);
                return $scope.broadcastItemUpdate();
            }
        }
    });

    /***
     * @ngdoc method
     * @name setReady
     * @methodOf BB.Directives:bbEventGroups
     * @description
     * Set this page section as ready
     */
    return $scope.setReady = function () {
        if ($scope.event_group) {
            $scope.booking_item.setEventGroup($scope.event_group);
            return true;
        } else {
            return false;
        }
    };
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbEventGroups
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Loads a list of event groups for the currently in scope company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @property {integer} total_entries The event total entries
 * @property {array} events The events array
 * @property {hash} filters A hash of filters
 * @property {object} validator The validator service - see {@link BB.Services:Validator Validator Service}
 */ //


angular.module('BB.Directives').directive('bbEventGroups', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'EventGroupList',
        link: function link(scope, element, attrs) {
            if (attrs.bbItem) {
                scope.booking_item = scope.$eval(attrs.bbItem);
            }
            if (attrs.bbShowAll) {
                scope.show_all = true;
            }
        }
    };
});
'use strict';

angular.module('BB.Controllers').controller('EventList', function ($scope, $rootScope, EventService, EventChainService, EventGroupService, $q, FormDataStoreService, $filter, PaginationService, $timeout, ValidatorService, LoadingService, BBModel) {

    var i = void 0;
    var loader = LoadingService.$loader($scope).notLoaded();

    $scope.pick = {};
    $scope.start_date = moment();
    $scope.end_date = moment().add(1, 'year');
    $scope.filters = { hide_fully_booked_events: false };
    $scope.pagination = PaginationService.initialise({ page_size: 10, max_size: 5 });
    $scope.events = {};
    $scope.fully_booked = false;
    $scope.event_data_loaded = false;

    FormDataStoreService.init('EventList', $scope, ['selected_date', 'event_group_id', 'event_group_manually_set']);

    $rootScope.connection_started.then(function () {

        if ($scope.bb.company) {
            // if there's a default event, skip this step
            if ($scope.bb.item_defaults && $scope.bb.item_defaults.event || $scope.bb.current_item.defaults && $scope.bb.current_item.defaults.event) {

                $scope.skipThisStep();
                $scope.decideNextPage();
                return;
            } else if ($scope.bb.company.$has('parent') && !$scope.bb.company.$has('company_questions')) {

                return $scope.bb.company.$getParent().then(function (parent) {
                    $scope.company_parent = parent;
                    return $scope.initialise();
                }, function (err) {
                    return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
                });
            } else {

                return $scope.initialise();
            }
        }
    }, function (err) {
        return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
    });

    $scope.initialise = function () {

        var event_group = void 0;
        loader.notLoaded();

        if ($scope.mode !== 0) {
            delete $scope.selected_date;
        }

        // has the event group been manually set (i.e. in the step before)
        if (!$scope.event_group_manually_set && $scope.bb.current_item.event_group == null) {
            $scope.event_group_manually_set = $scope.event_group_manually_set == null && $scope.bb.current_item.event_group != null;
        }

        // clear current item
        if ($scope.bb.current_item.event) {
            event_group = $scope.bb.current_item.event_group;

            $scope.clearBasketItem();
            // TODO only remove the basket items added in this session
            $scope.emptyBasket();
            if ($scope.event_group_manually_set) {
                $scope.bb.current_item.setEventGroup(event_group);
            }
        }

        var promises = [];

        // company question promise
        if ($scope.bb.company.$has('company_questions')) {
            promises.push($scope.bb.company.$getCompanyQuestions());
        } else if ($scope.company_parent != null && $scope.company_parent.$has('company_questions')) {
            promises.push($scope.company_parent.$getCompanyQuestions());
        } else {
            promises.push($q.when([]));
            $scope.has_company_questions = false;
        }

        // event group promise
        if ($scope.bb.item_defaults && $scope.bb.item_defaults.event_group) {
            $scope.bb.current_item.setEventGroup($scope.bb.item_defaults.event_group);
        } else if (!$scope.bb.current_item.event_group && $scope.bb.company.$has('event_groups')) {
            // --------------------------------------------------------------------------------
            // By default, the API returns the first 100 event_groups. We don't really want
            // to paginate event_groups (athough we DO want to paginate events)
            // so I have hardcoded the EventGroupService query to return all event_groups
            // by passing in a suitably high number for the per_page param
            // ---------------------------------------------------------------------------------
            promises.push(EventGroupService.query($scope.bb.company, { per_page: 500 }));
        } else {
            promises.push($q.when([]));
        }

        // event summary promise
        if ($scope.mode === 0 || $scope.mode === 2) {
            promises.push($scope.loadEventSummary());
        } else {
            promises.push($q.when([]));
        }

        // event data promise
        // TODO - always load some event data?
        if ($scope.mode === 1 || $scope.mode === 2) {
            promises.push($scope.loadEventData());
        } else {
            promises.push($q.when([]));
        }

        return $q.all(promises).then(function (result) {
            var company_questions = result[0];
            var event_groups = result[1];
            //let event_summary = result[2];
            //let event_data = result[3];

            $scope.has_company_questions = company_questions != null && company_questions.length > 0;
            if (company_questions) {
                buildDynamicFilters(company_questions);
            }
            $scope.event_groups = event_groups;

            // Add EventGroup to Event so we don't have to make network requests using item.getGroup() from the view
            var event_groups_collection = _.indexBy(event_groups, 'id');
            if ($scope.items) {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Array.from($scope.items)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var item = _step.value;

                        item.group = event_groups_collection[item.service_id];
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }

            // Remove loading icon
            return loader.setLoaded();
        }, function (err) {
            return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
        });
    };

    /***
     * @ngdoc method
     * @name loadEventSummary
     * @methodOf BB.Directives:bbEvents
     * @description
     * Load event summary
     */
    $scope.loadEventSummary = function () {

        var deferred = $q.defer();
        //let current_event = $scope.bb.current_item.event;

        // de-select the event chain if there's one already picked - as it's hiding other events in the same group
        if ($scope.bb.current_item && ($scope.bb.current_item.event_chain_id || $scope.bb.current_item.event_chain)) {
            delete $scope.bb.current_item.event_chain;
            delete $scope.bb.current_item.event_chain_id;
        }

        var comp = $scope.bb.company;

        var params = {
            item: $scope.bb.current_item,
            start_date: $scope.start_date.toISODate(),
            end_date: $scope.end_date.toISODate()
        };

        if ($scope.bb.item_defaults.event_chain) {
            params.event_chain_id = $scope.bb.item_defaults.event_chain.id;
        }

        BBModel.Event.$summary(comp, params).then(function (items) {

            var item_dates = void 0;
            if (items && items.length > 0) {

                item_dates = [];
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = Array.from(items)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var item = _step2.value;

                        var d = moment(item);
                        item_dates.push({
                            date: d,
                            idate: parseInt(d.format("YYYYDDDD")),
                            count: 1,
                            spaces: 1
                        });
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }

                $scope.item_dates = item_dates.sort(function (a, b) {
                    return a.idate - b.idate;
                });

                // TODO clear the selected date if the event group has changed (but only when event group has been explicity set)
                // if $scope.bb.current_item? and $scope.bb.current_item.event_group?
                //   if $scope.bb.current_item.event_group.id != $scope.event_group_id
                //     $scope.showDay($scope.item_dates[0].date)
                //   $scope.event_group_id = $scope.bb.current_item.event_group.id

                // if the selected date is within range of the dates loaded, show it, else show the first day loaded
                if ($scope.mode === 0) {
                    if ($scope.selected_date && ($scope.selected_date.isAfter($scope.item_dates[0].date) || $scope.selected_date.isSame($scope.item_dates[0].date)) && ($scope.selected_date.isBefore($scope.item_dates[$scope.item_dates.length - 1].date) || $scope.selected_date.isSame($scope.item_dates[$scope.item_dates.length - 1].date))) {
                        $scope.showDay($scope.selected_date);
                    } else {
                        $scope.showDay($scope.item_dates[0].date);
                    }
                }
            }

            return deferred.resolve($scope.item_dates);
        }, function (err) {
            return deferred.reject();
        });

        return deferred.promise;
    };

    /***
     * @ngdoc method
     * @name loadEventChainData
     * @methodOf BB.Directives:bbEvents
     * @description
     * Load event chain data in according of comp parameter
     *
     * @param {array} comp The company
     */
    $scope.loadEventChainData = function (comp) {

        var deferred = $q.defer();

        if ($scope.bb.item_defaults.event_chain) {
            deferred.resolve([]);
        } else {
            loader.notLoaded();
            if (!comp) {
                comp = $scope.bb.company;
            }

            var params = {
                item: $scope.bb.current_item,
                start_date: $scope.start_date.toISODate(),
                end_date: $scope.end_date.toISODate()
            };
            if ($scope.events_options.embed) {
                params.embed = $scope.events_options.embed;
            }
            if ($scope.client) {
                params.member_level_id = $scope.client.member_level_id;
            }

            BBModel.EventChain.$query(comp, params).then(function (event_chains) {
                loader.setLoaded();
                return deferred.resolve(event_chains);
            }, function (err) {
                return deferred.reject();
            });
        }

        return deferred.promise;
    };

    /***
     * @ngdoc method
     * @name loadEventData
     * @methodOf BB.Directives:bbEvents
     * @description
     * Load event data. De-select the event chain if there's one already picked - as it's hiding other events in the same group
     *
     * @param {array} comp The company parameter
     */
    $scope.loadEventData = function (comp) {

        loader.notLoaded();

        $scope.event_data_loaded = false;

        // clear the items when in summary mode
        if ($scope.mode === 0) {
            delete $scope.items;
        }

        var deferred = $q.defer();

        var current_event = $scope.bb.current_item.event;

        if (!comp) {
            comp = $scope.bb.company;
        }

        // de-select the event chain if there's one already picked - as it's hiding other events in the same group
        if ($scope.bb.current_item && ($scope.bb.current_item.event_chain_id || $scope.bb.current_item.event_chain)) {
            delete $scope.bb.current_item.event_chain;
            delete $scope.bb.current_item.event_chain_id;
        }

        var params = {
            item: $scope.bb.current_item,
            start_date: $scope.start_date.toISODate(),
            end_date: $scope.end_date.toISODate(),
            include_non_bookable: true
        };

        if ($scope.events_options.event_data_embed) {
            params.embed = $scope.events_options.event_data_embed;
        }

        if ($scope.bb.item_defaults.event_chain) {
            params.event_chain_id = $scope.bb.item_defaults.event_chain.id;
        }

        if ($scope.per_page) {
            params.per_page = $scope.per_page;
        }

        var chains = $scope.loadEventChainData(comp);

        $scope.events = {};

        BBModel.Event.$query(comp, params).then(function (events) {

            // Flatten events array
            $scope.items = _.flatten(events);

            // Add spaces_left prop - so we don't need to use ng-init="spaces_left = getSpacesLeft()" in the html template
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = Array.from($scope.items)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var item = _step3.value;

                    item.spaces_left = item.getSpacesLeft();
                }

                // Add address prop from the company to the item
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }

            if ($scope.bb.company.$has('address')) {

                $scope.bb.company.$getAddress().then(function (address) {
                    return function () {
                        var result = [];
                        var _iteratorNormalCompletion4 = true;
                        var _didIteratorError4 = false;
                        var _iteratorError4 = undefined;

                        try {
                            for (var _iterator4 = Array.from($scope.items)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                                item = _step4.value;

                                result.push(item.address = address);
                            }
                        } catch (err) {
                            _didIteratorError4 = true;
                            _iteratorError4 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion4 && _iterator4.return) {
                                    _iterator4.return();
                                }
                            } finally {
                                if (_didIteratorError4) {
                                    throw _iteratorError4;
                                }
                            }
                        }

                        return result;
                    }();
                });
            }

            // TODO make this behave like the frame timetable
            // get all data then process events
            return chains.then(function () {

                // get more event details
                var _iteratorNormalCompletion5 = true;
                var _didIteratorError5 = false;
                var _iteratorError5 = undefined;

                try {
                    for (var _iterator5 = Array.from($scope.items)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                        item = _step5.value;


                        params = { embed: $scope.events_options.embed };
                        if ($scope.client) {
                            params.member_level_id = $scope.client.member_level_id;
                        }
                        item.prepEvent(params);

                        // check if the current item already has the same event selected
                        if ($scope.mode === 0 && current_event && current_event.self === item.self) {

                            item.select();
                            $scope.event = item;
                        }
                    }

                    // only build item_dates if we're in 'next 100 event' mode
                } catch (err) {
                    _didIteratorError5 = true;
                    _iteratorError5 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion5 && _iterator5.return) {
                            _iterator5.return();
                        }
                    } finally {
                        if (_didIteratorError5) {
                            throw _iteratorError5;
                        }
                    }
                }

                if ($scope.mode === 1) {

                    var idate = void 0;
                    var item_dates = {};

                    if (items.length > 0) {
                        var _iteratorNormalCompletion6 = true;
                        var _didIteratorError6 = false;
                        var _iteratorError6 = undefined;

                        try {

                            for (var _iterator6 = Array.from(items)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                                item = _step6.value;


                                item.getDuration();
                                idate = parseInt(item.date.format("YYYYDDDD"));
                                item.idate = idate;

                                if (!item_dates[idate]) {
                                    item_dates[idate] = { date: item.date, idate: idate, count: 0, spaces: 0 };
                                }

                                item_dates[idate].count += 1;
                                item_dates[idate].spaces += item.num_spaces;
                            }
                        } catch (err) {
                            _didIteratorError6 = true;
                            _iteratorError6 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion6 && _iterator6.return) {
                                    _iterator6.return();
                                }
                            } finally {
                                if (_didIteratorError6) {
                                    throw _iteratorError6;
                                }
                            }
                        }

                        $scope.item_dates = [];

                        for (var x in item_dates) {

                            var y = item_dates[x];
                            $scope.item_dates.push(y);
                        }

                        $scope.item_dates = $scope.item_dates.sort(function (a, b) {
                            return a.idate - b.idate;
                        });
                    } else {

                        idate = parseInt($scope.start_date.format("YYYYDDDD"));
                        $scope.item_dates = [{ date: $scope.start_date, idate: idate, count: 0, spaces: 0 }];
                    }
                }

                // determine if all events are fully booked
                $scope.isFullyBooked();

                $scope.filtered_items = $scope.items;

                // run the filters to ensure any default filters get applied
                $scope.filterChanged();

                // update the paging
                PaginationService.update($scope.pagination, $scope.filtered_items.length);

                loader.setLoaded();
                $scope.event_data_loaded = true;

                return deferred.resolve($scope.items);
            }, function (err) {
                return deferred.reject();
            });
        }, function (err) {
            return deferred.reject();
        });

        return deferred.promise;
    };

    /***
     * @ngdoc method
     * @name isFullyBooked
     * @methodOf BB.Directives:bbEvents
     * @description
     * Verify if the items from event list are be fully booked
     */
    $scope.isFullyBooked = function () {

        var full_events = [];

        var _iteratorNormalCompletion7 = true;
        var _didIteratorError7 = false;
        var _iteratorError7 = undefined;

        try {
            for (var _iterator7 = Array.from($scope.items)[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                var item = _step7.value;


                if (item.num_spaces === item.spaces_booked) {
                    full_events.push(item);
                }
            }
        } catch (err) {
            _didIteratorError7 = true;
            _iteratorError7 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion7 && _iterator7.return) {
                    _iterator7.return();
                }
            } finally {
                if (_didIteratorError7) {
                    throw _iteratorError7;
                }
            }
        }

        if (full_events.length === $scope.items.length) {
            return $scope.fully_booked = true;
        }
    };

    /***
     * @ngdoc method
     * @name showDay
     * @methodOf BB.Directives:bbEvents
     * @description
     * Selects a day or filters events by day selected
     *
     * @param {moment} the day to select or filter by
     */
    $scope.showDay = function (date) {

        var new_date = void 0;
        if (!moment.isMoment(date)) {
            return;
        }

        if ($scope.mode === 0) {

            // unselect the event if it's not on the day being selected
            if ($scope.event && !$scope.selected_date.isSame(date, 'day')) {
                delete $scope.event;
            }
            new_date = date;
            $scope.start_date = moment(date);
            $scope.end_date = moment(date);
            $scope.loadEventData();
        } else {

            if (!$scope.selected_date || !date.isSame($scope.selected_date, 'day')) {
                new_date = date;
            }
        }

        if (new_date) {

            $scope.selected_date = new_date;
            $scope.filters.date = new_date.toDate();
        } else {

            delete $scope.selected_date;
            delete $scope.filters.date;
        }

        return $scope.filterChanged();
    };

    $scope.$watch('pick.date', function (new_val, old_val) {

        if (new_val) {

            $scope.start_date = moment(new_val);
            $scope.end_date = moment(new_val);
            return $scope.loadEventData();
        }
    });

    /***
     * @ngdoc method
     * @name selectItem
     * @methodOf BB.Directives:bbEvents
     * @description
     * Select an item into the current event list in according of item and route parameters
     *
     * @param {array} item The Event or BookableItem to select
     * @param {string=} route A specific route to load
     */
    $scope.selectItem = function (item, route) {

        if ((item.getSpacesLeft() > 0 || !$scope.bb.company.settings.has_waitlists) && !item.hasSpace()) {
            return false;
        }

        loader.notLoaded();

        if ($scope.$parent.$has_page_control) {

            if ($scope.event) {
                $scope.event.unselect();
            }
            $scope.event = item;
            $scope.event.select();
            loader.setLoaded();

            return false;
        } else {

            if ($scope.bb.moving_purchase) {
                var _iteratorNormalCompletion8 = true;
                var _didIteratorError8 = false;
                var _iteratorError8 = undefined;

                try {

                    for (var _iterator8 = Array.from($scope.bb.basket.items)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                        i = _step8.value;

                        i.setEvent(item);
                    }
                } catch (err) {
                    _didIteratorError8 = true;
                    _iteratorError8 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion8 && _iterator8.return) {
                            _iterator8.return();
                        }
                    } finally {
                        if (_didIteratorError8) {
                            throw _iteratorError8;
                        }
                    }
                }
            }

            $scope.bb.current_item.setEvent(item);
            $scope.bb.current_item.ready = false;

            $q.all($scope.bb.current_item.promises).then(function () {
                return $scope.decideNextPage(route);
            }, function (err) {
                return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
            });

            return true;
        }
    };

    /***
     * @ngdoc method
     * @name setReady
     * @methodOf BB.Directives:bbEvents
     * @description
     * Set this page section as ready - see {@link BB.Directives:bbPage Page Control}
     */
    $scope.setReady = function () {

        if (!$scope.event) {
            return false;
        }

        $scope.bb.current_item.setEvent($scope.event);

        return true;
    };

    /***
     * @ngdoc method
     * @name filterEvents
     * @methodOf BB.Directives:bbEvents
     * @description
     * Filter events from the event list in according of item parameter
     *
     * @param {array} item The Event or BookableItem to select
     */
    $scope.filterEvents = function (item) {
        var result = item.bookable && (moment($scope.filters.date).isSame(item.date, 'day') || $scope.filters.date == null) && ($scope.filters.event_group && item.service_id === $scope.filters.event_group.id || $scope.filters.event_group == null) && ($scope.filters.price != null && item.price_range.from <= $scope.filters.price || $scope.filters.price == null) && ($scope.filters.hide_fully_booked_events && item.getSpacesLeft() > 0 || !$scope.filters.hide_fully_booked_events) && $scope.filterEventsWithDynamicFilters(item);

        return result;
    };

    $scope.filterEventsWithDynamicFilters = function (item) {

        if (!$scope.has_company_questions || !$scope.dynamic_filters) {
            return true;
        }

        var result = true;

        var _iteratorNormalCompletion9 = true;
        var _didIteratorError9 = false;
        var _iteratorError9 = undefined;

        try {
            for (var _iterator9 = Array.from($scope.dynamic_filters.question_types)[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                var type = _step9.value;


                var dynamic_filter, filter, name;
                if (type === 'check') {
                    var _iteratorNormalCompletion10 = true;
                    var _didIteratorError10 = false;
                    var _iteratorError10 = undefined;

                    try {

                        for (var _iterator10 = Array.from($scope.dynamic_filters['check'])[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
                            dynamic_filter = _step10.value;


                            name = dynamic_filter.name.parameterise('_');
                            filter = false;

                            if (item.chain && item.chain.extra[name]) {
                                var _iteratorNormalCompletion11 = true;
                                var _didIteratorError11 = false;
                                var _iteratorError11 = undefined;

                                try {

                                    for (var _iterator11 = Array.from(item.chain.extra[name])[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
                                        i = _step11.value;

                                        filter = $scope.dynamic_filters.values[dynamic_filter.name] && i === $scope.dynamic_filters.values[dynamic_filter.name].name || $scope.dynamic_filters.values[dynamic_filter.name] == null;

                                        if (filter) {
                                            break;
                                        }
                                    }
                                } catch (err) {
                                    _didIteratorError11 = true;
                                    _iteratorError11 = err;
                                } finally {
                                    try {
                                        if (!_iteratorNormalCompletion11 && _iterator11.return) {
                                            _iterator11.return();
                                        }
                                    } finally {
                                        if (_didIteratorError11) {
                                            throw _iteratorError11;
                                        }
                                    }
                                }
                            } else if (item.chain.extra[name] === undefined && (_.isEmpty($scope.dynamic_filters.values) || $scope.dynamic_filters.values[dynamic_filter.name] == null)) {

                                filter = true;
                            }

                            result = result && filter;
                        }
                    } catch (err) {
                        _didIteratorError10 = true;
                        _iteratorError10 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion10 && _iterator10.return) {
                                _iterator10.return();
                            }
                        } finally {
                            if (_didIteratorError10) {
                                throw _iteratorError10;
                            }
                        }
                    }
                } else {
                    var _iteratorNormalCompletion12 = true;
                    var _didIteratorError12 = false;
                    var _iteratorError12 = undefined;

                    try {

                        for (var _iterator12 = Array.from($scope.dynamic_filters[type])[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                            dynamic_filter = _step12.value;


                            name = dynamic_filter.name.parameterise('_');
                            filter = $scope.dynamic_filters.values[dynamic_filter.name] && item.chain.extra[name] === $scope.dynamic_filters.values[dynamic_filter.name].name || $scope.dynamic_filters.values[dynamic_filter.name] == null;
                            result = result && filter;
                        }
                    } catch (err) {
                        _didIteratorError12 = true;
                        _iteratorError12 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion12 && _iterator12.return) {
                                _iterator12.return();
                            }
                        } finally {
                            if (_didIteratorError12) {
                                throw _iteratorError12;
                            }
                        }
                    }
                }
            }
        } catch (err) {
            _didIteratorError9 = true;
            _iteratorError9 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion9 && _iterator9.return) {
                    _iterator9.return();
                }
            } finally {
                if (_didIteratorError9) {
                    throw _iteratorError9;
                }
            }
        }

        return result;
    };

    /***
     * @ngdoc method
     * @name filterDateChanged
     * @methodOf BB.Directives:bbEvents
     * @description
     * Filtering data exchanged from the list of events
     */
    $scope.filterDateChanged = function (options) {

        if (options == null) {
            options = { reset: false };
        }
        if ($scope.filters.date) {
            var date = moment($scope.filters.date);
            $scope.$broadcast("event_list_filter_date:changed", date);
            $scope.showDay(date);

            if (options.reset === true || $scope.selected_date == null) {

                return $timeout(function () {
                    return delete $scope.filters.date;
                }, 250);
            }
        }
    };

    /***
     * @ngdoc method
     * @name resetFilters
     * @methodOf BB.Directives:bbEvents
     * @description
     * Reset the filters
     */
    $scope.resetFilters = function () {

        $scope.filters = {};
        if ($scope.has_company_questions) {
            $scope.dynamic_filters.values = {};
        }
        $scope.filterChanged();

        delete $scope.selected_date;
        return $rootScope.$broadcast("event_list_filter_date:cleared");
    };

    // build dynamic filters using company questions
    var buildDynamicFilters = function buildDynamicFilters(questions) {

        questions = _.each(questions, function (question) {
            return question.name = $filter('wordCharactersAndSpaces')(question.name);
        });

        $scope.dynamic_filters = _.groupBy(questions, 'question_type');
        $scope.dynamic_filters.question_types = _.uniq(_.pluck(questions, 'question_type'));
        return $scope.dynamic_filters.values = {};
    };

    // TODO build price filter by determiniug price range, if range is large enough, display price filter
    // buildPriceFilter = () ->
    //   for item in items


    // TODO allow sorting by price/date (default)


    /***
     * @ngdoc method
     * @name filterChanged
     * @methodOf BB.Directives:bbEvents
     * @description
     * Change filter of the event list
     */
    $scope.filterChanged = function () {

        if ($scope.items) {

            $scope.filtered_items = $filter('filter')($scope.items, $scope.filterEvents);
            $scope.pagination.num_items = $scope.filtered_items.length;
            $scope.filter_active = $scope.filtered_items.length !== $scope.items.length;
            return PaginationService.update($scope.pagination, $scope.filtered_items.length);
        }
    };

    /***
     * @ngdoc method
     * @name pageChanged
     * @methodOf BB.Directives:bbEvents
     * @description
     * Change page of the event list
     */
    return $scope.pageChanged = function () {

        PaginationService.update($scope.pagination, $scope.filtered_items.length);
        return $rootScope.$broadcast("page:changed");
    };
});

// TODO load more events when end of initial collection is reached/next collection is requested/data is loaded when no event data is present
// $scope.$on 'month_picker:month_changed', (event, month, last_month_shown) ->
//   return if !$scope.items or $scope.mode is 0
//   last_event = _.last($scope.items).date
//   # if the last event is in the same month as the last one shown, get more events
//   if last_month_shown.start_date.isSame(last_event, 'month')
//     $scope.start_date = last_month_shown.start_date
//     $scope.loadEventData()
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbEvents
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Loads a list of events for the currently in scope company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @param {hash}  bbEvents A hash of options
 * @property {integer} total_entries The event total entries
 * @property {array} events The events array
 * @property {boolean} hide_fully_booked_events Hide fully booked events (i.e. events with only waitlist spaces left). Default is false.
 */ //
angular.module('BB.Directives').directive('bbEvents', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'EventList',

        link: function link(scope, element, attrs) {

            scope.summary = attrs.summary != null;
            scope.events_options = scope.$eval(attrs.bbEvents) || {};

            // set the mode
            // 0 = Event summary (gets year summary and loads events a day at a time)
            // 1 = Next 100 events (gets next 100 events)
            // 2 = Next 100 events and event summary (gets event summary, loads next 100 events, and gets more events if requested)
            scope.mode = scope.events_options && scope.events_options.mode ? scope.events_options.mode : 0;
            if (scope.summary) {
                scope.mode = 0;
            }

            // set the total number of events loaded?
            if (scope.events_options && scope.events_options.per_page) {
                scope.per_page = scope.events_options.per_page;
            }
        }
    };
});
'use strict';

(function () {

    angular.module('BB.Controllers').controller('ItemDetails', itemDetailsController);

    function itemDetailsController($scope, $attrs, $rootScope, PurchaseBookingService, AlertService, BBModel, FormDataStoreService, ValidatorService, $uibModal, $document, $translate, $filter, GeneralOptions, PurchaseService, LoadingService, bbTimeZone) {
        'ngInject';

        var loader = LoadingService.$loader($scope);

        $scope.suppress_basket_update = $attrs.bbSuppressBasketUpdate != null;
        $scope.item_details_id = $scope.$eval($attrs.bbSuppressBasketUpdate);

        // if instructed to suppress basket updates (i.e. when the directive is invoked multiple times
        // on the same page), create a form store for each instance of the directive
        if ($scope.suppress_basket_update) {
            FormDataStoreService.init('ItemDetails' + $scope.item_details_id, $scope, ['item_details']);
        } else {
            FormDataStoreService.init('ItemDetails', $scope, ['item_details']);
        }

        // populate object with values stored in the question store. addAnswersByName()
        // is good for populating a single object. for dynamic question/answers see
        // addDynamicAnswersByName()
        BBModel.Question.$addAnswersByName($scope.client, ['first_name', 'last_name', 'email', 'mobile']);

        console.warn('Deprecation warning: validator.validateForm() will be removed from bbItemDetails in an upcoming major release, please update your template to use bbForm and submitForm() instead. See https://github.com/bookingbug/bookingbug-angular/issues/638');
        $scope.validator = ValidatorService;

        var confirming = false;

        $rootScope.connection_started.then(function () {
            if (!confirming) {
                return $scope.loadItem($scope.bb.current_item);
            }
        }, function (err) {
            return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
        });

        /***
         * @ngdoc method
         * @name loadItem
         * @methodOf BB.Directives:bbItemDetails
         * @description
         * Load item in according of item parameter
         *
         * @param {array} item The item loaded
         */
        $scope.loadItem = function (item) {

            loader.notLoaded();

            confirming = true;
            $scope.item = item;
            if ($scope.bb.private_note) {
                $scope.item.private_note = $scope.bb.private_note;
            }
            $scope.product = item.product;

            if ($scope.item.item_details) {
                setItemDetails($scope.item.item_details);
                // this will add any values in the querystring
                BBModel.Question.$addDynamicAnswersByName($scope.item_details.questions);
                if ($scope.bb.item_defaults.answers) {
                    BBModel.Question.$addAnswersFromDefaults($scope.item_details.questions, $scope.bb.item_defaults.answers);
                }
                $scope.recalc_price();
                loader.setLoaded();
                return $scope.$emit("item_details:loaded", $scope.item_details);
            } else {

                var params = { company: $scope.bb.company, cItem: $scope.item };
                return BBModel.ItemDetails.$query(params).then(function (details) {
                    if (details) {
                        setItemDetails(details);
                        $scope.item.item_details = $scope.item_details;
                        BBModel.Question.$addDynamicAnswersByName($scope.item_details.questions);
                        if ($scope.bb.item_defaults.answers) {
                            BBModel.Question.$addAnswersFromDefaults($scope.item_details.questions, $scope.bb.item_defaults.answers);
                        }
                        $scope.recalc_price();
                        $scope.$emit("item_details:loaded", $scope.item_details);
                    }
                    return loader.setLoaded();
                }, function (err) {
                    return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
                });
            }
        };

        /***
         * @ngdoc method
         * @name setItemDetails
         * @methodOf BB.Directives:bbItemDetails
         * @description
         * Set item details in according of details parameter
         *
         * @param {array} details The details parameter
         */
        // compare the questions stored in the data store to the new questions and if
        // any of them match then copy the answer value. we're doing it like this as
        // the amount of questions can change based on selections made earlier in the
        // journey, so we can't just store the questions.
        var setItemDetails = function setItemDetails(details) {
            if ($scope.item && $scope.item.defaults) {
                _.each(details.questions, function (item) {
                    var n = 'q_' + item.name;
                    if ($scope.item.defaults[n]) {
                        return item.answer = $scope.item.defaults[n];
                    }
                });
            }

            if ($scope.hasOwnProperty('item_details')) {
                var oldQuestions = $scope.item_details.questions;

                _.each(details.questions, function (item) {
                    var search = _.findWhere(oldQuestions, { name: item.name });
                    if (search) {
                        return item.answer = search.answer;
                    }
                });
            }
            return $scope.item_details = details;
        };

        // TODO document listener
        $scope.$on('currentItemUpdate', function (event) {
            if ($scope.item_from_param) {
                return $scope.loadItem($scope.item_from_param);
            } else {
                return $scope.loadItem($scope.bb.current_item);
            }
        });

        /***
         * @ngdoc method
         * @name recalc_price
         * @methodOf BB.Directives:bbItemDetails
         * @description
         * Recalculate item price in function of quantity
         */
        $scope.recalc_price = function () {
            var qprice = $scope.item_details.questionPrice($scope.item.getQty());
            var bprice = $scope.item.base_price;
            if (!bprice) {
                bprice = $scope.item.price;
            }

            $scope.item.setPrice(qprice + bprice);

            // set the asked_questions bool in the BasketItem model so that its getPostData method sends question data to the API
            return $scope.item.setAskedQuestions();
        };

        /***
         * @ngdoc method
         * @name confirm
         * @methodOf BB.Directives:bbItemDetails
         * @description
         * Confirm the question
         *
         * @param {object} form The form where question are introduced
         * @param {string=} route A specific route to load
         */
        $scope.confirm = function (form, route) {
            if (!ValidatorService.validateForm(form)) {
                return;
            }
            // we need to validate the question information has been correctly entered here
            if ($scope.bb.moving_booking) {
                return $scope.confirm_move(form, route);
            }

            $scope.item.setAskedQuestions();

            if ($scope.$parent.$has_page_control) {
                return true;
            }

            if ($scope.item.ready) {
                loader.notLoaded();
                return $scope.addItemToBasket().then(function () {
                    loader.setLoaded();
                    return $scope.decideNextPage(route);
                }, function (err) {
                    return loader.setLoaded();
                });
            } else {
                return $scope.decideNextPage(route);
            }
        };

        /***
         * @ngdoc method
         * @name setReady
         * @methodOf BB.Directives:bbItemDetails
         * @description
         * Set this page section as ready - see {@link BB.Directives:bbPage Page Control}
         */
        $scope.setReady = function () {
            $scope.item.setAskedQuestions();
            if ($scope.item.ready && !$scope.suppress_basket_update) {
                return $scope.addItemToBasket();
            } else {
                return true;
            }
        };

        /***
         * @ngdoc method
         * @name openTermsAndConditions
         * @methodOf BB.Directives:bbItemDetails
         * @description
         * Display terms and conditions view
         */
        $scope.openTermsAndConditions = function () {
            return $uibModal.open({
                templateUrl: $scope.getPartial("terms_and_conditions"),
                scope: $scope
            });
        };

        /***
         * @ngdoc method
         * @name getQuestion
         * @methodOf BB.Directives:bbItemDetails
         * @description
         * Get question by id
         *
         * @param {integer} id The id of the question
         */
        $scope.getQuestion = function (id) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = Array.from($scope.item_details.questions)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var question = _step.value;

                    if (question.id === id) {
                        return question;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return null;
        };

        /***
         * @ngdoc method
         * @name updateItem
         * @methodOf BB.Directives:bbItemDetails
         * @description
         * Update item
         */
        $scope.updateItem = function () {
            $scope.item.setAskedQuestions();
            if ($scope.item.ready) {
                loader.notLoaded();
                return PurchaseBookingService.update($scope.item).then(function (booking) {
                    var b = new BBModel.Purchase.Booking(booking);
                    if ($scope.bookings) {
                        for (var _i = 0; _i < $scope.bookings.length; _i++) {
                            var oldb = $scope.bookings[_i];
                            if (oldb.id === b.id) {
                                $scope.bookings[_i] = b;
                            }
                        }
                    }
                    $scope.purchase.bookings = $scope.bookings;
                    $scope.item_details_updated = true;
                    return loader.setLoaded();
                }, function (err) {
                    $log.info(err);
                    return loader.setLoaded();
                });
            }
        };

        /***
         * @ngdoc method
         * @name editItem
         * @methodOf BB.Directives:bbItemDetails
         * @description
         * Edit item
         */
        return $scope.editItem = function () {
            return $scope.item_details_updated = false;
        };
    }
})();
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbItemDetails
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Loads a list of item details for the currently in scope company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @property {array} item An array of all item details
 * @property {array} product The product
 * @property {array} booking The booking
 * @property {array} upload_progress The item upload progress
 * @property {object} validator The validator service - see {@link BB.Services:Validator Validator Service}
 * @property {object} alert The alert service - see {@link BB.Services:Alert Alert Service}
 */

angular.module('BB.Directives').directive('bbItemDetails', function ($q, $templateCache, $compile) {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        transclude: true,
        controller: 'ItemDetails',
        link: function link(scope, element, attrs, controller, transclude) {
            if (attrs.bbItemDetails) {
                var item = scope.$eval(attrs.bbItemDetails);
                scope.item_from_param = item;
                if (scope.item_details) {
                    delete scope.item_details;
                }
                if (item) {
                    scope.loadItem(item);
                }
            }

            return transclude(scope, function (clone) {
                // if there's content compile that or grab the week_calendar template
                var has_content = clone.length > 1 || clone.length === 1 && (!clone[0].wholeText || /\S/.test(clone[0].wholeText));
                if (has_content) {
                    return element.html(clone).show();
                } else {
                    return $q.when($templateCache.get('_item_details.html')).then(function (template) {
                        element.html(template).show();
                        return $compile(element.contents())(scope);
                    });
                }
            });
        }
    };
});
'use strict';

angular.module('BB.Controllers').controller('Login', function ($scope, $rootScope, $q, $location, LoginService, ValidatorService, AlertService, LoadingService, BBModel) {

    console.warn('Deprecation warning: validator.validateForm() will be removed from bbLogin in an upcoming major release, please update your template to use bbForm and submitForm() instead. See https://github.com/bookingbug/bookingbug-angular/issues/638');
    $scope.validator = ValidatorService;

    $scope.login_form = {};

    var loader = LoadingService.$loader($scope);

    /***
     * @ngdoc method
     * @name login_sso
     * @methodOf BB.Directives:bbLogin
     * @description
     * Login to application
     *
     * @param {object} token The token to use for login
     * @param {string=} route A specific route to load
     */
    $scope.login_sso = function (token, route) {
        return $rootScope.connection_started.then(function () {
            return LoginService.ssoLogin({
                company_id: $scope.bb.company.id,
                root: $scope.bb.api_url
            }, { token: token }).then(function (member) {
                if (route) {
                    return $scope.showPage(route);
                }
            }, function (err) {
                return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
            });
        }, function (err) {
            return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
        });
    };

    /***
     * @ngdoc method
     * @name login_with_password
     * @methodOf BB.Directives:bbLogin
     * @description
     * Login with password
     *
     * @param {string} email The email address that use for the login
     * @param {string} password The password use for the login
     */
    $scope.login_with_password = function (email, password) {
        return LoginService.companyLogin($scope.bb.company, {}, { email: email, password: password }).then(function (member) {
            return $scope.member = new BBModel.Member.Member(member);
        }, function (err) {
            return AlertService.raise('LOGIN_FAILED');
        });
    };

    /***
     * @ngdoc method
     * @name showEmailPasswordReset
     * @methodOf BB.Directives:bbLogin
     * @description
     * Display email reset password page
     */
    $scope.showEmailPasswordReset = function () {
        return $scope.showPage('email_reset_password');
    };

    /***
     * @ngdoc method
     * @name isLoggedIn
     * @methodOf BB.Directives:bbLogin
     * @description
     * Verify if user are logged in
     */
    $scope.isLoggedIn = function () {
        return LoginService.isLoggedIn();
    };

    /***
     * @ngdoc method
     * @name sendPasswordReset
     * @methodOf BB.Directives:bbLogin
     * @description
     * Send password reset via email
     *
     * @param {string} email The email address use for the send new password
     */
    $scope.sendPasswordReset = function (email) {
        return LoginService.sendPasswordReset($scope.bb.company, {
            email: email,
            custom: true
        }).then(function () {
            return AlertService.raise('PASSWORD_RESET_REQ_SUCCESS');
        }, function (err) {
            return AlertService.raise('PASSWORD_RESET_REQ_FAILED');
        });
    };

    /***
     * @ngdoc method
     * @name updatePassword
     * @methodOf BB.Directives:bbLogin
     * @description
     * Update password
     *
     * @param {string} new_password The new password has been set
     * @param {string} confirm_new_password The new password has been confirmed
     */
    return $scope.updatePassword = function (new_password, confirm_new_password) {
        AlertService.clear();
        if ($rootScope.member && new_password && confirm_new_password && new_password === confirm_new_password) {
            return LoginService.updatePassword($rootScope.member, {
                new_password: new_password,
                confirm_new_password: confirm_new_password,
                persist_login: $scope.login_form.persist_login
            }).then(function (member) {
                if (member) {
                    $scope.setClient(member);
                    $scope.password_updated = true;
                    return AlertService.raise('PASSWORD_RESET_SUCESS');
                }
            }, function (err) {
                $scope.error = err;
                return AlertService.raise('PASSWORD_RESET_FAILED');
            });
        } else {
            return AlertService.raise('PASSWORD_MISMATCH');
        }
    };
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbLogin
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Loads a list of logins for the currently in scope company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @property {boolean} password_updated The user password updated
 * @property {boolean} password_error The user password error
 * @property {boolean} email_sent The email sent
 * @property {boolean} success If user are log in with success
 * @property {boolean} login_error If user have some errors when try to log in
 * @property {object} validator The validator service - see {@link BB.Services:Validator Validator Service}
 */ //


angular.module('BB.Directives').directive('bbLogin', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'Login'
    };
});
'use strict';

(function (angular) {

    angular.module('BB.Controllers').controller('MapCtrl', MapCtrl);

    function MapCtrl($scope, $attrs, $rootScope, AlertService, FormDataStoreService, LoadingService, $q, $window, $timeout, ErrorService, $log, GeolocationService, GeneralOptions, bbAnalyticsPiwik, bbWidgetInit) {

        /*
         *  Retrieve the value passed to the layout attribute
         *  and populate an object which expose the layout type
         *
         *  Passing "radio" means that layout.radio is true, etc...
         *
         *  If no value is passed, the layout.default is set to true
         */
        $scope.layout = {};

        var layout = GeneralOptions.map_layout === 'default' ? 'default' : GeneralOptions.map_layout;
        $scope.layout[layout] = true;

        /*
         * window.isSecureContext might be not supported in some browsers.
         * Set its value checking if the iFrame parent url starts with https
         */
        var isSecureContext = window.isSecureContext;

        if (isSecureContext === undefined) {
            var url = window.location !== window.parent.location ? document.referrer : document.location.href;
            isSecureContext = /^https:\/\//.test(url);
        }

        // Use this value to hide or show the geolocate button, for example
        $scope.geolocation_enabled = isSecureContext;

        FormDataStoreService.init('MapCtrl', $scope, ['address', 'selectedStore', 'search_prms']);

        // init vars
        $scope.options = $scope.$eval($attrs.bbMap) || {};

        // when set to true, selectItem() does not call decideNextPage() when calling $scope.initWidget()
        $scope.no_route = $scope.options.no_route || false;

        $scope.num_search_results = $scope.options.num_search_results || 6;
        $scope.range_limit = $scope.options.range_limit || Infinity;
        $scope.hide_not_live_stores = $scope.options.hide_not_live_stores || false;
        $scope.can_filter_by_service = $scope.options.filter_by_service || false; // If set to true then the checkbox toggle for showing stores with/without the selected service will be shown in the template
        $scope.filter_by_service = $scope.options.filter_by_service || false; // The aforementioned checkbox is bound to this value which can be true or false depending on checked state, hence why we cannot use filter_by_service to show/hide the checkbox
        $scope.default_zoom = $scope.options.default_zoom || 6;

        // custom map marker icon can be set using GeneralOptions
        var defaultPin = GeneralOptions.map_marker_icon;
        var activePin = GeneralOptions.mapActiveMarkerIcon;
        var pinHasLabel = GeneralOptions.mapMarkerHasLabel;

        // when set to false, geolocate() only fills the input with the returned address and does not load the map
        $scope.loadMapOnGeolocate = true;

        var map_ready_def = $q.defer();
        $scope.mapLoaded = $q.defer();
        $scope.mapReady = map_ready_def.promise;
        $scope.map_init = $scope.mapLoaded.promise;
        $scope.showAllMarkers = false;
        $scope.mapMarkers = [];
        $scope.shownMarkers = $scope.shownMarkers || [];
        if (!$scope.numberedPin) {
            $scope.numberedPin = null;
        }
        if (!$scope.address && $attrs.bbAddress) {
            $scope.address = $scope.$eval($attrs.bbAddress);
        }

        var loader = LoadingService.$loader($scope);

        // setup geolocation shim
        webshim.setOptions({
            'waitReady': false,
            'loadStyles': false
        });
        webshim.polyfill("geolocation");

        $rootScope.connection_started.then(function () {
            return $scope.initialise();
        }, function (err) {
            return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
        });

        /***
         * @ngdoc method
         * @name initialise
         * @methodOf BB.Directives:bbMap
         * @description
         * Initialise the google map
         *
         */
        $scope.initialise = function () {

            $scope.mapMarkers = [];
            $scope.shownMarkers = $scope.shownMarkers || [];

            if (!$scope.selectedStore) {
                loader.setLoaded();
            }

            if ($scope.bb.company.companies) {
                $rootScope.parent_id = $scope.bb.company.id;
            } else if ($rootScope.parent_id) {
                bbWidgetInit.initWidget({
                    company_id: $rootScope.parent_id,
                    first_page: $scope.bb.current_page,
                    keep_basket: true,
                    item_defaults: $scope.bb.item_defaults ? $scope.bb.item_defaults : {}
                });
                return;
            } else {
                bbWidgetInit.initWidget({
                    company_id: $scope.bb.company.id,
                    first_page: null
                });
                return;
            }

            $scope.companies = $scope.bb.company.companies;
            if (!$scope.companies || $scope.companies.length === 0) {
                $scope.companies = [$scope.bb.company];
            }

            if ($scope.bb.current_item.service && $scope.options && $scope.options.filter_by_service) {
                loader.notLoaded($scope);

                $scope.filterByServicePromise().then(function () {
                    return $scope.map_init.then(function () {
                        return mapInit();
                    });
                });
            } else {
                $scope.map_init.then(function () {
                    return mapInit();
                });
            }

            $scope.mapBounds = new google.maps.LatLngBounds();
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = Array.from($scope.companies)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var comp = _step.value;

                    if (comp.address && comp.address.lat && comp.address.long) {
                        var latlong = new google.maps.LatLng(comp.address.lat, comp.address.long);
                        $scope.mapBounds.extend(latlong);
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            $scope.mapOptions = {
                center: $scope.mapBounds.getCenter(),
                zoom: $scope.default_zoom,
                mapTypeId: google.maps.MapTypeId.ROADMAP,
                mapTypeControl: true,
                mapTypeControlOptions: {
                    style: window.google.maps.MapTypeControlStyle.DROPDOWN_MENU
                }
            };

            if ($scope.options && $scope.options.map_options) {
                for (var key in $scope.options.map_options) {
                    var value = $scope.options.map_options[key];
                    $scope.mapOptions[key] = value;
                }
            }

            return map_ready_def.resolve(true);
        };

        /***
         * @ngdoc method
         * @name $scope.filterByServicePromise
         * @methodOf BB.Directives:bbMap
         * @description
         * Set the has_service property and the service object on all companies
         * so companies can be filtered by service
         */
        $scope.filterByServicePromise = function () {
            var deferred = $q.defer();
            if ($scope.bb.selected_service.$has('all_children')) {
                $scope.bb.selected_service.$get('all_children').then(function (resource) {
                    return resource.$get('services').then(function (services) {
                        var service = void 0;
                        var company_ids = _.map(services, function (service) {
                            return service.company_id;
                        });

                        return Array.from($scope.companies).map(function (company) {
                            return company.has_service = _.contains(company_ids, company.id), service = _.find(services, function (service) {
                                return service.company_id === company.id;
                            }), company.service = service, deferred.resolve();
                        });
                    });
                });
            } else {
                deferred.resolve();
            }
            return deferred.promise;
        };

        /***
         * @ngdoc method
         * @name $scope.filterByService
         * @methodOf BB.Directives:bbMap
         * @description
         * Set $scope.shownMarkers to include / exclude
         * companies without the selected service
         */
        $scope.filterByService = function () {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {

                for (var _iterator2 = Array.from($scope.shownMarkers)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var marker = _step2.value;

                    marker.setMap(null);
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            if ($scope.options && $scope.filter_by_service) {
                $scope.shownMarkers = $scope.shown_markers_with_services;
            } else {
                $scope.shownMarkers = $scope.shown_markers;
            }

            return $timeout(function () {
                return setMarkers();
            });
        };

        var mapInit = function mapInit() {
            // iterate over companies tracking by index
            Array.from($scope.companies).map(function (comp, index) {
                if (comp.address && comp.address.lat && comp.address.long) {
                    var latlong = new google.maps.LatLng(comp.address.lat, comp.address.long);
                    var marker = new google.maps.Marker({
                        map: $scope.myMap,
                        position: latlong,
                        visible: $scope.showAllMarkers,
                        icon: defaultPin
                    });

                    // assign a label to the pin in order to easily match with the list
                    if (pinHasLabel) {
                        marker.setLabel((index + 1).toString());
                    }

                    marker.company = comp;
                    if (!$scope.hide_not_live_stores || !!comp.live) {
                        $scope.mapMarkers.push(marker);
                    }
                }
            });

            $timeout(function () {
                $scope.myMap.fitBounds($scope.mapBounds);
                if ($scope.options.default_zoom) {
                    $scope.myMap.setZoom($scope.default_zoom);
                }
                if ($scope.bb.current_item.service && $scope.options && $scope.filter_by_service) {
                    return loader.setLoaded();
                }
            });
            return checkDataStore();
        };

        /***
         * @ngdoc method
         * @name loadMap
         * @methodOf BB.Directives:bbMap
         * @description
         * Set the center, zoom and show the closest markers on the Map
         *
         */
        var loadMap = function loadMap() {
            $scope.myMap.setCenter($scope.loc);
            if ($scope.options.default_zoom) {
                $scope.myMap.setZoom($scope.default_zoom);
            }
            $scope.showClosestMarkers($scope.loc);
            return;
        };

        /***
         * @ngdoc method
         * @name checkDataStore
         * @methodOf BB.Directives:bbMap
         * @description
         * If the user has clicked back to the map then display it.
         */
        var checkDataStore = function checkDataStore() {
            if ($scope.selectedStore) {
                loader.notLoaded();
                if ($scope.search_prms) {
                    $scope.searchAddress($scope.search_prms);
                } else {
                    $scope.geolocate();
                }
                return google.maps.event.addListenerOnce($scope.myMap, 'idle', function () {
                    return _.each($scope.mapMarkers, function (marker) {
                        if ($scope.selectedStore.id === marker.company.id) {
                            return google.maps.event.trigger(marker, 'click');
                        }
                    });
                });
            }
        };

        /***
         * @ngdoc method
         * @name title
         * @methodOf BB.Directives:bbMap
         * @description
         * Create title for the map selection step
         */
        $scope.title = function () {
            var p1 = void 0;
            var ci = $scope.bb.current_item;
            if (ci.category && ci.category.description) {
                p1 = ci.category.description;
            } else {
                p1 = $scope.bb.company.extra.department;
            }

            return p1 + ' - ' + $scope.$eval('getCurrentStepTitle()');
        };

        function setPiwik(title) {
            var category = "Map";
            bbAnalyticsPiwik.push(['trackEvent', [category], title]);
        }

        /***
         * @ngdoc method
         * @name searchAddress
         * @methodOf BB.Directives:bbMap
         * @description
         * Search address in according of prms parameter
         *
         * @param {object} prms The parameters of the address
         */
        $scope.searchAddress = function () {
            var prms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};


            if (bbAnalyticsPiwik.isEnabled()) setPiwik('Search');

            // if a reverse geocode has been performed and the address
            // is no different to one the entered, abort the search
            if ($scope.loadMapOnGeolocate && $scope.reverse_geocode_address && $scope.reverse_geocode_address === $scope.address) {
                return false;
            }

            if (angular.isDefined(prms.address)) {
                $scope.address = prms.address;
            }

            // a condition for the empty sent address value which was causing non-stopping spinner
            // the previous condition isn't editted for the purpose of the application wide possible side-effects
            if ($scope.loadMapOnGeolocate && (!$scope.address || angular.isString($scope.address) && !$scope.address.trim())) {
                AlertService.clear();
                AlertService.raise('MISSING_LOCATION');
                return false;
            }

            /*
             * the previous condition seems to break map rendering on some clients implementations (i.e. COS),
             * so this one only prevents searches for empty criteria
             */
            if ($scope.address !== undefined && $scope.address.trim() === '') {
                return false;
            }

            loader.notLoaded();

            $scope.loadMapOnGeolocate = true;

            delete $scope.geocoder_result;

            $scope.search_prms = prms;
            $scope.map_init.then(function () {
                var address = $scope.address;

                if (prms.address) {
                    address = prms.address;
                }

                if (address) {
                    var req = {
                        address: address
                    };
                    if (prms.region) {
                        req.region = prms.region;
                    }
                    if (prms.componentRestrictions) {
                        req.componentRestrictions = prms.componentRestrictions;
                    }

                    if (prms.bounds) {
                        var sw = new google.maps.LatLng(prms.bounds.sw.x, prms.bounds.sw.y);
                        var ne = new google.maps.LatLng(prms.bounds.ne.x, prms.bounds.ne.y);
                        req.bounds = new google.maps.LatLngBounds(sw, ne);
                    }

                    return new google.maps.Geocoder().geocode(req, function (results, status) {

                        if (results.length > 0 && status === 'OK') {
                            $scope.geocoder_result = results[0];
                        }

                        if (!$scope.geocoder_result || $scope.geocoder_result && $scope.geocoder_result.partial_match) {
                            searchPlaces(req);
                        } else if ($scope.geocoder_result) {
                            searchSuccess($scope.geocoder_result);
                        } else {
                            searchFailed();
                        }
                        loader.setLoaded();
                    });
                }
            });

            return;
        };

        /***
         * @ngdoc method
         * @name searchPlaces
         * @methodOf BB.Directives:bbMap
         * @description
         * Search places in according of prms parameter
         *
         * @param {object} prms The parameters of the places
         */
        var searchPlaces = function searchPlaces(prms) {

            var req = {
                query: prms.address,
                types: ['shopping_mall', 'store', 'embassy'] // narrow place types to improve results
            };

            if (prms.bounds) {
                req.bounds = prms.bounds;
            }

            var service = new google.maps.places.PlacesService($scope.myMap);
            return service.textSearch(req, function (results, status) {
                if (results.length > 0 && status === 'OK') {
                    searchSuccess(results[0]);
                } else if ($scope.geocoder_result) {
                    searchSuccess($scope.geocoder_result);
                } else {
                    searchFailed();
                }
                return;
            });
        };

        /***
         * @ngdoc method
         * @name searchSuccess
         * @methodOf BB.Directives:bbMap
         * @description
         * Search has been succeeded, and return
         *
         * @param {object} result The result of the search
         */
        var searchSuccess = function searchSuccess(result) {
            AlertService.clear();
            $scope.search_failed = false;
            $scope.loc = result.geometry.location;
            $scope.formatted_address = result.formatted_address;
            if ($scope.loadMapOnGeolocate) {
                loadMap();
            }
            return $rootScope.$broadcast("map:search_success");
        };

        /***
         * @ngdoc method
         * @name searchFailed
         * @methodOf BB.Directives:bbMap
         * @description
         * Search failed and displayed an error
         */
        var searchFailed = function searchFailed() {
            $scope.search_failed = true;
            AlertService.raise('LOCATION_NOT_FOUND');
            // need to call apply to update bindings as geocode callback is outside angular library
            return $rootScope.$apply();
        };

        /***
         * @ngdoc method
         * @name validateAddress
         * @methodOf BB.Directives:bbMap
         * @description
         * Validate the address using form
         *
         * @param {object} form The form where address has been validate
         */
        $scope.validateAddress = function (form) {
            if (!form) {
                return false;
            }
            if (form.$error.required) {
                AlertService.clear();
                AlertService.raise('MISSING_LOCATION');
                return false;
            } else {
                return true;
            }
        };

        /***
         * @ngdoc method
         * @name showClosestMarkers
         * @methodOf BB.Directives:bbMap
         * @description
         * Display the closest markers
         *
         * @param {Object} centre The map centre
         */
        $scope.showClosestMarkers = function (centre) {

            var distances = [];
            var distances_with_services = [];

            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = Array.from($scope.mapMarkers)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var marker = _step3.value;


                    var map_centre = {
                        lat: centre.lat(),
                        long: centre.lng()
                    };

                    var marker_position = {
                        lat: marker.position.lat(),
                        long: marker.position.lng()
                    };

                    marker.distance = GeolocationService.haversine(map_centre, marker_position);

                    if (!$scope.showAllMarkers) {
                        marker.setVisible(false);
                    }

                    if (marker.distance < $scope.range_limit) {
                        distances.push(marker);
                        if (marker.company.has_service) {
                            distances_with_services.push(marker);
                        }
                    }
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }

            distances.sort(function (a, b) {
                return a.distance - b.distance;
            });

            distances_with_services.sort(function (a, b) {
                return a.distance - b.distance;
            });

            $scope.setShownMarkers(distances, distances_with_services);

            if ($scope.shownMarkers.length != 0) {
                $timeout(function () {
                    return setMarkers();
                });
            }
            return;
        };

        /***
         * @ngdoc method
         * @name setShownMarkers
         * @methodOf BB.Directives:bbMap
         * @description
         * Set the shownMarkers on scope
         *
         * @param {array} distances Markers with property distance
         * @param {array} distances_with_services Markers with property distance and support the pre-selected service
         */
        $scope.setShownMarkers = function (distances, distances_with_services) {
            $scope.shown_markers = distances.slice(0, $scope.num_search_results);
            $scope.shown_markers_with_services = distances_with_services.slice(0, $scope.num_search_results);

            if ($scope.options && $scope.filter_by_service && $scope.shown_markers_with_services.length != 0) {
                $scope.shownMarkers = $scope.shown_markers_with_services;
            } else {
                $scope.shownMarkers = $scope.shown_markers;
            }
        };

        var setMarkers = function setMarkers() {

            var latlong = $scope.loc;

            var localBounds = new google.maps.LatLngBounds();
            localBounds.extend(latlong);
            var index = 1;

            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
                for (var _iterator4 = Array.from($scope.shownMarkers)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                    var marker = _step4.value;

                    if ($scope.numberedPin) {
                        var iconPath = $window.sprintf($scope.numberedPin, index);
                        marker.setIcon(iconPath);
                    }

                    marker.setVisible(true);
                    marker.setMap($scope.myMap);
                    localBounds.extend(marker.position);
                    index += 1;
                }
            } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion4 && _iterator4.return) {
                        _iterator4.return();
                    }
                } finally {
                    if (_didIteratorError4) {
                        throw _iteratorError4;
                    }
                }
            }

            $scope.$emit('map:shown_markers_updated', $scope.shownMarkers);

            google.maps.event.trigger($scope.myMap, 'resize');
            $scope.myMap.fitBounds(localBounds);
            return openDefaultMarker();
        };

        var openDefaultMarker = function openDefaultMarker() {

            if ($scope.options && $scope.options.no_default_location_details) {
                return;
            }

            var open_marker_index = 0;
            var open_marker = _.find($scope.shownMarkers, function (obj) {
                open_marker_index++;
                return obj.company.id === $scope.bb.current_item.company.id;
            });
            if (open_marker) {
                open_marker_index--;
            } else {
                open_marker_index = 0;
            }
            $scope.shownMarkers[open_marker_index].is_open = true;
            return $scope.openMarkerInfo($scope.shownMarkers[open_marker_index]);
        };

        /***
         * @ngdoc method
         * @name openMarkerInfo
         * @methodOf BB.Directives:bbMap
         * @description
         * Display marker information on the map
         *
         * @param {object} marker The marker
         */
        $scope.openMarkerInfo = function (marker) {
            return $timeout(function () {
                $scope.currentMarker = marker;
                $scope.myMap.setCenter(marker.position);
                $scope.myInfoWindow.open($scope.myMap, marker);
                var _iteratorNormalCompletion5 = true;
                var _didIteratorError5 = false;
                var _iteratorError5 = undefined;

                try {
                    for (var _iterator5 = Array.from($scope.shownMarkers)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                        var shown_marker = _step5.value;

                        shown_marker.setIcon(defaultPin);
                        if (shown_marker.company.id === marker.company.id) {
                            if (activePin) {
                                shown_marker.setIcon(activePin);
                            }
                            shown_marker.is_open = true;
                        }
                    }
                } catch (err) {
                    _didIteratorError5 = true;
                    _iteratorError5 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion5 && _iterator5.return) {
                            _iterator5.return();
                        }
                    } finally {
                        if (_didIteratorError5) {
                            throw _iteratorError5;
                        }
                    }
                }

                return $scope.shownMarkers;
            }, 250);
        };

        /***
         * @ngdoc method
         * @name selectItem
         * @methodOf BB.Directives:bbMap
         * @description
         * Select an item from map
         *
         * @param company {object} the company to select; by default is the current company set via accordion
         * @param {string=} route A specific route to load
         */
        $scope.selectItem = function () {
            var company = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : $scope.currentMarker.company;
            var route = arguments[1];

            if (!$scope.$debounce(1000)) {
                return;
            }

            if (!company) {
                AlertService.warning(ErrorService.getError('STORE_NOT_SELECTED'));
                return;
            } else if (!company.id) {
                AlertService.warning(ErrorService.getError('STORE_NOT_SELECTED'));
                $log.warn('valid company object not found');
                return;
            }

            loader.notLoaded();

            // if the selected store changes, emit an event. the form data store uses
            // this to clear data, but it can be used to action anything.
            if ($scope.selectedStore && $scope.selectedStore.id !== company.id) {
                $scope.$emit('change:storeLocation');
            }

            $scope.selectedStore = company;

            // Add answers object to the item_defaults if questions have already been asked before the map step
            if ($scope.bb.current_item.item_details && $scope.bb.current_item.item_details.questions) {
                setAnswers();
            }

            if (company.service) {
                $scope.bb.item_defaults.service = company.service.id;
            }

            var init_obj = {
                company_id: company.id,
                item_defaults: $scope.bb.item_defaults,
                no_route: $scope.options.no_route
            };
            if (route) {
                init_obj.first_page = route;
            }

            loader.setLoaded();

            return $scope.initWidget(init_obj);
        };

        var setAnswers = function setAnswers() {
            var answers = {};
            var _iteratorNormalCompletion6 = true;
            var _didIteratorError6 = false;
            var _iteratorError6 = undefined;

            try {
                for (var _iterator6 = Array.from($scope.bb.current_item.item_details.questions)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                    var q = _step6.value;

                    answers['q_' + q.name] = q.answer;
                }
            } catch (err) {
                _didIteratorError6 = true;
                _iteratorError6 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion6 && _iterator6.return) {
                        _iterator6.return();
                    }
                } finally {
                    if (_didIteratorError6) {
                        throw _iteratorError6;
                    }
                }
            }

            if (!_.isEmpty(answers)) {
                return $scope.bb.item_defaults.answers = answers;
            }
        };

        /***
         * @ngdoc method
         * @name roundNumberUp
         * @methodOf BB.Directives:bbMap
         * @description
         * Calculate the round number up
         *
         * @param {integer} num The number of places
         * @param {object} places The places
         */
        $scope.roundNumberUp = function (num, places) {
            return Math.round(num * Math.pow(10, places)) / Math.pow(10, places);
        };

        /***
         * @ngdoc method
         * @name geolocate
         * @methodOf BB.Directives:bbMap
         * @description
         * Get geolocation information
         */
        $scope.geolocate = function () {
            var loadMapOnGeolocate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;


            if (bbAnalyticsPiwik.isEnabled()) setPiwik('Geolocate');

            if (!navigator.geolocation || $scope.reverse_geocode_address && $scope.reverse_geocode_address === $scope.address) {
                return false;
            }

            $scope.loadMapOnGeolocate = loadMapOnGeolocate;

            loader.notLoaded();

            return webshim.ready('geolocation', function () {
                // set timeout as 5 seconds and max age as 1 hour
                var options = {
                    timeout: 5000,
                    maximumAge: 3600000
                };
                return navigator.geolocation.getCurrentPosition(reverseGeocode, geolocateFail, options);
            });
        };

        /***
         * @ngdoc method
         * @name geolocateFail
         * @methodOf BB.Directives:bbMap
         * @description
         * Geolocation fail and display an error message
         *
         * @param {object} error The error
         */
        var geolocateFail = function geolocateFail(error) {
            switch (error.code) {
                // Browser may not allow websites to request physical location. It can be changed in browser settings.
                case error.PERMISSION_DENIED:
                    loader.setLoaded();
                    AlertService.raise('GEOLOCATION_ERROR_FORBIDDEN');
                    break;

                // If the geocode failed because the position was unavailable or the request timed out, raise an alert.
                case error.POSITION_UNAVAILABLE:
                case error.TIMEOUT:
                    loader.setLoaded();
                    AlertService.raise('GEOLOCATION_ERROR');
                    break;
                default:
                    loader.setLoaded();
            }
            return $scope.$apply();
        };

        /***
         * @ngdoc method
         * @name reverseGeocode
         * @methodOf BB.Directives:bbMap
         * @description
         * Reverse geocode in according of position parameter
         *
         * @param {object} positon The postion get latitude and longitude from google maps api
         */
        var reverseGeocode = function reverseGeocode(position) {
            var lat = parseFloat(position.coords.latitude);
            var long = parseFloat(position.coords.longitude);
            var latlng = new google.maps.LatLng(lat, long);

            return new google.maps.Geocoder().geocode({
                'latLng': latlng
            }, function (results, status) {
                if (results.length > 0 && status === 'OK') {
                    $scope.geocoder_result = results[0];

                    var _iteratorNormalCompletion7 = true;
                    var _didIteratorError7 = false;
                    var _iteratorError7 = undefined;

                    try {
                        for (var _iterator7 = Array.from($scope.geocoder_result.address_components)[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                            var ac = _step7.value;

                            if (ac.types.indexOf("route") >= 0) {
                                $scope.reverse_geocode_address = ac.long_name;
                            }
                            if (ac.types.indexOf("locality") >= 0) {
                                $scope.reverse_geocode_address += ', ' + ac.long_name;
                            }
                            $scope.address = $scope.reverse_geocode_address;
                        }
                    } catch (err) {
                        _didIteratorError7 = true;
                        _iteratorError7 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion7 && _iterator7.return) {
                                _iterator7.return();
                            }
                        } finally {
                            if (_didIteratorError7) {
                                throw _iteratorError7;
                            }
                        }
                    }

                    searchSuccess($scope.geocoder_result);
                }
                return $timeout(function () {
                    return loader.setLoaded();
                });
            });
        };

        /***
         * @ngdoc method
         * @name increaseRange
         * @methodOf BB.Directives:bbMap
         * @description
         * Increase range, the range limit is infinity
         */
        $scope.increaseRange = function () {
            $scope.range_limit = Infinity;
            return $scope.searchAddress($scope.search_prms);
        };

        // look for change in display size to determine if the map needs to be refreshed
        $scope.$watch('display.xs', function (new_value, old_value) {
            if (new_value !== old_value && $scope.loc) {
                $scope.myInfoWindow.close();
                loadMap();
                return;
            }
        });

        return $rootScope.$on('widget:restart', function () {
            $scope.loc = null;
            $scope.reverse_geocode_address = null;
            return $scope.address = null;
        });
    }
})(angular);
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbMap
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Loads a list of maps for the currently in scope company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @param {hash}  bbMap A hash of options
 * @property {object} mapLoaded The map has been loaded
 * @property {object} mapReady The maps has been ready
 * @property {object} map_init The initialization the map
 * @property {object} range_limit The range limit
 * @property {boolean} showAllMarkers Display or not all markers
 * @property {array} mapMarkers The map markers
 * @property {array} shownMarkers Display the markers
 * @property {integer} numberedPin The numbered pin
 * @property {integer} defaultPin The default pin
 * @proeprty {boolean} hide_not_live_stores Hide or not the live stores
 * @property {object} address The address
 * @property {object} error_msg The error message
 * @property {object} alert The alert service - see {@link BB.Services:Alert Alert Service}
 */ //


angular.module('BB.Directives').directive('bbMap', function () {
    return {
        restrict: 'A',
        replace: true,
        scope: true,
        controller: 'MapCtrl'
    };
});
'use strict';

angular.module('BB.Controllers').controller('MemberLogin', function ($scope, $log, $rootScope, $templateCache, $q, halClient, BBModel, $sessionStorage, $window, AlertService, ValidatorService, LoadingService) {

    $scope.login = {};

    console.warn('Deprecation warning: validator.validateForm() will be removed from bbMemberLogin in an upcoming major release, please update your template to use bbForm and submitForm() instead. See https://github.com/bookingbug/bookingbug-angular/issues/638');
    $scope.validator = ValidatorService;

    var loader = LoadingService.$loader($scope).notLoaded();

    $rootScope.connection_started.then(function () {

        if (BBModel.Login.$checkLogin()) {
            $scope.setClient($rootScope.member);
            if ($scope.bb.destination) {
                return $scope.redirectTo($scope.bb.destination);
            } else {
                loader.setLoaded();
                $scope.skipThisStep();
                return $scope.decideNextPage();
            }
        } else {
            return halClient.$get($scope.bb.api_url + '/api/v1').then(function (root) {
                return root.$get("new_login").then(function (new_login) {
                    $scope.form = new_login.form;
                    $scope.schema = new_login.schema;
                    return loader.setLoaded();
                }, function (err) {
                    return console.log('err ', err);
                });
            }, function (err) {
                return console.log('err ', err);
            });
        }
    });

    $scope.submit = function () {

        $scope.login.role = 'member';

        return $scope.bb.company.$post('login', {}, $scope.login).then(function (login) {
            if (login.$has('members')) {
                return login.$get('members').then(function (members) {
                    return $scope.handleLogin(members[0]);
                });
            } else if (login.$has('member')) {
                return login.$get('member').then(function (member) {
                    return $scope.handleLogin(member);
                });
            }
        }, function (err) {
            if (err.data.error === "Account has been disabled") {
                return AlertService.raise('ACCOUNT_DISABLED');
            } else {
                return AlertService.raise('LOGIN_FAILED');
            }
        });
    };

    return $scope.handleLogin = function (member) {
        member = BBModel.Login.$setLogin(member, $scope.login.persist_login);
        $scope.setClient(member);
        if ($scope.bb.destination) {
            return $scope.redirectTo($scope.bb.destination);
        } else {
            $scope.skipThisStep();
            return $scope.decideNextPage();
        }
    };
});
'use strict';

angular.module('BB').directive('bbMemberLogin', function (PathSvc) {
    return {
        restrict: 'A',
        controller: 'MemberLogin',
        templateUrl: function templateUrl(elem, attrs) {
            if (attrs.bbCustomLoginForm != null) {
                return PathSvc.directivePartial("_member_login_form");
            } else {
                return PathSvc.directivePartial("_member_login_schema_form");
            }
        }
    };
});
"use strict";
'use strict';

angular.module('BB.Directives').directive('bbMembershipLevels', function ($rootScope, BBModel) {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: function controller($scope, $element, $attrs, LoadingService) {

            var loader = LoadingService.$loader($scope);

            $rootScope.connection_started.then(function () {
                return $scope.initialise();
            });

            $scope.initialise = function () {
                if ($scope.bb.company && $scope.bb.company.$has('member_levels')) {
                    loader.notLoaded();
                    return BBModel.MembershipLevels.$getMembershipLevels($scope.bb.company).then(function (member_levels) {
                        loader.setLoaded();
                        return $scope.membership_levels = member_levels;
                    }
                    //checkClientDefaults()
                    , function (err) {
                        return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
                    });
                }
            };

            $scope.selectMemberLevel = function (level) {
                if (level && $scope.client) {
                    $scope.client.member_level_id = level.id;

                    if ($scope.$parent.$has_page_control) {
                        return;
                    } else {
                        return $scope.decideNextPage();
                    }
                }
            };

            /*let checkClientDefaults = function () {
                if (!$scope.bb.client_defaults.membership_ref) {
                    return;
                }
                return (() => {
                    let result = [];
                    for (let membership_level of Array.from($scope.membership_levels)) {
                        let item;
                        if (membership_level.name === $scope.bb.client_defaults.membership_ref) {
                            item = $scope.selectMemberLevel(membership_level);
                        }
                        result.push(item);
                    }
                    return result;
                })();
            };*/

            $scope.setReady = function () {
                if (!$scope.client.member_level_id) {
                    return false;
                }
                return true;
            };

            return $scope.getMembershipLevel = function (member_level_id) {
                return _.find($scope.membership_levels, function (level) {
                    return level.id === member_level_id;
                });
            };
        }
    };
});
'use strict';

angular.module('BB.Controllers').controller('DayListMa', function ($scope, $rootScope, $q, AlertService, LoadingService, BBModel) {

    var date = void 0,
        day = void 0,
        edate = void 0;
    var loader = LoadingService.$loader($scope).notLoaded();

    $scope.WeekHeaders = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
    $scope.day_data = {};
    if (!$scope.type) {
        $scope.type = "month";
    }
    if (!$scope.data_source) {
        $scope.data_source = $scope.bb.current_item;
    }

    // Load up some day based data
    $rootScope.connection_started.then(function () {
        if (!$scope.current_date && $scope.last_selected_date) {
            $scope.current_date = $scope.last_selected_date.startOf($scope.type);
        } else if (!$scope.current_date) {
            $scope.current_date = moment().startOf($scope.type);
        }
        return $scope.loadData();
    }, function (err) {
        return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
    });

    $scope.$on("currentItemUpdate", function (event) {
        return $scope.loadData();
    });

    /***
     * @ngdoc method
     * @name setCalType
     * @methodOf BB.Directives:bbMonthAvailability
     * @description
     * Set cal type in acording of type
     *
     * @param {array} type The type of day list
     */
    $scope.setCalType = function (type) {
        return $scope.type = type;
    };

    /***
     * @ngdoc method
     * @name setDataSource
     * @methodOf BB.Directives:bbMonthAvailability
     * @description
     * Set data source in according of source
     *
     * @param {string} source The source of day list
     */
    $scope.setDataSource = function (source) {
        return $scope.data_source = source;
    };

    /***
     * @ngdoc method
     * @name format_date
     * @methodOf BB.Directives:bbMonthAvailability
     * @description
     * Format date and get current date
     *
     * @param {date} fmt The format date
     */
    $scope.format_date = function (fmt) {
        if ($scope.current_date) {
            return $scope.current_date.format(fmt);
        }
    };

    /***
     * @ngdoc method
     * @name format_start_date
     * @methodOf BB.Directives:bbMonthAvailability
     * @description
     * Format start date in according of fmt parameter
     *
     * @param {date} fmt The format date
     */
    $scope.format_start_date = function (fmt) {
        return $scope.format_date(fmt);
    };

    /***
     * @ngdoc method
     * @name format_end_date
     * @methodOf BB.Directives:bbMonthAvailability
     * @description
     * Format end date in according of fmt parameter
     *
     * @param {date} fmt The format date
     */
    $scope.format_end_date = function (fmt) {
        if ($scope.end_date) {
            return $scope.end_date.format(fmt);
        }
    };

    /***
     * @ngdoc method
     * @name selectDay
     * @methodOf BB.Directives:bbMonthAvailability
     * @description
     * Select day
     *
     * @param {date} day The day
     * @param {string=} route A specific route to load
     * @param {string} force The force
     */
    $scope.selectDay = function (day, route, force) {
        if (day.spaces === 0 && !force) {
            return false;
        }
        $scope.setLastSelectedDate(day.date);
        $scope.bb.current_item.setDate(day);
        if ($scope.$parent.$has_page_control) {
            return;
        } else {
            return $scope.decideNextPage(route);
        }
    };

    /***
     * @ngdoc method
     * @name setMonth
     * @methodOf BB.Directives:bbMonthAvailability
     * @description
     * Set month
     *
     * @param {date} month The month
     * @param {date} year The year
     */
    $scope.setMonth = function (month, year) {
        $scope.current_date = moment().startOf('month').year(year).month(month - 1);
        $scope.current_date.year();
        return $scope.type = "month";
    };

    /***
     * @ngdoc method
     * @name setWeek
     * @methodOf BB.Directives:bbMonthAvailability
     * @description
     * Set month
     *
     * @param {date} week The week
     * @param {date} year The year
     */
    $scope.setWeek = function (week, year) {
        $scope.current_date = moment().year(year).isoWeek(week).startOf('week');
        $scope.current_date.year();
        return $scope.type = "week";
    };

    /***
     * @ngdoc method
     * @name add
     * @methodOf BB.Directives:bbMonthAvailability
     * @description
     * Add the current date in according of type and amount parameters
     *
     * @param {string} type The type
     * @param {string} amount The amount
     */
    $scope.add = function (type, amount) {
        $scope.current_date.add(amount, type);
        return $scope.loadData();
    };

    /***
     * @ngdoc method
     * @name subtract
     * @methodOf BB.Directives:bbMonthAvailability
     * @description
     * Substract the current date in according of type and amount
     *
     * @param {string} type The type
     * @param {string} amount The amount
     */
    $scope.subtract = function (type, amount) {
        return $scope.add(type, -amount);
    };

    /***
     * @ngdoc method
     * @name isPast
     * @methodOf BB.Directives:bbMonthAvailability
     * @description
     * Calculate if the current earlist date is in the past - in which case we might want to disable going backwards
     */
    // calculate if the current earlist date is in the past - in which case we might want to disable going backwards
    $scope.isPast = function () {
        if (!$scope.current_date) {
            return true;
        }
        return moment().isAfter($scope.current_date);
    };

    /***
     * @ngdoc method
     * @name loadData
     * @methodOf BB.Directives:bbMonthAvailability
     * @description
     * Load week if type is equals with week else load month
     */
    $scope.loadData = function () {
        if ($scope.type === "week") {
            return $scope.loadWeek();
        } else {
            return $scope.loadMonth();
        }
    };

    /***
     * @ngdoc method
     * @name loadMonth
     * @methodOf BB.Directives:bbMonthAvailability
     * @description
     * Load month
     */
    $scope.loadMonth = function () {
        date = $scope.current_date;

        $scope.month = date.month();
        loader.notLoaded();
        edate = moment(date).add(1, 'months');
        $scope.end_date = moment(edate).add(-1, 'days');

        if ($scope.data_source) {
            return BBModel.Day.$query({
                company: $scope.bb.company,
                cItem: $scope.data_source,
                'month': date.format("MMYY"),
                client: $scope.client
            }).then(function (days) {
                $scope.days = days;
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Array.from(days)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        day = _step.value;

                        $scope.day_data[day.string_date] = day;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                var weeks = [];
                for (var w = 0; w <= 5; w++) {
                    var week = [];
                    for (var d = 0; d <= 6; d++) {
                        week.push(days[w * 7 + d]);
                    }
                    weeks.push(week);
                }
                $scope.weeks = weeks;
                return loader.setLoaded();
            }, function (err) {
                return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
            });
        } else {
            return loader.setLoaded();
        }
    };

    /***
     * @ngdoc method
     * @name loadWeek
     * @methodOf BB.Directives:bbMonthAvailability
     * @description
     * Load week
     */
    $scope.loadWeek = function () {
        date = $scope.current_date;
        loader.notLoaded();

        edate = moment(date).add(7, 'days');
        $scope.end_date = moment(edate).add(-1, 'days');
        if ($scope.data_source) {
            return BBModel.Day.$query({
                company: $scope.bb.company,
                cItem: $scope.data_source,
                date: date.toISODate(),
                edate: edate.toISODate(),
                client: $scope.client
            }).then(function (days) {
                $scope.days = days;
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = Array.from(days)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        day = _step2.value;

                        $scope.day_data[day.string_date] = day;
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }

                return loader.setLoaded();
            }, function (err) {
                return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
            });
        } else {
            return loader.setLoaded();
        }
    };

    /***
     * @ngdoc method
     * @name setReady
     * @methodOf BB.Directives:bbMonthAvailability
     * @description
     * Set this page section as ready
     */
    return $scope.setReady = function () {
        if ($scope.bb.current_item.date) {
            return true;
        } else {
            AlertService.clear();
            AlertService.add("danger", { msg: "You need to select a date" });
            return false;
        }
    };
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbMonthAvailability
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Loads a list of month availability for the currently in scope company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @property {string} message The message text
 * @property {string} setLoaded  Set the day list loaded
 * @property {object} setLoadedAndShowError Set loaded and show error
 * @property {object} alert The alert service - see {@link BB.Services:Alert Alert Service}
 */ //


angular.module('BB.Directives').directive('bbMonthAvailability', function () {
    return {
        restrict: 'A',
        replace: true,
        scope: true,
        controller: 'DayListMa'
    };
});
'use strict';

angular.module('BB.Controllers').controller('MonthCalendar', function ($scope, $rootScope, $q, AlertService, LoadingService, BBModel, $translate) {

    var date = void 0,
        day = void 0,
        edate = void 0;
    var loader = LoadingService.$loader($scope).notLoaded();

    $scope.WeekHeaders = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
    $scope.day_data = {};
    if (!$scope.type) {
        $scope.type = "month";
    }
    if (!$scope.data_source) {
        $scope.data_source = $scope.bb.current_item;
    }

    // Load up some day based data
    $rootScope.connection_started.then(function () {
        if (!$scope.current_date && $scope.last_selected_date) {
            $scope.current_date = $scope.last_selected_date.startOf($scope.type);
        } else if (!$scope.current_date) {
            $scope.current_date = moment().startOf($scope.type);
        }
        return $scope.loadData();
    }, function (err) {
        return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
    });

    $scope.$on("currentItemUpdate", function (event) {
        return $scope.loadData();
    });

    /***
     * @ngdoc method
     * @name setCalType
     * @methodOf BB.Directives:bbMonthCalendar
     * @description
     * Set cal type in acording of type
     *
     * @param {array} type The type of day list
     */
    $scope.setCalType = function (type) {
        return $scope.type = type;
    };

    /***
     * @ngdoc method
     * @name setDataSource
     * @methodOf BB.Directives:bbMonthCalendar
     * @description
     * Set data source in according of source
     *
     * @param {string} source The source of day list
     */
    $scope.setDataSource = function (source) {
        return $scope.data_source = source;
    };

    /***
     * @ngdoc method
     * @name format_date
     * @methodOf BB.Directives:bbMonthCalendar
     * @description
     * Format date and get current date
     *
     * @param {date} fmt The format date
     */
    $scope.format_date = function (fmt) {
        if ($scope.current_date) {
            return $scope.current_date.format(fmt);
        }
    };

    /***
     * @ngdoc method
     * @name format_start_date
     * @methodOf BB.Directives:bbMonthCalendar
     * @description
     * Format start date in according of fmt parameter
     *
     * @param {date} fmt The format date
     */
    $scope.format_start_date = function (fmt) {
        return $scope.format_date(fmt);
    };

    /***
     * @ngdoc method
     * @name format_end_date
     * @methodOf BB.Directives:bbMonthCalendar
     * @description
     * Format end date in according of fmt parameter
     *
     * @param {date} fmt The format date
     */
    $scope.format_end_date = function (fmt) {
        if ($scope.end_date) {
            return $scope.end_date.format(fmt);
        }
    };

    /***
     * @ngdoc method
     * @name selectDay
     * @methodOf BB.Directives:bbMonthCalendar
     * @description
     * Select day
     *
     * @param {date} day The day
     * @param {string=} route A specific route to load
     * @param {string} force The force
     */
    $scope.selectDay = function (day, route, force) {
        if (day.spaces === 0 && !force) {
            return false;
        }
        $scope.setLastSelectedDate(day.date);
        $scope.bb.current_item.setDate(day);
        if ($scope.$parent.$has_page_control) {
            return;
        } else {
            return $scope.decideNextPage(route);
        }
    };

    /***
     * @ngdoc method
     * @name setMonth
     * @methodOf BB.Directives:bbMonthCalendar
     * @description
     * Set month
     *
     * @param {date} month The month
     * @param {date} year The year
     */
    $scope.setMonth = function (month, year) {
        $scope.current_date = moment().startOf('month').year(year).month(month - 1);
        $scope.current_date.year();
        return $scope.type = "month";
    };

    /***
     * @ngdoc method
     * @name setWeek
     * @methodOf BB.Directives:bbMonthCalendar
     * @description
     * Set month
     *
     * @param {date} week The week
     * @param {date} year The year
     */
    $scope.setWeek = function (week, year) {
        $scope.current_date = moment().year(year).isoWeek(week).startOf('week');
        $scope.current_date.year();
        return $scope.type = "week";
    };

    /***
     * @ngdoc method
     * @name add
     * @methodOf BB.Directives:bbMonthCalendar
     * @description
     * Add the current date in according of type and amount parameters
     *
     * @param {string} type The type
     * @param {string} amount The amount
     */
    $scope.add = function (type, amount) {
        $scope.current_date.add(amount, type);
        return $scope.loadData();
    };

    /***
     * @ngdoc method
     * @name subtract
     * @methodOf BB.Directives:bbMonthCalendar
     * @description
     * Substract the current date in according of type and amount
     *
     * @param {string} type The type
     * @param {string} amount The amount
     */
    $scope.subtract = function (type, amount) {
        return $scope.add(type, -amount);
    };

    /***
     * @ngdoc method
     * @name isPast
     * @methodOf BB.Directives:bbMonthCalendar
     * @description
     * Calculate if the current earlist date is in the past - in which case we might want to disable going backwards
     */
    // calculate if the current earlist date is in the past - in which case we might want to disable going backwards
    $scope.isPast = function () {
        if (!$scope.current_date) {
            return true;
        }
        return moment().isAfter($scope.current_date);
    };

    /***
     * @ngdoc method
     * @name loadData
     * @methodOf BB.Directives:bbMonthCalendar
     * @description
     * Load week if type is equals with week else load month
     */
    $scope.loadData = function () {
        if ($scope.type === "week") {
            return $scope.loadWeek();
        } else {
            return $scope.loadMonth();
        }
    };

    /***
     * @ngdoc method
     * @name loadMonth
     * @methodOf BB.Directives:bbMonthCalendar
     * @description
     * Load month
     */
    $scope.loadMonth = function () {
        date = $scope.current_date;

        $scope.month = date.month();
        loader.notLoaded();
        edate = moment(date).add(1, 'months');
        $scope.end_date = moment(edate).add(-1, 'days');

        if ($scope.data_source) {
            return BBModel.Day.$query({
                company: $scope.bb.company,
                cItem: $scope.data_source,
                'month': date.format("MMYY"),
                client: $scope.client
            }).then(function (days) {
                $scope.days = days;
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Array.from(days)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        day = _step.value;

                        $scope.day_data[day.string_date] = day;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                var weeks = [];
                for (var w = 0; w <= 5; w++) {
                    var week = [];
                    for (var d = 0; d <= 6; d++) {
                        week.push(days[w * 7 + d]);
                    }
                    weeks.push(week);
                }
                $scope.weeks = weeks;
                return loader.setLoaded();
            }, function (err) {
                return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
            });
        } else {
            return loader.setLoaded();
        }
    };

    /***
     * @ngdoc method
     * @name loadWeek
     * @methodOf BB.Directives:bbMonthCalendar
     * @description
     * Load week
     */
    $scope.loadWeek = function () {
        date = $scope.current_date;
        loader.notLoaded();

        edate = moment(date).add(7, 'days');
        $scope.end_date = moment(edate).add(-1, 'days');
        if ($scope.data_source) {
            return BBModel.Day.$query({
                company: $scope.bb.company,
                cItem: $scope.data_source,
                date: date.toISODate(),
                edate: edate.toISODate(),
                client: $scope.client
            }).then(function (days) {
                $scope.days = days;
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = Array.from(days)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        day = _step2.value;

                        $scope.day_data[day.string_date] = day;
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }

                return loader.setLoaded();
            }, function (err) {
                return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
            });
        } else {
            return loader.setLoaded();
        }
    };

    /***
     * @ngdoc method
     * @name setReady
     * @methodOf BB.Directives:bbMonthCalendar
     * @description
     * Set this page section as ready
     */
    return $scope.setReady = function () {
        if ($scope.bb.current_item.date) {
            return true;
        } else {
            AlertService.clear();
            AlertService.add("danger", { msg: $translate.instant("PUBLIC_BOOKING.DAY.DATE_NOT_SELECTED") });
            return false;
        }
    };
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbMonthCalendar
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Loads a list of month availability for the currently in scope company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @property {string} message The message text
 * @property {string} setLoaded  Set the day list loaded
 * @property {object} setLoadedAndShowError Set loaded and show error
 * @property {object} alert The alert service - see {@link BB.Services:Alert Alert Service}
 */

angular.module('BB.Directives').directive('bbMonthCalendar', function () {
    return {
        restrict: 'A',
        replace: true,
        scope: true,
        controller: 'MonthCalendar'
    };
});
'use strict';

angular.module('BB.Controllers').controller('MultiServiceSelect', function ($scope, $rootScope, $q, $attrs, BBModel, $uibModal, $document, AlertService, FormDataStoreService, LoadingService) {

    FormDataStoreService.init('MultiServiceSelect', $scope, ['selected_category_name']);

    $scope.options = $scope.$eval($attrs.bbMultiServiceSelect) || {};
    $scope.options.max_services = $scope.options.max_services || Infinity;
    $scope.options.ordered_categories = $scope.options.ordered_categories || false;
    $scope.options.services = $scope.options.services || 'items';

    var loader = LoadingService.$loader($scope);

    $rootScope.connection_started.then(function () {
        if ($scope.bb.company.$has('parent') && !$scope.bb.company.$has('company_questions')) {
            $scope.bb.company.$getParent().then(function (parent) {
                $scope.company = parent;
                return initialise();
            });
        } else {
            $scope.company = $scope.bb.company;
        }

        // wait for services before we begin initialisation
        return $scope.$watch($scope.options.services, function (newval, oldval) {
            if (newval && angular.isArray(newval)) {
                $scope.items = newval;
                return initialise();
            }
        });
    });

    var initialise = function initialise() {

        if (!$scope.items || !$scope.company) {
            return;
        }

        $scope.initialised = true;

        var promises = [];

        promises.push(BBModel.Category.$query($scope.bb.company));

        // company question promise
        if ($scope.company.$has('company_questions')) {
            promises.push($scope.company.$getCompanyQuestions());
        }

        return $q.all(promises).then(function (result) {

            $scope.company_questions = result[1];

            initialiseCategories(result[0]);

            // if there's already some stacked items (i.e. we've come back to this page,
            // make sure they're selected)
            if ($scope.bb.stacked_items && $scope.bb.stacked_items.length > 0) {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Array.from($scope.bb.stacked_items)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var stacked_item = _step.value;
                        var _iteratorNormalCompletion2 = true;
                        var _didIteratorError2 = false;
                        var _iteratorError2 = undefined;

                        try {
                            for (var _iterator2 = Array.from($scope.items)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                var item = _step2.value;

                                if (item.self === stacked_item.service.self) {
                                    stacked_item.service = item;
                                    stacked_item.service.selected = true;
                                    break;
                                }
                            }
                        } catch (err) {
                            _didIteratorError2 = true;
                            _iteratorError2 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                    _iterator2.return();
                                }
                            } finally {
                                if (_didIteratorError2) {
                                    throw _iteratorError2;
                                }
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            } else {
                // check item defaults
                checkItemDefaults();
            }

            // if we're moving the booking, just move to the next step
            if ($scope.bb.moving_booking) {
                $scope.nextStep();
            }

            $scope.$broadcast("multi_service_select:loaded");

            return loader.setLoaded();
        }, function (err) {
            return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
        });
    };

    /***
     * @ngdoc method
     * @name checkItemDefaults
     * @methodOf BB.Directives:bbMultiServiceSelect
     * @description
     * Check item defaults
     */
    var checkItemDefaults = function checkItemDefaults() {
        if (!$scope.bb.item_defaults.service) {
            return;
        }
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
            for (var _iterator3 = Array.from($scope.items)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var service = _step3.value;

                if (service.self === $scope.bb.item_defaults.service.self) {
                    $scope.addItem(service);
                    return;
                }
            }
        } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                    _iterator3.return();
                }
            } finally {
                if (_didIteratorError3) {
                    throw _iteratorError3;
                }
            }
        }
    };

    /***
     * @ngdoc method
     * @name initialiseCategories
     * @methodOf BB.Directives:bbMultiServiceSelect
     * @description
     * Initialize the categories in according of categories parameter
     *
     * @param {array} categories The categories of service
     */
    var initialiseCategories = function initialiseCategories(categories) {

        // extract order from category name if we're using ordered categories
        var category = void 0;
        if ($scope.options.ordered_categories) {
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
                for (var _iterator4 = Array.from(categories)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                    category = _step4.value;

                    category.order = parseInt(category.name.slice(0, 2));
                    category.name = category.name.slice(3);
                }
            } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion4 && _iterator4.return) {
                        _iterator4.return();
                    }
                } finally {
                    if (_didIteratorError4) {
                        throw _iteratorError4;
                    }
                }
            }
        }

        // index categories by their id
        $scope.all_categories = _.indexBy(categories, 'id');

        // group services by category id
        var all_categories = _.groupBy($scope.items, function (item) {
            return item.category_id;
        });

        // find any sub categories
        var sub_categories = _.findWhere($scope.company_questions, { name: 'Extra Category' });
        if (sub_categories) {
            sub_categories = _.map(sub_categories.question_items, function (sub_category) {
                return sub_category.name;
            });
        }

        // filter categories that have no services
        categories = {};
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
            for (var _iterator5 = Object.keys(all_categories || {})[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                var key = _step5.value;

                var value = all_categories[key];
                if (value.length > 0) {
                    categories[key] = value;
                }
            }

            // build the catagories array
        } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion5 && _iterator5.return) {
                    _iterator5.return();
                }
            } finally {
                if (_didIteratorError5) {
                    throw _iteratorError5;
                }
            }
        }

        $scope.categories = [];

        return function () {
            var result = [];
            for (var category_id in categories) {

                var category_details;
                var services = categories[category_id];
                var item = void 0;
                category = {};

                // group services by their subcategory
                var grouped_sub_categories = [];
                if (sub_categories) {
                    var _iteratorNormalCompletion6 = true;
                    var _didIteratorError6 = false;
                    var _iteratorError6 = undefined;

                    try {
                        for (var _iterator6 = Array.from(sub_categories)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                            var sub_category = _step6.value;

                            var grouped_sub_category = {
                                name: sub_category,
                                services: _.filter(services, function (service) {
                                    return service.extra.extra_category === sub_category;
                                })
                            };

                            // only add the sub category if it has some services
                            if (grouped_sub_category.services.length > 0) {
                                grouped_sub_categories.push(grouped_sub_category);
                            }
                        }
                    } catch (err) {
                        _didIteratorError6 = true;
                        _iteratorError6 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion6 && _iterator6.return) {
                                _iterator6.return();
                            }
                        } finally {
                            if (_didIteratorError6) {
                                throw _iteratorError6;
                            }
                        }
                    }

                    category.sub_categories = grouped_sub_categories;
                } else {
                    category.services = services;
                }

                // get the name and description
                if ($scope.all_categories[category_id]) {
                    category_details = {
                        name: $scope.all_categories[category_id].name,
                        description: $scope.all_categories[category_id].description
                    };
                }

                // set the category
                category.name = category_details.name;
                category.description = category_details.description;

                // get the order if instruccted
                if ($scope.options.ordered_categories && $scope.all_categories[category_id]) {
                    category.order = $scope.all_categories[category_id].order;
                }

                $scope.categories.push(category);

                // check it a category is already selected
                if ($scope.selected_category_name && $scope.selected_category_name === category_details.name) {
                    item = $scope.selected_category = $scope.categories[$scope.categories.length - 1];
                    // or if there's a default category
                } else if ($scope.bb.item_defaults.category && $scope.bb.item_defaults.category.name === category_details.name && !$scope.selected_category) {
                    $scope.selected_category = $scope.categories[$scope.categories.length - 1];
                    item = $scope.selected_category_name = $scope.selected_category.name;
                }
                result.push(item);
            }
            return result;
        }();
    };

    /***
     * @ngdoc method
     * @name changeCategory
     * @methodOf BB.Directives:bbMultiServiceSelect
     * @description
     * Change category in according of category name and services parameres
     *
     * @param {string} category_name The category name
     * @param {array} services The services array
     */
    $scope.changeCategory = function (category_name, services) {

        if (category_name && services) {
            $scope.selected_category = {
                name: category_name,
                sub_categories: services
            };
            $scope.selected_category_name = $scope.selected_category.name;
            return $rootScope.$broadcast("multi_service_select:category_changed");
        }
    };

    /***
     * @ngdoc method
     * @name changeCategoryName
     * @methodOf BB.Directives:bbMultiServiceSelect
     * @description
     * Change the category name
     */
    $scope.changeCategoryName = function () {
        $scope.selected_category_name = $scope.selected_category.name;
        return $rootScope.$broadcast("multi_service_select:category_changed");
    };

    /***
     * @ngdoc method
     * @name addItem
     * @methodOf BB.Directives:bbMultiServiceSelect
     * @description
     * Add item in according of item and duration parameters
     *
     * @param {array} item The item that been added
     * @param {date} duration The duration
     */
    $scope.addItem = function (item, duration) {
        if ($scope.bb.stacked_items.length < $scope.options.max_services) {
            $scope.bb.clearStackedItemsDateTime(); // clear any selected date/time as the selection has changed
            item.selected = true;
            var iitem = new BBModel.BasketItem(null, $scope.bb);
            iitem.setDefaults($scope.bb.item_defaults);
            iitem.setService(item);
            if (duration) {
                iitem.setDuration(duration);
            }
            iitem.setGroup(item.group);
            $scope.bb.stackItem(iitem);
            $rootScope.$broadcast("multi_service_select:item_added");
            if ($scope.options.raise_alerts) {
                return AlertService.info({ msg: item.name + ' added to your treatment selection', persist: false });
            }
        } else {
            return Array.from($scope.items).map(function (i) {
                return i.popover = 'Sorry, you can only book a maximum of ' + $scope.options.max_services + ' treatments', i.popoverText = i.popover;
            });
        }
    };

    /***
     * @ngdoc method
     * @name removeItem
     * @methodOf BB.Directives:bbMultiServiceSelect
     * @description
     * Remove item in according of item and options parameters
     *
     * @params {array} item The item that been removed
     * @params {array} options The options remove
     */
    $scope.removeItem = function (item, options) {
        item.selected = false;

        if (options && options.type === 'BasketItem') {
            $scope.bb.deleteStackedItem(item);
        } else {
            $scope.bb.deleteStackedItemByService(item);
        }

        $scope.bb.clearStackedItemsDateTime(); // clear any selected date/time as the selection has changed
        $rootScope.$broadcast("multi_service_select:item_removed");
        return function () {
            var result = [];
            var _iteratorNormalCompletion7 = true;
            var _didIteratorError7 = false;
            var _iteratorError7 = undefined;

            try {
                for (var _iterator7 = Array.from($scope.items)[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                    var i = _step7.value;

                    var item1 = void 0;
                    if (i.self === item.self) {
                        i.selected = false;
                        break;
                    }
                    result.push(item1);
                }
            } catch (err) {
                _didIteratorError7 = true;
                _iteratorError7 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion7 && _iterator7.return) {
                        _iterator7.return();
                    }
                } finally {
                    if (_didIteratorError7) {
                        throw _iteratorError7;
                    }
                }
            }

            return result;
        }();
    };

    /***
     * @ngdoc method
     * @name removeStackedItem
     * @methodOf BB.Directives:bbMultiServiceSelect
     * @description
     * Removed stacked item whose type is 'BasketItem'
     *
     * @params {array} item The item that been removed
     */
    $scope.removeStackedItem = function (item) {
        return $scope.removeItem(item, { type: 'BasketItem' });
    };

    /***
     * @ngdoc method
     * @name nextStep
     * @methodOf BB.Directives:bbMultiServiceSelect
     * @description
     * Next step to selected an basket item, if basket item is not selected she display an error message
     */
    $scope.nextStep = function () {
        if ($scope.bb.stacked_items.length > 1) {
            return $scope.decideNextPage();
        } else if ($scope.bb.stacked_items.length === 1) {
            // first clear anything already in the basket and then set the basket item
            if ($scope.bb.basket && $scope.bb.basket.items.length > 0) {
                $scope.quickEmptybasket({ preserve_stacked_items: true });
            }
            $scope.setBasketItem($scope.bb.stacked_items[0]);
            return $scope.decideNextPage();
        } else {
            AlertService.clear();
            return AlertService.add("danger", { msg: "You need to select at least one treatment to continue" });
        }
    };

    /***
     * @ngdoc method
     * @name addService
     * @methodOf BB.Directives:bbMultiServiceSelect
     * @description
     * Add service which add a new item
     */
    $scope.addService = function () {
        return $rootScope.$broadcast("multi_service_select:add_item");
    };

    /***
     * @ngdoc method
     * @name setReady
     * @methodOf BB.Directives:bbMultiServiceSelect
     * @description
     * Set this page section as ready
     */
    $scope.setReady = function () {
        if ($scope.bb.stacked_items.length > 1) {
            return true;
        } else if ($scope.bb.stacked_items.length === 1) {
            // first clear anything already in the basket and then set the basket item
            if ($scope.bb.basket && $scope.bb.basket.items.length > 0) {
                $scope.quickEmptybasket({ preserve_stacked_items: true });
            }
            $scope.setBasketItem($scope.bb.stacked_items[0]);
            return true;
        } else {
            AlertService.clear();
            AlertService.add("danger", { msg: "You need to select at least one treatment to continue" });
            return false;
        }
    };

    /***
     * @ngdoc method
     * @name selectDuration
     * @methodOf BB.Directives:bbMultiServiceSelect
     * @description
     * Select duration in according of service parameter and display the modal
     *
     * @params {object} service The service
     */
    return $scope.selectDuration = function (_service) {

        if (_service.durations.length === 1) {
            return $scope.addItem(_service);
        } else {

            var modalInstance = $uibModal.open({
                templateUrl: $scope.getPartial('_select_duration_modal'),
                scope: $scope,
                controller: function controller($scope, $uibModalInstance, service) {
                    $scope.durations = service.durations;
                    $scope.duration = $scope.durations[0];
                    $scope.service = service;

                    $scope.cancel = function () {
                        return $uibModalInstance.dismiss('cancel');
                    };
                    return $scope.setDuration = function () {
                        return $uibModalInstance.close({
                            service: $scope.service,
                            duration: $scope.duration
                        });
                    };
                },

                resolve: {
                    service: function service() {
                        return _service;
                    }
                }
            });

            return modalInstance.result.then(function (result) {
                return $scope.addItem(result.service, result.duration);
            });
        }
    };
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbMultiServiceSelect
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Enables selection of multiple services for the currently in scope company
 *
 * NOTE: This directive needs to be used with bbTimeRangeStacked directive
 * This directive must be placed within the _service.html template or equivalent
 * The bbTimeRangeStacked directive should be used on the same scope as bbTimeRanges to enable this feature
 *
 * The template (_service.html) should be updated to use addItem() and removeItem() to select services
 *
 * WARNING: this does not work well with booking multiple services which have pre and post times
 * pre and post times are not considered so bookings may overlap
 *
 * <pre>
 * restrict: 'AE'
 * scope: true
 * </pre>
 *
 * @param {hash}  bbMultiServiceSelect A hash of options
 * @property {object} options The options of service
 * @property {object} max_services The max services
 * @property {boolean} ordered_categories Verify if categories are ordered or not
 * @property {array} services The services
 * @property {array} company The company
 * @property {array} items An array of items service
 * @property {object} alert The alert service - see {@link BB.Services:Alert Alert Service}
 */ //


angular.module('BB.Directives').directive('bbMultiServiceSelect', function () {
    return {
        restrict: 'AE',
        scope: true,
        controller: 'MultiServiceSelect'
    };
});
'use strict';

angular.module('BB.Controllers').controller('PackageItem', function ($scope, $rootScope, BBModel) {

    $rootScope.connection_started.then(function () {
        if ($scope.bb.company) {
            return $scope.init($scope.bb.company);
        }
    });

    $scope.init = function (company) {
        if (!$scope.booking_item) {
            $scope.booking_item = $scope.bb.current_item;
        }
        return BBModel.PackageItem.$query(company).then(function (package_items) {
            return $scope.packages = package_items;
        });
    };

    /***
     * @ngdoc method
     * @name selectItem
     * @methodOf BB.Directives:bbPackageItems
     * @description
     * Select a package into the current booking journey and route on to the next page dpending on the current page control
     *
     * @param {object} package The Service or BookableItem to select
     * @param {string=} route A specific route to load
     */
    $scope.selectItem = function (item, route) {
        if ($scope.$parent.$has_page_control) {
            $scope.package = item;
            return false;
        } else {
            $scope.booking_item.setPackageItem(item);
            $scope.decideNextPage(route);
            return true;
        }
    };

    /***
     * @ngdoc method
     * @name setReady
     * @methodOf BB.Directives:bbPackageItems
     * @description
     * Set this page section as ready - see {@link BB.Directives:bbPage Page Control}
     */
    $scope.setReady = function () {
        if ($scope.package) {
            $scope.booking_item.setPackageItem($scope.package);
            return true;
        } else {
            return false;
        }
    };

    /***
     * @ngdoc method
     * @name getPackageServices
     * @methodOf BB.Directives:bbPackageItems
     * @description
     * Query all of the services included in the package
     * @params {array} item.service_list an array of services within the item
     */
    return $scope.getPackageServices = function (item) {
        if (item && !item.service_list) {
            item.service_list = [];
            var promise = BBModel.PackageItem.$getPackageServices(item);
            promise.then(function (services) {
                return item.service_list = services;
            });
            return true;
        } else {
            return false;
        }
    };
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbPackageItems
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Loads a list of packages for the currently in scroe company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @param {hash}  bbPackgeItems   A hash of options
 * @property {array} packages An array of all services
 * @property {array} bookable_items An array of all BookableItems - used if the current_item has already selected a resource or person
 * @property {array} bookable_services An array of Services - used if the current_item has already selected a resource or person
 * @property {package} package The currectly selected package
 * @property {hash} filters A hash of filters
 *  
 *  <example module="BB">
 *    <file name="index.html">
 *   <div bb-api-url='https://uk.bookingbug.com'>
 *   <div  bb-widget='{company_id:21}'>
 *     <div bb-package-items>
 *        <ul>
 *          <li ng-repeat='package in packages'> {{package.name}}</li>
 *        </ul>
 *     </div>
 *     </div>
 *     </div>
 *   </file>
 *  </example>
 *
 */ //

angular.module('BB.Directives').directive('bbPackageItems', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'PackageItem'
    };
});
'use strict';

angular.module('BB.Controllers').controller('PackagePicker', function ($scope, $rootScope, $q, TimeService, LoadingService, BBModel) {

    var item = void 0,
        latest = void 0,
        slot = void 0,
        time = void 0;
    $scope.sel_date = moment().add(1, 'days');
    $scope.selected_date = $scope.sel_date.toDate();
    $scope.picked_time = false;
    var loader = LoadingService.$loader($scope);

    $scope.$watch('selected_date', function (newv, oldv) {
        $scope.sel_date = moment(newv);
        return $scope.loadDay();
    });

    /***
     * @ngdoc method
     * @name loadDay
     * @methodOf BB.Directives:bbPackagePicker
     * @description
     * Load day
     */
    $scope.loadDay = function () {
        $scope.timeSlots = [];
        loader.notLoaded();

        var pslots = [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = Array.from($scope.stackedItems)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                item = _step.value;

                pslots.push(TimeService.query({
                    company: $scope.bb.company,
                    cItem: item,
                    date: $scope.sel_date,
                    client: $scope.client
                }));
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        return $q.all(pslots).then(function (res) {
            loader.setLoaded();
            $scope.data_valid = true;
            $scope.timeSlots = [];
            for (var _i = 0; _i < $scope.stackedItems.length; _i++) {
                item = $scope.stackedItems[_i];
                item.slots = res[_i];
                if (!item.slots || item.slots.length === 0) {
                    $scope.data_valid = false;
                }
                item.order = _i;
            }

            // only show times if all of the severs have availability
            if ($scope.data_valid) {

                $scope.timeSlots = res;
                // go through the items forward - to disable any start times that can't be booked for later services
                var earliest = null;
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = Array.from($scope.stackedItems)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        item = _step2.value;

                        var next_earliest = null;
                        var _iteratorNormalCompletion5 = true;
                        var _didIteratorError5 = false;
                        var _iteratorError5 = undefined;

                        try {
                            for (var _iterator5 = Array.from(item.slots)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                                slot = _step5.value;

                                if (earliest && slot.time < earliest) {
                                    slot.disable();
                                } else if (!next_earliest) {
                                    next_earliest = slot.time + item.service.duration;
                                }
                            }
                        } catch (err) {
                            _didIteratorError5 = true;
                            _iteratorError5 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion5 && _iterator5.return) {
                                    _iterator5.return();
                                }
                            } finally {
                                if (_didIteratorError5) {
                                    throw _iteratorError5;
                                }
                            }
                        }

                        earliest = next_earliest;
                    }

                    // go through the items backwards - to disable any start times that can't be booked for earlier services
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }

                latest = null;
                return function () {
                    var result = [];
                    var _iteratorNormalCompletion3 = true;
                    var _didIteratorError3 = false;
                    var _iteratorError3 = undefined;

                    try {
                        for (var _iterator3 = Array.from($scope.bb.stacked_items.slice(0).reverse())[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                            item = _step3.value;

                            var next_latest = null;
                            var _iteratorNormalCompletion4 = true;
                            var _didIteratorError4 = false;
                            var _iteratorError4 = undefined;

                            try {
                                for (var _iterator4 = Array.from(item.slots)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                                    slot = _step4.value;

                                    if (latest && slot.time > latest) {
                                        slot.disable();
                                    } else {
                                        next_latest = slot.time - item.service.duration;
                                    }
                                }
                            } catch (err) {
                                _didIteratorError4 = true;
                                _iteratorError4 = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion4 && _iterator4.return) {
                                        _iterator4.return();
                                    }
                                } finally {
                                    if (_didIteratorError4) {
                                        throw _iteratorError4;
                                    }
                                }
                            }

                            result.push(latest = next_latest);
                        }
                    } catch (err) {
                        _didIteratorError3 = true;
                        _iteratorError3 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion3 && _iterator3.return) {
                                _iterator3.return();
                            }
                        } finally {
                            if (_didIteratorError3) {
                                throw _iteratorError3;
                            }
                        }
                    }

                    return result;
                }();
            }
        }, function (err) {
            return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
        });
    };

    /***
     * @ngdoc method
     * @name selectSlot
     * @methodOf BB.Directives:bbPackagePicker
     * @description
     * Select slot in according of sel_item and slot parameters
     *
     * @param {array} sel_item The sel item
     * @param {object} slot The slot
     */
    $scope.selectSlot = function (sel_item, slot) {

        for (var count = 0; count < $scope.stackedItems.length; count++) {
            var next;
            item = $scope.stackedItems[count];
            if (count === sel_item.order) {
                item.setDate(new BBModel.Day({ date: $scope.sel_date.format(), spaces: 1 }));
                item.setTime(slot);
                next = slot.time + item.service.duration;
                var _slot = slot;
                time = _slot.time;

                slot = null;
                // if this wasnt the first item - we might need to go backwards through the previous package items - but only if they haven't already had a time picked - or it the time picked wasn't valid
                if (count > 0) {
                    var current = count - 1;
                    while (current >= 0) {
                        item = $scope.bb.stacked_items[current];
                        latest = time - item.service.duration; // the last time this service can be based on the next time (we're not accounting for gaps yet) - and the previous service duration
                        if (!item.time || item.time.time > latest) {
                            // if the item doesn't already have a time - or has one, but it's no longer valid for the picked new time
                            // pick a new time - select the last possible time
                            item.setDate(new BBModel.Day({ date: $scope.sel_date.format(), spaces: 1 }));
                            item.setTime(null);
                            var _iteratorNormalCompletion6 = true;
                            var _didIteratorError6 = false;
                            var _iteratorError6 = undefined;

                            try {
                                for (var _iterator6 = Array.from(item.slots)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                                    slot = _step6.value;

                                    if (slot.time < latest) {
                                        item.setTime(slot);
                                    }
                                }
                            } catch (err) {
                                _didIteratorError6 = true;
                                _iteratorError6 = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion6 && _iterator6.return) {
                                        _iterator6.return();
                                    }
                                } finally {
                                    if (_didIteratorError6) {
                                        throw _iteratorError6;
                                    }
                                }
                            }
                        }
                        time = item.time.time;

                        current -= 1;
                    }
                }
            } else if (count > sel_item.order) {
                // for the last items - resort them
                var _item = item,
                    slots = _item.slots;

                item.setDate(new BBModel.Day({ date: $scope.sel_date.format(), spaces: 1 }));
                if (slots) {
                    item.setTime(null);
                    var _iteratorNormalCompletion7 = true;
                    var _didIteratorError7 = false;
                    var _iteratorError7 = undefined;

                    try {
                        for (var _iterator7 = Array.from(slots)[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                            slot = _step7.value;

                            if (slot.time >= next && !item.time) {
                                item.setTime(slot);
                                next = slot.time + item.service.duration;
                            }
                        }
                    } catch (err) {
                        _didIteratorError7 = true;
                        _iteratorError7 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion7 && _iterator7.return) {
                                _iterator7.return();
                            }
                        } finally {
                            if (_didIteratorError7) {
                                throw _iteratorError7;
                            }
                        }
                    }
                }
            }
        }
        return $scope.picked_time = true;
    };

    /***
     * @ngdoc method
     * @name hasAvailability
     * @methodOf BB.Directives:bbPackagePicker
     * @description
     * Checks if picker have the start time and the end time available
     *
     * @param {object} slots The slots of the package picker
     * @param {date} start_time The start time of the picker
     * @param {date} end_time The end time of the picker
     */
    // helper function to determine if there's availability between given times,
    // returns true immediately if a time a slot is found with availability
    $scope.hasAvailability = function (slots, start_time, end_time) {

        if (!slots) {
            return false;
        }

        if (start_time && end_time) {
            // it's a time range query
            var _iteratorNormalCompletion8 = true;
            var _didIteratorError8 = false;
            var _iteratorError8 = undefined;

            try {
                for (var _iterator8 = Array.from(slots)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                    slot = _step8.value;

                    if (slot.time >= start_time && slot.time < end_time && slot.availability() > 0) {
                        return true;
                    }
                }
            } catch (err) {
                _didIteratorError8 = true;
                _iteratorError8 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion8 && _iterator8.return) {
                        _iterator8.return();
                    }
                } finally {
                    if (_didIteratorError8) {
                        throw _iteratorError8;
                    }
                }
            }
        } else if (end_time) {
            // it's a 'less than' query
            var _iteratorNormalCompletion9 = true;
            var _didIteratorError9 = false;
            var _iteratorError9 = undefined;

            try {
                for (var _iterator9 = Array.from(slots)[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                    slot = _step9.value;

                    if (slot.time < end_time && slot.availability() > 0) {
                        return true;
                    }
                }
            } catch (err) {
                _didIteratorError9 = true;
                _iteratorError9 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion9 && _iterator9.return) {
                        _iterator9.return();
                    }
                } finally {
                    if (_didIteratorError9) {
                        throw _iteratorError9;
                    }
                }
            }
        } else if (start_time) {
            // it's a 'greater than' query
            var _iteratorNormalCompletion10 = true;
            var _didIteratorError10 = false;
            var _iteratorError10 = undefined;

            try {
                for (var _iterator10 = Array.from(slots)[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
                    slot = _step10.value;

                    if (slot.time >= start_time && slot.availability() > 0) {
                        return true;
                    }
                }
            } catch (err) {
                _didIteratorError10 = true;
                _iteratorError10 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion10 && _iterator10.return) {
                        _iterator10.return();
                    }
                } finally {
                    if (_didIteratorError10) {
                        throw _iteratorError10;
                    }
                }
            }
        } else {
            // check if there's availability across all slots
            var _iteratorNormalCompletion11 = true;
            var _didIteratorError11 = false;
            var _iteratorError11 = undefined;

            try {
                for (var _iterator11 = Array.from(slots)[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
                    slot = _step11.value;

                    if (slot.availability() > 0) {
                        return true;
                    }
                }
            } catch (err) {
                _didIteratorError11 = true;
                _iteratorError11 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion11 && _iterator11.return) {
                        _iterator11.return();
                    }
                } finally {
                    if (_didIteratorError11) {
                        throw _iteratorError11;
                    }
                }
            }
        }
    };

    return $scope.confirm = function () {};
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbPackagePicker
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Loads a list of package pickers for the currently in scope company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @property {date} sel_date The sel date
 * @property {date} selected_date The selected date
 * @property {boolean} picked_time The picked time
 * @property {array} timeSlots The time slots
 * @property {boolean} data_valid The valid data
 */ //


angular.module('BB.Directives').directive('bbPackagePicker', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'PackagePicker'
    };
});
'use strict';

angular.module('BB.Controllers').controller('Payment', function ($scope, $rootScope, $q, $location, $window, $sce, $log, $timeout, LoadingService) {

    var loader = LoadingService.$loader($scope).notLoaded();

    if ($scope.purchase) {
        $scope.bb.total = $scope.purchase;
    }

    $rootScope.connection_started.then(function () {
        if ($scope.total) {
            $scope.bb.total = $scope.total;
        }
        if ($scope.bb && $scope.bb.total && $scope.bb.total.$href('new_payment')) {
            return $scope.url = $sce.trustAsResourceUrl($scope.bb.total.$href('new_payment'));
        }
    });

    /***
     * @ngdoc method
     * @name callNotLoaded
     * @methodOf BB.Directives:bbPayment
     * @description
     * Set not loaded state
     */
    $scope.callNotLoaded = function () {
        return loader.notLoaded();
    };

    /***
     * @ngdoc method
     * @name callSetLoaded
     * @methodOf BB.Directives:bbPayment
     * @description
     * Set loaded state
     */
    $scope.callSetLoaded = function () {
        return loader.setLoaded();
    };

    /***
     * @ngdoc method
     * @name paymentDone
     * @methodOf BB.Directives:bbPayment
     * @description
     * Handles payment success
     */
    $scope.paymentDone = function () {
        $scope.bb.payment_status = "complete";
        $scope.$emit('payment:complete');
        if ($scope.route_to_next_page) {
            return $scope.decideNextPage();
        }
    };

    return $scope.error = function (message) {
        return $log.warn('Payment Failure: ' + message);
    };
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbPayment
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Renders payment iframe (where integrated payment has been configured) and handles payment success/failure.
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @property {array} total The total of payment
 */ //


angular.module('BB.Directives').directive('bbPayment', function ($window, $location, $sce, GeneralOptions, AlertService) {

    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'Payment',
        link: function link(scope, element, attributes) {

            var getHost = function getHost(url) {
                var a = document.createElement('a');
                a.href = url;
                return a['protocol'] + '//' + a['host'];
            };

            var sendLoadEvent = function sendLoadEvent(element, origin, scope) {
                var custom_stylesheet = void 0;
                var referrer = $location.protocol() + "://" + $location.host();
                if ($location.port()) {
                    referrer += ':' + $location.port();
                }

                if (scope.payment_options.custom_stylesheet) {
                    if (scope.payment_options.custom_stylesheet.match(/http/)) {
                        custom_stylesheet = scope.payment_options.custom_stylesheet;
                        // custom stylesheet as an absolute url, for ex. "http://bespoke.bookingbug.com/staging/custom-booking-widget.css"
                    } else {
                        // custom stylesheet as a file, for ex. "custom-booking-widget.css"
                        custom_stylesheet = $location.absUrl().match(/.+(?=#)/) + scope.payment_options.custom_stylesheet;
                    }
                }

                var payload = JSON.stringify({
                    'type': 'load',
                    'message': referrer,
                    'custom_partial_url': scope.bb.custom_partial_url,
                    'custom_stylesheet': custom_stylesheet,
                    'scroll_offset': GeneralOptions.scroll_offset
                });

                return element.find('iframe')[0].contentWindow.postMessage(payload, origin);
            };

            scope.payment_options = scope.$eval(attributes.bbPayment) || {};
            scope.route_to_next_page = scope.payment_options.route_to_next_page != null ? scope.payment_options.route_to_next_page : true;

            element.find('iframe').bind('load', function (event) {
                var url = void 0;
                if (scope.bb && scope.bb.total && scope.bb.total.$href('new_payment')) {
                    url = scope.bb.total.$href('new_payment');
                }
                var origin = getHost(url);
                sendLoadEvent(element, origin, scope);
                return scope.$apply(function () {
                    return scope.callSetLoaded();
                });
            });

            return $window.addEventListener('message', function (event) {
                var data = void 0;
                if (angular.isObject(event.data)) {
                    data = event.data;
                } else if (!event.data.match(/iFrameSizer/)) {
                    data = JSON.parse(event.data);
                }
                return scope.$apply(function () {
                    if (data) {
                        switch (data.type) {
                            case "submitting":
                                return scope.callNotLoaded();
                            case "error":
                                scope.$emit("payment:failed");
                                scope.callNotLoaded();
                                AlertService.raise('PAYMENT_FAILED');
                                // reload the payment iframe
                                return document.getElementsByTagName("iframe")[0].src += '';
                            case "payment_complete":
                                scope.callSetLoaded();
                                return scope.paymentDone();
                        }
                    }
                });
            }, false);
        }
    };
});
'use strict';

var BBPeopleCtrl = function BBPeopleCtrl($scope, $rootScope, $q, BBModel, PersonModel, FormDataStoreService, ValidatorService, LoadingService) {
    'ngInject';

    var new_person = void 0;
    this.$scope = $scope;

    var chosenService = null;
    var loader = null;

    var init = function init() {
        $scope.selectItem = selectItem;
        $scope.selectAndRoute = selectAndRoute;
        $scope.setReady = setReady;

        loader = LoadingService.$loader($scope).notLoaded();

        $rootScope.connection_started.then(connectionStartedSuccess, connectionStartedFailure);
        $scope.$watch('person', personListener);
        $scope.$on("currentItemUpdate", currentItemUpdateHandler);
    };

    var connectionStartedSuccess = function connectionStartedSuccess() {
        return loadData();
    };

    var connectionStartedFailure = function connectionStartedFailure(err) {
        return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
    };

    var currentItemUpdateHandler = function currentItemUpdateHandler(event) {
        return loadData();
    };

    var loadData = function loadData() {
        var bi = $scope.booking_item;

        if (!bi.service || bi.service === chosenService) {
            if (!bi.service) {
                loader.setLoaded();
            }
            return;
        }

        loader.notLoaded();

        chosenService = bi.service;

        var ppromise = BBModel.Person.$query($scope.bb.company);
        ppromise.then(function (people) {
            if (bi.group) {
                // check they're part of any currently selected group
                people = people.filter(function (x) {
                    return !x.group_id || x.group_id === bi.group;
                });
            }
            return $scope.all_people = people;
        });

        return BBModel.BookableItem.$query({
            company: $scope.bb.company,
            cItem: bi,
            wait: ppromise,
            item: 'person'
        }).then(function (items) {
            if (bi.group) {
                // check they're part of any currently selected group
                items = items.filter(function (x) {
                    return !x.group_id || x.group_id === bi.group;
                });
            }

            var promises = [];
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = Array.from(items)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var i = _step.value;

                    promises.push(i.promise);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            $q.all(promises).then(function (res) {
                var person = void 0;
                var people = [];
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = Array.from(items)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        i = _step2.value;

                        people.push(i.item);
                        if (bi && bi.person && bi.person.id === i.item.id) {
                            if ($scope.bb.current_item.settings.person !== -1) {
                                $scope.person = i.item;
                            }
                            $scope.selected_bookable_items = [i];
                        }
                    }

                    // if there's only 1 person and combine resources/staff has been turned on, auto select the person
                    // OR if the person has been passed into item_defaults, skip to next step
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }

                if (items.length === 1 && $scope.bb.company.settings && $scope.bb.company.settings.merge_people) {
                    person = items[0];
                }

                if ($scope.bb.current_item.defaults.person) {
                    person = $scope.bb.current_item.defaults.person;
                }

                if (person && !$scope.selectItem(person, $scope.nextRoute, { skip_step: true })) {
                    setPerson(people);
                    $scope.bookable_items = items;
                    $scope.selected_bookable_items = items;
                } else {
                    setPerson(people);
                    $scope.bookable_items = items;
                    if (!$scope.selected_bookable_items) {
                        $scope.selected_bookable_items = items;
                    }
                }
                return loader.setLoaded();
            }, function (err) {
                return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
            });

            return ppromise['finally'](function () {
                return loader.setLoaded();
            });
        });
    };

    // we're storing the person property in the form store but the angular select
    // menu has to have a reference to the same object memory address for it to
    // appear as selected as it's ng-model property is a Person object.
    var setPerson = function setPerson(people) {
        $scope.bookable_people = people;
        if ($scope.person) {
            return _.each(people, function (person) {
                if (person.id === $scope.person.id) {
                    return $scope.person = person;
                }
            });
        }
    };

    var getItemFromPerson = function getItemFromPerson(person) {
        if (person instanceof PersonModel) {
            if ($scope.bookable_items) {
                var _iteratorNormalCompletion3 = true;
                var _didIteratorError3 = false;
                var _iteratorError3 = undefined;

                try {
                    for (var _iterator3 = Array.from($scope.bookable_items)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                        var item = _step3.value;

                        if (item.item.self === person.self) {
                            return item;
                        }
                    }
                } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion3 && _iterator3.return) {
                            _iterator3.return();
                        }
                    } finally {
                        if (_didIteratorError3) {
                            throw _iteratorError3;
                        }
                    }
                }
            }
        }
        return person;
    };

    /**
     * @ngdoc method
     * @name selectItem
     * @methodOf BB.Directives:bbPeople
     * @description
     * Select an item into the current person list in according of item and route parameters
     *
     * @param {array} item Selected item from the list of current people
     * @param {string=} route A specific route to load
     */
    var selectItem = function selectItem(item, route, options) {
        if (options == null) {
            options = {};
        }
        if ($scope.$parent.$has_page_control) {
            $scope.person = item;
            return false;
        } else {
            new_person = getItemFromPerson(item);
            _.each($scope.booking_items, function (bi) {
                return bi.setPerson(new_person);
            });
            if (options.skip_step) {
                $scope.skipThisStep();
            }
            $scope.decideNextPage(route);
            return true;
        }
    };

    /**
     * @ngdoc method
     * @name selectAndRoute
     * @methodOf BB.Directives:bbPeople
     * @description
     * Select and route person from list in according of item and route parameters
     *
     * @param {array} item Selected item from the list of current people
     * @param {string} route A specific route to load
     */
    var selectAndRoute = function selectAndRoute(item, route) {
        new_person = getItemFromPerson(item);
        _.each($scope.booking_items, function (bi) {
            return bi.setPerson(new_person);
        });
        $scope.decideNextPage(route);
        return true;
    };

    var personListener = function personListener(newval, oldval) {
        if ($scope.person && $scope.booking_item) {
            if (!$scope.booking_item.person || $scope.booking_item.person.self !== $scope.person.self) {
                // only set and broadcast if it's changed
                new_person = getItemFromPerson($scope.person);
                _.each($scope.booking_items, function (item) {
                    return item.setPerson(new_person);
                });
                $scope.broadcastItemUpdate();
            }
        } else if (newval !== oldval) {
            _.each($scope.booking_items, function (item) {
                return item.setPerson(null);
            });
            $scope.broadcastItemUpdate();
        }

        $scope.bb.current_item.defaults.person = $scope.person;
    };

    /**
     * @ngdoc method
     * @name setReady
     * @methodOf BB.Directives:bbPeople
     * @description
     * Called by bbPage to ready directive for transition to the next step
     */
    var setReady = function setReady() {
        if ($scope.person) {
            new_person = getItemFromPerson($scope.person);
            _.each($scope.booking_items, function (item) {
                return item.setPerson(new_person);
            });
            return true;
        } else {
            _.each($scope.booking_items, function (item) {
                return item.setPerson(null);
            });
            return true;
        }
    };

    init();
};

angular.module('BB.Controllers').controller('BBPeopleCtrl', BBPeopleCtrl);
'use strict';

/**
 * @ngdoc directive
 * @name BB.Directives:bbPeople
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Loads a list of peoples for the currently in scope company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @param {BasketItem} bbItem The BasketItem that will be updated with the selected person. If no item is provided, bb.current_item is used as the default
 * @param {array} bbItems An array of BasketItem's that will be updated with the selected person.
 * @property {array} items A list of people
 * @property {array} bookable_people The bookable people from the person list
 * @property {array} bookable_items The bookable items from the person list
 * @property {array} booking_item The BasketItem used by the person list. If bbItems provided, this will be the first item
 *
 *  <example module="BB">
 *    <file name="index.html">
 *   <div bb-api-url='https://dev01.bookingbug.com'>
 *   <div  bb-widget='{company_id:37167}'>
 *     <div bb-people>
 *        <ul>
 *          <li ng-repeat='person in all_people'> {{person.name}}</li>
 *        </ul>
 *     </div>
 *     </div>
 *     </div>
 *   </file>
 *  </example>
 */
angular.module('BB.Directives').directive('bbPeople', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'BBPeopleCtrl',
        controllerAs: '$bbPeopleCtrl',
        link: function link(scope, element, attrs) {
            if (attrs.bbItems) {
                scope.booking_items = scope.$eval(attrs.bbItems) || [];
                return scope.booking_item = scope.booking_items[0];
            } else {
                scope.booking_item = scope.$eval(attrs.bbItem) || scope.bb.current_item;
                return scope.booking_items = [scope.booking_item];
            }
        }
    };
});
'use strict';

angular.module('BB.Controllers').controller('ProductList', function ($scope, $rootScope, $q, $attrs, ItemService, FormDataStoreService, ValidatorService, LoadingService) {

    var loader = LoadingService.$loader($scope).notLoaded();

    $rootScope.connection_started.then(function () {
        if ($scope.bb.company) {
            return $scope.init($scope.bb.company);
        }
    }, function (err) {
        return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
    });

    $scope.init = function (company) {
        if (!$scope.booking_item) {
            $scope.booking_item = $scope.bb.current_item;
        }

        return company.$get('products').then(function (products) {
            return products.$get('products').then(function (products) {
                $scope.products = products;
                return loader.setLoaded();
            });
        });
    };

    /***
     * @ngdoc method
     * @name selectItem
     * @methodOf BB.Directives:bbProductList
     * @description
     * Select an item from the product list in according of item and route parameter
     *
     * @param {array} item The array items
     * @param {string=} route A specific route to load
     */
    return $scope.selectItem = function (item, route) {
        if ($scope.$parent.$has_page_control) {
            $scope.product = item;
            return false;
        } else {
            $scope.booking_item.setProduct(item);
            $scope.decideNextPage(route);
            return true;
        }
    };
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbProductList
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Loads a list of product for the currently in scope company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @property {array} products The products from the list
 * @property {array} item The item of the product list
 * @property {array} booking_item The booking item
 * @property {product} product The currectly selected product
 */ //


angular.module('BB.Directives').directive('bbProductList', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'ProductList',
        link: function link(scope, element, attrs) {
            if (attrs.bbItem) {
                scope.booking_item = scope.$eval(attrs.bbItem);
            }
            if (attrs.bbShowAll) {
                scope.show_all = true;
            }
        }
    };
});
'use strict';

var BBResourcesCtrl = function BBResourcesCtrl($scope, $rootScope, $attrs, $q, BBModel, ResourceModel, ValidatorService, LoadingService) {
    'ngInject';

    var new_resource = void 0,
        resource = void 0;
    this.$scope = $scope;

    var loader = null;

    var init = function init() {
        $scope.setReady = setReady.bind(this);
        $scope.selectItem = selectItem.bind(this);

        loader = LoadingService.$loader($scope).notLoaded();

        $rootScope.connection_started.then(connectionStartedSuccess.bind(this), connectionStartedFailure.bind(this));
        $scope.$watch('resource', resourceListener.bind(this));
        $scope.$on("currentItemUpdate", currentItemUpdateHandler.bind(this));
    };

    var connectionStartedSuccess = function connectionStartedSuccess() {
        return loadData();
    };

    var connectionStartedFailure = function connectionStartedFailure(err) {
        return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
    };

    var currentItemUpdateHandler = function currentItemUpdateHandler(event) {
        return loadData();
    };

    var loadData = function loadData() {
        if (!$scope.booking_item) {
            $scope.booking_item = $scope.bb.current_item;
        }
        // do nothing if nothing has changed
        if ((!$scope.bb.steps || $scope.bb.steps[0].page !== "resource_list") && !$scope.options.resource_first) {
            if (!$scope.booking_item.service || $scope.booking_item.service === $scope.change_watch_item) {
                // if there's no service - we have to wait for one to be set - so we're done loading for now!
                if (!$scope.booking_item.service) {
                    loader.setLoaded();
                }
                return;
            }
        }

        $scope.change_watch_item = $scope.booking_item.service;
        loader.setLoaded();

        var rpromise = BBModel.Resource.$query($scope.bb.company);
        rpromise.then(function (resources) {
            if ($scope.booking_item.group) {
                // check they're part of any currently selected group
                resources = resources.filter(function (x) {
                    return !x.group_id || x.group_id === $scope.booking_item.group;
                });
            }
            return $scope.all_resources = resources;
        });

        var params = {
            company: $scope.bb.company,
            cItem: $scope.booking_item,
            wait: rpromise,
            item: 'resource'
        };
        return BBModel.BookableItem.$query(params).then(function (items) {
            var promises = [];
            if ($scope.booking_item.group) {
                // check they're part of any currently selected group
                items = items.filter(function (x) {
                    return !x.group_id || x.group_id === $scope.booking_item.group;
                });
            }

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = Array.from(items)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var i = _step.value;

                    promises.push(i.promise);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return $q.all(promises).then(function (res) {
                var resources = [];
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = Array.from(items)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        i = _step2.value;

                        resources.push(i.item);
                        if ($scope.booking_item && $scope.booking_item.resource && $scope.booking_item.resource.id === i.item.id) {
                            // set the resource unless the resource was automatically set
                            if ($scope.bb.current_item.settings.resource !== -1) {
                                $scope.resource = i.item;
                            }
                        }
                    }
                    // if there's only one resource and single pick hasn't been enabled,
                    // automatically select the resource.
                    // OR if the resource has been passed into item_defaults and single pick hasn't been enabled,, skip to next step
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }

                if (resources.length === 1) {
                    resource = items[0];
                }
                if ($scope.bb.item_defaults.resource) {
                    resource = $scope.bb.item_defaults.resource;
                }

                var selectedResource = resource && resource.item ? resource.item : resource;

                if (resource) {
                    $scope.selectItem(selectedResource, $scope.nextRoute, { skip_step: true });
                }

                $scope.bookable_resources = resources;
                $scope.bookable_items = items;

                return loader.setLoaded();
            }, function (err) {
                return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
            });
        }, function (err) {
            if (err !== "No service link found" || (!$scope.bb.steps || $scope.bb.steps[0].page !== 'resource_list') && !$scope.options.resource_first) {
                return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
            } else {
                return loader.setLoaded();
            }
        });
    };

    /**
     * @ngdoc method
     * @name getItemFromResource
     * @methodOf BB.Directives:bbResources
     * @description
     * Get item from resource in according of resource parameter
     *
     * @param {object} resource The resource
     */
    var getItemFromResource = function getItemFromResource(resource) {
        if (resource instanceof ResourceModel) {
            if ($scope.bookable_items) {
                var _iteratorNormalCompletion3 = true;
                var _didIteratorError3 = false;
                var _iteratorError3 = undefined;

                try {
                    for (var _iterator3 = Array.from($scope.bookable_items)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                        var item = _step3.value;

                        if (item.item.self === resource.self) {
                            return item;
                        }
                    }
                } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion3 && _iterator3.return) {
                            _iterator3.return();
                        }
                    } finally {
                        if (_didIteratorError3) {
                            throw _iteratorError3;
                        }
                    }
                }
            }
        }
        return resource;
    };

    /**
     * @ngdoc method
     * @name selectItem
     * @methodOf BB.Directives:bbResources
     * @description
     * Select an item into the current booking journey and route on to the next page dpending on the current page control
     *
     * @param {array} item The Service or BookableItem to select
     * @param {string=} route A specific route to load
     * @param {string=} skip_step The skip_step has been set to false
     */
    var selectItem = function selectItem(item, route, options) {
        if (options == null) {
            options = {};
        }
        if ($scope.$parent.$has_page_control) {
            $scope.resource = item;
            return false;
        } else {
            new_resource = getItemFromResource(item);
            _.each($scope.booking_items, function (item) {
                return item.setResource(new_resource);
            });
            if (options.skip_step) {
                $scope.skipThisStep();
            }
            $scope.decideNextPage(route);
            return true;
        }
    };

    var resourceListener = function resourceListener(newval, oldval) {
        if ($scope.resource && $scope.booking_item) {
            if (!$scope.booking_item.resource || $scope.booking_item.resource.self !== $scope.resource.self) {
                // only set and broadcast if it's changed
                new_resource = getItemFromResource($scope.resource);
                _.each($scope.booking_items, function (item) {
                    return item.setResource(new_resource);
                });
                return $scope.broadcastItemUpdate();
            }
        } else if (newval !== oldval) {
            _.each($scope.booking_items, function (item) {
                return item.setResource(null);
            });
            return $scope.broadcastItemUpdate();
        }
    };

    /**
     * @ngdoc method
     * @name setReady
     * @methodOf BB.Directives:bbResources
     * @description
     * Set this page section as ready
     */
    var setReady = function setReady() {
        if ($scope.resource) {
            new_resource = getItemFromResource($scope.resource);
            _.each($scope.booking_items, function (item) {
                return item.setResource(new_resource);
            });
            return true;
        } else {
            _.each($scope.booking_items, function (item) {
                return item.setResource(null);
            });
            return true;
        }
    };

    init();
};

angular.module('BB.Controllers').controller('BBResourcesCtrl', BBResourcesCtrl);
'use strict';

/**
 * @ngdoc directive
 * @name BB.Directives:bbResources
 * @restrict AE
 * @scope true
 *
 * @description
 * Loads a list of resources for the currently in scope company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @param {hash}  bbResources   A hash of options
 * @param {BasketItem} bbItem The BasketItem that will be updated with the selected resource. If no item is provided, bb.current_item is used as the default
 * @param {boolean}  waitForService   Wait for a the service to be loaded before loading Resources
 * @param {boolean}  hideDisabled   In an admin widget, disabled resources are shown by default, you can choose to hide disabled resources
 * @property {array} booking_item The current basket item being referred to
 * @property {array} all_resources An array of all resources
 * @property {array} bookable_items An array of all BookableItems - used if the current_item has already selected a services or person
 * @property {array} bookable_resources An array of Resources - used if the current_item has already selected a services or person
 * @property {resource} resource The currectly selected resource
 *
 *  <example module="BB">
 *    <file name="index.html">
 *   <div bb-api-url='https://dev01.bookingbug.com'>
 *   <div  bb-widget='{company_id:37167}'>
 *     <div bb-resources>
 *        <ul>
 *          <li ng-repeat='resource in all_resources'> {{resource.name}}</li>
 *        </ul>
 *     </div>
 *     </div>
 *     </div>
 *   </file>
 *  </example>
 *
 */

angular.module('BB.Directives').directive('bbResources', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'BBResourcesCtrl',
        controllerAs: '$bbResourcesCtrl',
        link: function link(scope, element, attrs) {
            scope.options = scope.$eval(attrs.bbResources) || {};
            if (attrs.bbItems) {
                scope.booking_items = scope.$eval(attrs.bbItems) || [];
                return scope.booking_item = scope.booking_items[0];
            } else {
                scope.booking_item = scope.$eval(attrs.bbItem) || scope.bb.current_item;
                return scope.booking_items = [scope.booking_item];
            }
        }
    };
});
'use strict';

var BBServicesCtrl = function BBServicesCtrl($scope, $rootScope, $q, $attrs, $uibModal, $document, BBModel, FormDataStoreService, ValidatorService, ErrorService, $filter, LoadingService) {
    'ngInject';

    this.$scope = $scope;

    FormDataStoreService.init('ServiceList', $scope, ['service']);

    var loader = LoadingService.$loader($scope).notLoaded();

    $scope.filters = {
        category_name: null,
        service_name: null,
        price: {
            min: 0,
            max: 100
        },
        custom_array_value: null
    };
    $scope.show_custom_array = false;

    $scope.options = $scope.$eval($attrs.bbServices) || {};

    if ($attrs.bbItem) {
        $scope.booking_item = $scope.$eval($attrs.bbItem);
    }
    if ($attrs.bbShowAll || $scope.options.show_all) {
        $scope.show_all = true;
    }
    if ($scope.options.allow_single_pick) {
        $scope.allowSinglePick = true;
    }
    if ($scope.options.hide_disabled) {
        $scope.hide_disabled = true;
    }

    $scope.price_options = {
        min: 0,
        max: 100
    };

    $rootScope.connection_started.then(function () {
        if ($scope.bb.company) {
            return $scope.init($scope.bb.company);
        }
    }, function (err) {
        return loader.setLoadedAndShowError($scope, err, 'Sorry, something went wrong');
    });

    $scope.init = function (comp) {
        var item = void 0;
        if (!$scope.booking_item) {
            $scope.booking_item = $scope.bb.current_item;
        }

        if ($scope.bb.company.$has('named_categories')) {
            BBModel.Category.$query($scope.bb.company).then(function (items) {
                return $scope.all_categories = items;
            }, function (err) {
                return $scope.all_categories = [];
            });
        } else {
            $scope.all_categories = [];
        }

        // check any curretn service is valid for the current company
        if ($scope.service && $scope.service.company_id !== $scope.bb.company.id) {
            $scope.service = null;
        }

        var ppromise = comp.$getServices();

        var all_loaded = [ppromise];

        ppromise.then(function (items) {
            if ($scope.options.hide_disabled) {
                // this might happen to ahve been an admin api call which would include disabled services - and we migth to hide them
                items = items.filter(function (x) {
                    return !x.disabled && !x.deleted;
                });
            }

            // not all service lists need filtering. check for attribute first
            var filterItems = $attrs.filterServices === 'false' ? false : true;

            if (filterItems) {
                if ($scope.booking_item.service_ref && !$scope.options.show_all) {
                    items = items.filter(function (x) {
                        return x.api_ref === $scope.booking_item.service_ref;
                    });
                } else if ($scope.booking_item.category && !$scope.options.show_all) {
                    // if we've selected a category for the current item - limit the list
                    // of services to ones that are relevant
                    items = items.filter(function (x) {
                        return x.$has('category') && x.$href('category') === $scope.booking_item.category.self;
                    });
                }
            }

            // filter out event groups unless explicity requested
            if (!$scope.options.show_event_groups) {
                items = items.filter(function (x) {
                    return !x.is_event_group;
                });
            }

            // if there's only one service and single pick hasn't been enabled,
            // automatically select the service.
            if (items.length === 1 && !$scope.options.allow_single_pick) {
                if (!$scope.selectItem(items[0], $scope.nextRoute, {
                    skip_step: true
                })) {
                    setServiceItem(items);
                }
            } else {
                setServiceItem(items);
            }

            // if there's a default - pick it and move on
            if ($scope.booking_item.defaultService()) {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Array.from(items)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        item = _step.value;

                        if (item.self === $scope.booking_item.defaultService().self || item.name === $scope.booking_item.defaultService().name && !item.deleted) {
                            $scope.selectItem(item, $scope.nextRoute, {
                                skip_step: true
                            });
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }

            // if there's one selected - just select it
            if ($scope.booking_item.service) {
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = Array.from(items)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        item = _step2.value;

                        item.selected = false;
                        if (item.self === $scope.booking_item.service.self) {
                            $scope.service = item;
                            item.selected = true;
                            $scope.booking_item.setService($scope.service);
                        }
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }
            }

            if ($scope.booking_item.service || !($scope.booking_item.person && !$scope.booking_item.anyPerson() || $scope.booking_item.resource && !$scope.booking_item.anyResource())) {
                // the "bookable services" are the service unless we've pre-selected something!
                items = setServicesDisplayName(items);
                return $scope.bookable_services = items;
            }
        }, function (err) {
            return loader.setLoadedAndShowError($scope, err, 'Sorry, something went wrong');
        });

        if ($scope.booking_item.person && !$scope.booking_item.anyPerson() || $scope.booking_item.resource && !$scope.booking_item.anyResource()) {
            // if we've already picked a service or a resource - get a more limited service selection
            var ispromise = BBModel.BookableItem.$query({
                company: $scope.bb.company,
                cItem: $scope.booking_item,
                wait: ppromise,
                item: 'service'
            });
            all_loaded.push(ispromise);
            ispromise.then(function (items) {
                if ($scope.booking_item.service_ref) {
                    items = items.filter(function (x) {
                        return x.api_ref === $scope.booking_item.service_ref;
                    });
                }
                if ($scope.booking_item.group) {
                    items = items.filter(function (x) {
                        return !x.group_id || x.group_id === $scope.booking_item.group;
                    });
                }

                if ($scope.options.hide_disabled) {
                    // this might happen to ahve been an admin api call which would include disabled services - and we migth to hide them
                    items = items.filter(function (x) {
                        return x.item == null || !x.item.disabled && !x.item.deleted;
                    });
                }

                var services = Array.from(items).filter(function (i) {
                    return i.item != null;
                }).map(function (i) {
                    return i.item;
                });

                services = setServicesDisplayName(services);

                $scope.bookable_services = services;

                $scope.bookable_items = items;

                if (services.length === 1 && !$scope.options.allow_single_pick) {
                    if (!$scope.selectItem(services[0], $scope.nextRoute, {
                        skip_step: true
                    })) {
                        return setServiceItem(services);
                    }
                } else {
                    // The ServiceModel is more relevant than the BookableItem when price and duration needs to be listed in the view pages.
                    return setServiceItem(services);
                }
            }, function (err) {
                return loader.setLoadedAndShowError($scope, err, 'Sorry, something went wrong');
            });
        }

        return $q.all(all_loaded).then(function () {
            return loader.setLoaded();
        });
    };

    var setServicesDisplayName = function setServicesDisplayName(items) {
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
            for (var _iterator3 = Array.from(items)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var item = _step3.value;

                if (item.listed_durations && item.listed_durations.length === 1) {
                    item.display_name = item.name + ' - ' + $filter('time_period')(item.duration);
                } else {
                    item.display_name = item.name;
                }
            }
        } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                    _iterator3.return();
                }
            } finally {
                if (_didIteratorError3) {
                    throw _iteratorError3;
                }
            }
        }

        return items;
    };

    // set the service item so the correct item is displayed in the dropdown menu.
    // without doing this the menu will default to 'please select'
    var setServiceItem = function setServiceItem(items) {
        $scope.items = items;
        $scope.filtered_items = $scope.items;
        if ($scope.service) {
            return _.each(items, function (item) {
                if (item.id === $scope.service.id) {
                    return $scope.service = item;
                }
            });
        }
    };

    /***
     * @ngdoc method
     * @name selectItem
     * @methodOf BB.Directives.bbServices
     * @description
     * Select an item into the current booking journey and route on to the next page dpending on the current page control
     *
     * @param {object} item The Service or BookableItem to select
     * @param {string=} route A specific route to load
     */
    $scope.selectItem = function (item, route, options) {

        if (options == null) {
            options = {};
        }
        if ($scope.routed) {
            return true;
        }

        if ($scope.$parent.$has_page_control) {
            $scope.service = item;
            return false;
        } else if (item.is_event_group) {
            $scope.booking_item.setEventGroup(item);
            if (options.skip_step) {
                $scope.skipThisStep();
            }
            $scope.decideNextPage(route);
            return $scope.routed = true;
        } else {
            $scope.booking_item.setService(item);
            // -----------------------------------------------------------
            // Only set bb.selected_service if the service is a parent service
            if (!$scope.booking_item.service.child_level_service) $scope.bb.selected_service = $scope.booking_item.service;
            // -----------------------------------------------------------
            if (options.skip_step) {
                $scope.skipThisStep();
            }
            $scope.decideNextPage(route);
            $scope.routed = true;
            return true;
        }
    };

    $scope.$watch('service', function (newval, oldval) {
        if ($scope.service && $scope.booking_item) {
            if (!$scope.booking_item.service || $scope.booking_item.service.self !== $scope.service.self) {
                // only set and broadcast if it's changed
                $scope.booking_item.setService($scope.service);
                $scope.broadcastItemUpdate();
                // -----------------------------------------------------------
                // Only set bb.selected_service if the service is a parent service
                if (!$scope.service.child_level_service) $scope.bb.selected_service = $scope.service;
                // -----------------------------------------------------------
                return;
            }
        }
    });

    /***
     * @ngdoc method
     * @name setReady
     * @methodOf BB.Directives.bbServices
     * @description
     * Set this page section as ready - see {@link BB.Directives:bbPage Page Control}
     */
    $scope.setReady = function () {
        if ($scope.service) {
            $scope.booking_item.setService($scope.service);
            return true;
        } else if ($scope.bb.stacked_items && $scope.bb.stacked_items.length > 0) {
            return true;
        } else {
            return false;
        }
    };

    /***
     * @ngdoc method
     * @name errorModal
     * @methodOf BB.Directives.bbServices
     * @description
     * Display error message in modal
     */
    $scope.errorModal = function () {
        return $uibModal.open({
            templateUrl: $scope.getPartial('_error_modal'),
            controller: function controller($scope, $uibModalInstance) {
                $scope.message = ErrorService.getError('GENERIC').msg;
                return $scope.ok = function () {
                    return $uibModalInstance.close();
                };
            }
        });
    };

    /***
     * @ngdoc method
     * @name filterFunction
     * @methodOf BB.Directives.bbServices
     * @description
     * Filter service
     */
    $scope.filterFunction = function (service) {
        if (!service) {
            return false;
        }
        $scope.service_array = [];
        $scope.custom_array = function (match) {
            if (!match) {
                return false;
            }
            if ($scope.options.custom_filter) {
                match = match.toLowerCase();
                var _iteratorNormalCompletion4 = true;
                var _didIteratorError4 = false;
                var _iteratorError4 = undefined;

                try {
                    for (var _iterator4 = Array.from(service.extra[$scope.options.custom_filter])[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                        var item = _step4.value;

                        item = item.toLowerCase();
                        if (item === match) {
                            $scope.show_custom_array = true;
                            return true;
                        }
                    }
                } catch (err) {
                    _didIteratorError4 = true;
                    _iteratorError4 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion4 && _iterator4.return) {
                            _iterator4.return();
                        }
                    } finally {
                        if (_didIteratorError4) {
                            throw _iteratorError4;
                        }
                    }
                }

                return false;
            }
        };
        $scope.service_name_include = function (match) {
            if (!match) {
                return false;
            }
            if (match) {
                match = match.toLowerCase();
                var item = service.name.toLowerCase();
                if (item.includes(match)) {
                    return true;
                } else {
                    return false;
                }
            }
        };
        return (!$scope.filters.category_name || service.category_id === $scope.filters.category_name.id) && (!$scope.filters.service_name || $scope.service_name_include($scope.filters.service_name)) && (!$scope.filters.custom_array_value || $scope.custom_array($scope.filters.custom_array_value)) && (!service.price || service.price >= $scope.filters.price.min * 100 && service.price <= $scope.filters.price.max * 100);
    };

    /***
     * @ngdoc method
     * @name resetFilters
     * @methodOf BB.Directives.bbServices
     * @description
     * Clear the filters
     */
    $scope.resetFilters = function () {
        if ($scope.options.clear_results) {
            $scope.show_custom_array = false;
        }
        $scope.filters.category_name = null;
        $scope.filters.service_name = null;
        $scope.filters.price.min = 0;
        $scope.filters.price.max = 100;
        $scope.filters.custom_array_value = null;
        return $scope.filterChanged();
    };

    /***
     * @ngdoc method
     * @name filterChanged
     * @methodOf BB.Directives.bbServices
     * @description
     * Filter changed
     */
    $scope.filterChanged = function () {
        return $scope.filtered_items = $filter('filter')($scope.items, $scope.filterFunction);
    };
};

angular.module('BB.Controllers').controller('BBServicesCtrl', BBServicesCtrl);
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives.bbServices
 * @restrict AE
 * @scope true
 *
 * @description Loads a list of services for the currently in scroe company
 *
 *
 * @param {hash}  bbServices   A hash of options
 * @param {boolean}  allowSinglePick   By default if there is only one service, it will be selected and routed, however you can force with directive to stop and show even if there is only a single service
 * @param {boolean}  hideDisabled   IN an admin widget, disabled services are shown by default, you can choose to hide disabled services
 * @param {boolean}  bbShowAll   Show all services even if the current basket item pre-selects a service or category
 * @property {array} all_services An array of all services
 * @property {array} filtered_items A filtered list according to a filter setting
 * @property {array} bookable_items An array of all BookableItems - used if the current_item has already selected a resource or person
 * @property {array} bookable_services An array of Services - used if the current_item has already selected a resource or person
 * @property {service} service The currectly selected service
 * @property {hash} filters A hash of filters
 *
 *
 */

/*
 *  <doc:example module="BB.Directives.bbServices">
 *    <doc:source>
 *      <div bb-api-url='https://dev01.bookingbug.com'>
 *       <div bb-widget='{company_id:37167}'>
 *        <div bb-services>
 *          <ul>
 *           <li ng-repeat='service in all_services'> {{service.name}}</li>
 *          </ul>
 *        </div>
 *       </div>
 *     </div>
 *    </doc:source>
 *
 *  </doc:example>
 *
 */ //


angular.module('BB.Directives').directive('bbServices', function ($q, $compile, $templateCache) {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        transclude: true,
        controller: 'BBServicesCtrl',
        controllerAs: '$bbServicesCtrl',
        link: function link(scope, element, attrs, ctrls, transclude) {

            scope.directives = "public.ServiceList";

            return transclude(scope, function (clone) {

                // if there's content compile that or grab the _services template
                var has_content = clone.length > 1 || clone.length === 1 && (!clone[0].wholeText || /\S/.test(clone[0].wholeText));

                if (has_content) {
                    return element.html(clone).show();
                } else {
                    return $q.when($templateCache.get('_services.html')).then(function (template) {
                        element.html(template).show();
                        return $compile(element.contents())(scope);
                    });
                }
            });
        }
    };
});
'use strict';

angular.module('BB.Controllers').controller('SpaceList', function ($scope, $rootScope, $q, ServiceService, LoadingService, BBModel) {

    var loader = LoadingService.$loader($scope);

    $rootScope.connection_started.then(function () {
        if ($scope.bb.company) {
            return $scope.init($scope.bb.company);
        }
    }, function (err) {
        return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
    });

    $scope.init = function (comp) {
        return BBModel.Space.$query(comp).then(function (items) {
            if ($scope.currentItem.category) {
                // if we've selected a category for the current item - limit the list of servcies to ones that are relevant
                items = items.filter(function (x) {
                    return x.$has('category') && x.$href('category') === $scope.currentItem.category.self;
                });
            }
            $scope.items = items;
            if (items.length === 1 && !$scope.allowSinglePick) {
                $scope.skipThisStep();
                $rootScope.services = items;
                return $scope.selectItem(items[0], $scope.nextRoute);
            } else {
                return $scope.listLoaded = true;
            }
        }, function (err) {
            return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
        });
    };

    /***
     * @ngdoc method
     * @name selectItem
     * @methodOf BB.Directives:bbSpaces
     * @description
     * Select the current item in according of item and route parameters
     *
     * @param {array} item The Space or BookableItem to select
     * @param {string=} route A specific route to load
     */
    return $scope.selectItem = function (item, route) {
        $scope.currentItem.setService(item);
        return $scope.decide_next_page(route);
    };
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbSpaces
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Loads a list of spaces for the currently in scope company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @property {array} items An array of all services
 * @property {space} space The currectly selected space
 */

angular.module('BB.Directives').directive('bbSpaces', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'SpaceList'
    };
});
'use strict';

angular.module('BB.Controllers').controller('Summary', function ($scope, $rootScope, LoadingService, BBModel, $q) {

    $rootScope.connection_started.then(function () {
        $scope.item = $scope.bb.current_item;
        return $scope.items = $scope.bb.basket.timeItems();
    });

    /***
     * @ngdoc method
     * @name confirm
     * @methodOf BB.Directives:bbSummary
     * @description
     * Submits the client and BasketItem to the API
     */
    return $scope.confirm = function () {

        var loader = LoadingService.$loader($scope).notLoaded();

        var promises = [BBModel.Client.$create_or_update($scope.bb.company, $scope.client)];

        if ($scope.bb.current_item.service) {
            promises.push($scope.addItemToBasket());
        }

        return $q.all(promises).then(function (result) {
            var client = result[0];
            $scope.setClient(client);

            if (client.waitingQuestions) {
                client.gotQuestions.then(function () {
                    return $scope.client_details = client.client_details;
                });
            }

            loader.setLoaded();
            return $scope.decideNextPage();
        }, function (err) {
            return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
        });
    };
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbSummary
 * @restrict AE
 * @scope true
 *
 * @description
 * Loads a summary of the booking
 *
 *
 */ //


angular.module('BB.Directives').directive('bbSummary', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'Summary'
    };
});
'use strict';

angular.module('BB.Controllers').controller('SurveyQuestions', function ($scope, $rootScope, $location, BBModel, ValidatorService, $sessionStorage) {

    var auth_token = void 0,
        getBookingAndSurvey = void 0,
        params = void 0;
    $scope.completed = false;
    $scope.login = { email: "", password: "" };
    $scope.login_error = false;
    $scope.booking_ref = "";

    var loader = LoadingService.$loader($scope).notLoaded();

    $rootScope.connection_started.then(function () {
        return init();
    }, function (err) {
        return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
    });

    var init = function init() {
        if ($scope.company) {
            if ($scope.company.settings.requires_login) {
                $scope.checkIfLoggedIn();
                if ($rootScope.member) {
                    return getBookingAndSurvey();
                } else {
                    return;
                }
            } else {
                return getBookingAndSurvey();
            }
        }
    };

    /***
     * @ngdoc method
     * @name checkIfLoggedIn
     * @methodOf BB.Directives:bbSurveyQuestions
     * @description
     * Check if logged in
     */
    $scope.checkIfLoggedIn = function () {
        return BBModel.Login.$checkLogin();
    };

    /***
     * @ngdoc method
     * @name loadSurvey
     * @methodOf BB.Directives:bbSurveyQuestions
     * @description
     * Load Survey in according of purchase parameter
     *
     * @param {array} purchase The purchase
     */
    $scope.loadSurvey = function (purchase) {
        if (!$scope.company) {
            $scope.purchase.$get('company').then(function (company) {
                return setPurchaseCompany(company);
            });
        }

        if ($scope.purchase.$has('client')) {
            $scope.purchase.$get('client').then(function (client) {
                return $scope.setClient(new BBModel.Client(client));
            });
        }

        return $scope.purchase.$getBookings().then(function (bookings) {
            params = {};
            $scope.bookings = bookings;
            return function () {
                var result = [];
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = Array.from($scope.bookings)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var booking = _step.value;

                        if (booking.datetime) {
                            booking.pretty_date = moment(booking.datetime).format("dddd, MMMM Do YYYY");
                        }
                        if (booking.address) {
                            var address = new BBModel.Address(booking.address);
                            var pretty_address = address.addressSingleLine();
                            booking.pretty_address = pretty_address;
                        }
                        if ($rootScope.user) {
                            params.admin_only = true;
                        }
                        result.push(booking.$get("survey_questions", params).then(function (details) {
                            var item_details = new BBModel.ItemDetails(details);
                            booking.survey_questions = item_details.survey_questions;
                            return booking.$getSurveyAnswers().then(function (answers) {
                                booking.survey_answers = answers;
                                var _iteratorNormalCompletion2 = true;
                                var _didIteratorError2 = false;
                                var _iteratorError2 = undefined;

                                try {
                                    for (var _iterator2 = Array.from(booking.survey_questions)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                        var question = _step2.value;

                                        if (booking.survey_answers) {
                                            var _iteratorNormalCompletion3 = true;
                                            var _didIteratorError3 = false;
                                            var _iteratorError3 = undefined;

                                            try {
                                                for (var _iterator3 = Array.from(booking.survey_answers)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                                                    var answer = _step3.value;

                                                    if (answer.question_text === question.name && answer.value) {
                                                        question.answer = answer.value;
                                                    }
                                                }
                                            } catch (err) {
                                                _didIteratorError3 = true;
                                                _iteratorError3 = err;
                                            } finally {
                                                try {
                                                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                                                        _iterator3.return();
                                                    }
                                                } finally {
                                                    if (_didIteratorError3) {
                                                        throw _iteratorError3;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } catch (err) {
                                    _didIteratorError2 = true;
                                    _iteratorError2 = err;
                                } finally {
                                    try {
                                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                            _iterator2.return();
                                        }
                                    } finally {
                                        if (_didIteratorError2) {
                                            throw _iteratorError2;
                                        }
                                    }
                                }

                                return loader.setLoaded();
                            });
                        }));
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                return result;
            }();
        }, function (err) {
            loader.setLoaded();
            return failMsg();
        });
    };

    /***
     * @ngdoc method
     * @name submitSurveyLogin
     * @methodOf BB.Directives:bbSurveyQuestions
     * @description
     * Submit survey login in according of form parameter else display an error message
     *
     * @param {object} form The survey login form
     */
    $scope.submitSurveyLogin = function (form) {
        if (!ValidatorService.validateForm(form)) {
            return;
        }
        params = {
            email: $scope.login.email,
            password: $scope.login.password,
            id: $scope.company_id
        };
        return BBModel.Login.$companyLogin($scope.company, {}, params).then(function (member) {
            BBModel.Login.$setLogin(member);
            return getBookingAndSurvey();
        }, function (err) {
            showLoginError();
            return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
        });
    };

    /***
     * @ngdoc method
     * @name loadSurveyFromPurchaseID
     * @methodOf BB.Directives:bbSurveyQuestions
     * @description
     * Load survey from purchase id in according of id parameter else display an error message
     *
     * @param {object} id The id of purchase
     */
    $scope.loadSurveyFromPurchaseID = function (id) {
        params = { purchase_id: id, url_root: $scope.bb.api_url };
        auth_token = $sessionStorage.getItem('auth_token');
        if (auth_token) {
            params.auth_token = auth_token;
        }
        return BBModel.Purchase.Total.$query(params).then(function (purchase) {
            $scope.purchase = purchase;
            $scope.total = $scope.purchase;
            return $scope.loadSurvey($scope.purchase);
        }, function (err) {
            return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
        });
    };

    /***
     * @ngdoc method
     * @name loadSurveyFromBookingRef
     * @methodOf BB.Directives:bbSurveyQuestions
     * @description
     * Load survey from booking ref in according of id else display an error message
     *
     * @param {object} id The id of booking
     */
    $scope.loadSurveyFromBookingRef = function (id) {
        params = { booking_ref: id, url_root: $scope.bb.api_url, raw: true };
        auth_token = $sessionStorage.getItem('auth_token');
        if (auth_token) {
            params.auth_token = auth_token;
        }
        return BBModel.Purchase.Total.$bookingRefQuery(params).then(function (purchase) {
            $scope.purchase = purchase;
            $scope.total = $scope.purchase;
            return $scope.loadSurvey($scope.purchase);
        }, function (err) {
            showLoginError();
            return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
        });
    };

    /***
     * @ngdoc method
     * @name submitSurvey
     * @methodOf BB.Directives:bbSurveyQuestions
     * @description
     * Submit survey in according of form parameter
     *
     * @param {object} form The survey form
     */
    $scope.submitSurvey = function (form) {
        if (!ValidatorService.validateForm(form)) {
            return;
        }
        return Array.from($scope.bookings).map(function (booking) {
            return booking.checkReady(), booking.ready ? (loader.notLoaded(), booking.client_id = $scope.client.id, params = booking, BBModel.Purchase.Booking.$addSurveyAnswersToBooking(params).then(function (booking) {
                loader.setLoaded();
                return $scope.completed = true;
            }, function (err) {
                return loader.setLoaded();
            })) : $scope.decideNextPage(route);
        });
    };

    /***
     * @ngdoc method
     * @name submitBookingRef
     * @methodOf BB.Directives:bbSurveyQuestions
     * @description
     * Submit booking in according of form parameter
     *
     * @param {object} form The submit booking form
     */
    $scope.submitBookingRef = function (form) {
        if (!ValidatorService.validateForm(form)) {
            return;
        }
        loader.notLoaded();
        params = { booking_ref: $scope.booking_ref, url_root: $scope.bb.api_url, raw: true };
        auth_token = $sessionStorage.getItem('auth_token');
        if (auth_token) {
            params.auth_token = auth_token;
        }
        return BBModel.Purchase.Total.$bookingRefQuery(params).then(function (purchase) {
            $scope.purchase = purchase;
            $scope.total = $scope.purchase;
            return $scope.loadSurvey($scope.purchase);
        }, function (err) {
            showLoginError();
            return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
        });
    };

    /***
     * @ngdoc method
     * @name storeBookingCookie
     * @methodOf BB.Directives:bbSurveyQuestions
     * @description
     * Store booking cookie
     */
    $scope.storeBookingCookie = function () {
        return document.cookie = 'bookingrefsc=' + $scope.booking_ref;
    };

    /***
     * @ngdoc method
     * @name showLoginError
     * @methodOf BB.Directives:bbSurveyQuestions
     * @description
     * Show login error
     */
    var showLoginError = function showLoginError() {
        return $scope.login_error = true;
    };

    /***
     * @ngdoc method
     * @name setPurchaseCompany
     * @methodOf BB.Directives:bbSurveyQuestions
     * @description
     * Set purchase company in according of company parameter
     *
     * @param {object} company The company
     */
    var setPurchaseCompany = function setPurchaseCompany(company) {
        $scope.bb.company_id = company.id;
        $scope.bb.company = new BBModel.Company(company);
        $scope.company = $scope.bb.company;
        $scope.bb.item_defaults.company = $scope.bb.company;
        if (company.settings) {
            if (company.settings.merge_resources) {
                $scope.bb.item_defaults.merge_resources = true;
            }
            if (company.settings.merge_people) {
                return $scope.bb.item_defaults.merge_people = true;
            }
        }
    };

    /***
     * @ngdoc method
     * @name getBookingRef
     * @methodOf BB.Directives:bbSurveyQuestions
     * @description
     * Get booking references
     */
    var getBookingRef = function getBookingRef() {
        var booking_ref = void 0;
        var matches = /^.*(?:\?|&)booking_ref=(.*?)(?:&|$)/.exec($location.absUrl());
        if (matches) {
            booking_ref = matches[1];
        }
        return booking_ref;
    };

    /***
     * @ngdoc method
     * @name getPurchaseID
     * @methodOf BB.Directives:bbSurveyQuestions
     * @description
     * Get purchase Id
     */
    var getPurchaseID = function getPurchaseID() {
        var purchase_id = void 0;
        var matches = /^.*(?:\?|&)id=(.*?)(?:&|$)/.exec($location.absUrl());
        if (matches) {
            purchase_id = matches[1];
        }
        return purchase_id;
    };

    /***
     * @ngdoc method
     * @name getBookingAndSurvey
     * @methodOf BB.Directives:bbSurveyQuestions
     * @description
     * Get booking and survey
     */
    return getBookingAndSurvey = function getBookingAndSurvey() {
        var id = getBookingRef();
        if (id) {
            return $scope.loadSurveyFromBookingRef(id);
        } else {
            id = getPurchaseID();
            if (id) {
                return $scope.loadSurveyFromPurchaseID(id);
            } else {
                if ($scope.bb.total) {
                    return $scope.loadSurveyFromPurchaseID($scope.bb.total.long_id);
                } else {
                    return;
                }
            }
        }
    };
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives:bbSurveyQuestions
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Loads a list of survey questions for the currently in scope company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @property {integer} company_id The company id
 * @property {array} questions An array with questions
 * @property {object} validator The validator service - see {@link BB.Services:Validator Validator Service}
 * @property {object} widget The widget service - see {@link BB.Models:BBWidget Widget Service}
 * @property {object} alert The alert service - see {@link BB.Services:Alert Alert Service}
 */ //

angular.module('BB.Directives').directive('bbSurveyQuestions', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'SurveyQuestions'
    };
});
'use strict';

function bbTimeRangeStackedController($scope, $element, $attrs, $rootScope, $q, TimeService, AlertService, BBModel, FormDataStoreService, PersonService, PurchaseService, DateTimeUtilitiesService, LoadingService, TimeSlotPermutationService) {

    var loader = void 0;

    this.$onInit = function () {
        FormDataStoreService.init('TimeRangeListStacked', $scope, ['selected_slot', 'original_start_date', 'start_at_week_start']);

        loader = LoadingService.$loader($scope).notLoaded();

        $rootScope.connection_started.then(function () {
            initScopeVariables();
            initTimeRange();
            $scope.loadData();
        });
    };

    /***
     * @ngdoc method
     * @name initScopeVariables
     * @methodOf BB.Directives.bbTimeRangeStacked
     * @description
     * Initialises options, time_range_length, day_of_week and selected_day
     */
    var initScopeVariables = function initScopeVariables() {
        $scope.available_times = 0;

        var selected_day = void 0;
        $scope.options = $scope.$eval($attrs.bbTimeRangeStacked) || {};
        $scope.options.ignore_min_advance_datetime = $scope.options.ignore_min_advance_datetime ? true : false;

        if (!$scope.time_range_length) {
            if ($attrs.bbTimeRangeLength != null) {
                $scope.time_range_length = $scope.$eval($attrs.bbTimeRangeLength);
            } else if ($scope.options && $scope.options.time_range_length) {
                $scope.time_range_length = $scope.options.time_range_length;
            } else {
                $scope.time_range_length = 7;
            }
        }

        if ($attrs.bbDayOfWeek != null || $scope.options && $scope.options.day_of_week) {
            $scope.day_of_week = $attrs.bbDayOfWeek != null ? $scope.$eval($attrs.bbDayOfWeek) : $scope.options.day_of_week;
        }

        if ($attrs.bbSelectedDay != null || $scope.options && $scope.options.selected_day) {
            selected_day = $attrs.bbSelectedDay != null ? moment($scope.$eval($attrs.bbSelectedDay)) : moment($scope.options.selected_day);
            if (moment.isMoment(selected_day)) {
                $scope.selected_day = selected_day;
            }
        }
    };

    /***
     * @ngdoc method
     * @name initTimeRange
     * @methodOf BB.Directives.bbTimeRangeStacked
     * @description
     * Sets the time range based on stacked items / selected date
     */
    var initTimeRange = function initTimeRange() {
        // initialise the time range
        // last selected day is set (i.e, a user has already selected a date)
        if (!$scope.start_date && $scope.last_selected_date) {
            if ($scope.original_start_date) {
                var diff = $scope.last_selected_date.diff($scope.original_start_date, 'days');
                diff = diff % $scope.time_range_length;
                diff = diff === 0 ? diff : diff + 1;
                var start_date = $scope.last_selected_date.clone().subtract(diff, 'days');
                setTimeRange($scope.last_selected_date, start_date);
            } else {
                setTimeRange($scope.last_selected_date);
            }
            // the current item already has a date
        } else if ($scope.bb.stacked_items[0].date) {
            setTimeRange($scope.bb.stacked_items[0].date.date);
            // selected day has been provided, use this to set the time
        } else if ($scope.selected_day) {
            $scope.original_start_date = $scope.original_start_date || moment($scope.selected_day);
            setTimeRange($scope.selected_day);
            // set the time range as today
        } else {
            $scope.start_at_week_start = true;
            setTimeRange(moment());
        }
    };

    /***
     * @ngdoc method
     * @name setTimeRange
     * @methodOf BB.Directives.bbTimeRangeStacked
     * @description
     * Set time range in according of selected_date
     *
     * @param {date} selected_date The selected date from multi time range list
     * @param {date} start_date The start date of range list
     */
    var setTimeRange = function setTimeRange(selected_date, start_date) {
        if (start_date) {
            $scope.start_date = start_date;
        } else if ($scope.day_of_week) {
            $scope.start_date = selected_date.clone().day($scope.day_of_week);
        } else if ($scope.start_at_week_start) {
            $scope.start_date = selected_date.clone().startOf('week');
        } else {
            $scope.start_date = selected_date.clone();
        }

        $scope.selected_day = selected_date;
        // convert selected day to JS date object for date picker, it needs
        // to be saved as a variable as functions cannot be passed into the
        // AngluarUI date picker
        $scope.selected_date = $scope.selected_day.toDate();

        isSubtractValid();

        isAddValid();
    };

    /***
     * @ngdoc method
     * @name add
     * @methodOf BB.Directives.bbTimeRangeStacked
     * @description
     * Add date
     *
     * @param {object} amount The selected amount
     * @param {array} type The start type
     */
    $scope.add = function (amount, type) {
        $scope.selected_day = moment($scope.selected_date);
        switch (type) {
            case 'days':
                setTimeRange($scope.selected_day.add(amount, 'days'));
                break;
            case 'weeks':
                $scope.start_date.add(amount, 'weeks');
                setTimeRange($scope.start_date);
                break;
        }
        return $scope.loadData();
    };

    /***
     * @ngdoc method
     * @name subtract
     * @methodOf BB.Directives.bbTimeRangeStacked
     * @description
     * Subtract in according of amount and type parameters
     *
     * @param {object} amount The selected amount
     * @param {object} type The start type
     */
    $scope.subtract = function (amount, type) {
        return $scope.add(-amount, type);
    };

    /***
     * @ngdoc method
     * @name isSubtractValid
     * @methodOf BB.Directives.bbTimeRangeStacked
     * @description
     * Verify if the subtract is valid or not
     */
    var isSubtractValid = function isSubtractValid() {
        $scope.is_subtract_valid = true;

        var diff = Math.ceil($scope.selected_day.diff(moment(), 'day', true));
        $scope.subtract_length = diff < $scope.time_range_length ? diff : $scope.time_range_length;
        if (diff <= 0) {
            $scope.is_subtract_valid = false;
        }

        if ($scope.subtract_length > 1) {
            return $scope.subtract_string = 'Prev ' + $scope.subtract_length + ' days';
        } else if ($scope.subtract_length === 1) {
            return $scope.subtract_string = "Prev day";
        } else {
            return $scope.subtract_string = "Prev";
        }
    };

    /***
     * @ngdoc method
     * @name isAddValid
     * @methodOf BB.Directives.bbTimeRangeStacked
     * @description
     * Use to determine if addition of the time range is valid (i.e. it's not more than the max days in advance)
     *
     */
    var isAddValid = function isAddValid() {
        $scope.is_add_valid = true;

        if (!$scope.isAdmin() && !$scope.options.ignore_max_advance_datetime && $scope.max_date) {
            var max_date = $scope.max_date.clone();
            var selected_day = $scope.selected_day.clone();
            var difference = max_date.startOf('day').diff(selected_day.startOf('day'), 'days', true);
            if (difference - $scope.time_range_length < 0) {
                return $scope.is_add_valid = false;
            }
        }
    };

    /***
     * @ngdoc method
     * @name selectedDateChanged
     * @methodOf BB.Directives.bbTimeRangeStacked
     * @description
     * Called on datepicker date change
     */
    // called on datepicker date change
    $scope.selectedDateChanged = function () {
        setTimeRange(moment($scope.selected_date));
        $scope.selected_slot = null;
        return $scope.loadData();
    };

    /***
     * @ngdoc method
     * @name updateHideStatus
     * @methodOf BB.Directives.bbTimeRangeStacked
     * @description
     * Update the hidden status
     */
    var updateHideStatus = function updateHideStatus() {
        return function () {
            var result = [];
            for (var key in $scope.days) {
                var day = $scope.days[key];
                result.push($scope.days[key].hide = !day.date.isSame($scope.selected_day, 'day'));
            }
            return result;
        }();
    };

    /***
     * @ngdoc method
     * @name isPast
     * @methodOf BB.Directives.bbTimeRangeStacked
     * @description
     * Calculate if the current earliest date is in the past - in which case we. Might want to disable going backwards
     */
    // calculate if the current earliest date is in the past - in which case we
    // might want to disable going backwards
    $scope.isPast = function () {
        if (!$scope.start_date) {
            return true;
        }
        return moment().isAfter($scope.start_date);
    };

    /***
     * @ngdoc method
     * @name status
     * @methodOf BB.Directives.bbTimeRangeStacked
     * @description
     * Check the status of the slot to see if it has been selected
     *
     * @param {date} day The day
     * @param {object} slot The slot of day in multi time range list
     */
    // check the status of the slot to see if it has been selected
    // NOTE: This is very costly to call from a view, please consider using ng-class
    // to access the status
    $scope.status = function (day, slot) {
        if (!slot) {
            return;
        }

        var status = slot.status();
        return status;
    };

    /***
     * @ngdoc method
     * @name highlightSlot
     * @methodOf BB.Directives.bbTimeRangeStacked
     * @description
     * Check the highlight slot
     *
     * @param {date} day The day
     * @param {object} slot The slot of day in multi time range list
     */
    $scope.highlightSlot = function (slot, day) {

        if (day && slot && slot.availability() > 0) {
            $scope.bb.clearStackedItemsDateTime();
            if ($scope.selected_slot) {
                $scope.selected_slot.selected = false;
            }
            $scope.setLastSelectedDate(day.date);
            $scope.selected_slot = angular.copy(slot);
            $scope.selected_day = day.date;
            $scope.selected_date = day.date.toDate();

            // broadcast message to the accordion range groups
            $scope.$broadcast('slotChanged', day, slot);

            // set the date and time on the stacked items
            while (slot) {
                for (var itemIndex in $scope.bb.stacked_items) {
                    var item = $scope.bb.stacked_items[itemIndex];
                    if (item.service.self === slot.service.self && !item.date && !item.time) {
                        item.setDate(day);
                        item.setTime(slot);
                        slot = slot.next;
                        break;
                    }
                }
            }

            updateHideStatus();
            return $rootScope.$broadcast("time:selected");
        }
    };

    /***
     * @ngdoc method
     * @name loadData
     * @methodOf BB.Directives.bbTimeRangeStacked
     * @description
     * Load the time data
     */
    // load the time data
    $scope.loadData = function () {

        loader.notLoaded();

        $scope.start_date = moment($scope.start_date);
        var edate = moment($scope.start_date).add($scope.time_range_length, 'days');
        $scope.end_date = moment(edate).add(-1, 'days');

        var selectedItems = $scope.bb.stacked_items;
        if (!selectedItems || !selectedItems.length) {
            selectedItems = [$scope.bb.current_item];
        }

        var people_promise = $scope.bb.company.$getPeople();

        var time_data_promise = TimeService.queryItems({
            company: $scope.bb.company,
            items: selectedItems,
            client: $scope.client,
            start_date: $scope.start_date,
            end_date: $scope.end_date
        });

        return $q.all([people_promise, time_data_promise]).then(function (res) {
            var people = res[0];
            var timeData = res[1];
            var maxGapBetweenSlots = 0;

            $scope.days = TimeSlotPermutationService.findValidSlots(selectedItems, timeData, maxGapBetweenSlots);

            $scope.$broadcast("bbTimeRangeStacked-loadData:finished", $scope.days, people);
            $scope.setLoaded($scope);
        }, function (err) {
            $scope.setLoadedAndShowError($scope, err, 'Sorry, something went wrong');
        });
    };
    /***
     * @ngdoc method
     * @name pretty_month_title
     * @methodOf BB.Directives.bbTimeRangeStacked
     * @description
     * Display pretty month title in according of month format and year format parameters
     *
     * @param {date} month_format The month format
     * @param {date} year_format The year format
     * @param {string} separator The separator is '-'
     */
    $scope.pretty_month_title = function (month_format, year_format, seperator) {
        var start_date = void 0;
        if (seperator == null) {
            seperator = '-';
        }
        if (!$scope.start_date) {
            return;
        }
        var month_year_format = month_format + ' ' + year_format;
        if ($scope.start_date && $scope.end_date && $scope.end_date.isAfter($scope.start_date, 'month')) {
            start_date = $scope.start_date.format(month_format);
            if ($scope.start_date.month() === 11) {
                start_date = $scope.start_date.format(month_year_format);
            }
            return start_date + ' ' + seperator + ' ' + $scope.end_date.format(month_year_format);
        } else {
            return $scope.start_date.format(month_year_format);
        }
    };

    /***
     * @ngdoc method
     * @name confirm
     * @methodOf BB.Directives.bbTimeRangeStacked
     * @description
     * Confirm the time range stacked
     *
     * @param {string =} route A specific route to load
     * @param {object} options The options
     */
    $scope.confirm = function (route, options) {
        // first check all of the stacked items
        var booking = void 0;
        if (options == null) {
            options = {};
        }
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = Array.from($scope.bb.stacked_items)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var item = _step.value;

                if (!item.time) {
                    AlertService.add("danger", { msg: "Select a time to continue your booking" });
                    return false;
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        if ($scope.bb.moving_booking != null && $scope.bb.moving_booking.bookings != null) {
            var different = false;
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = Array.from($scope.bb.moving_booking.bookings)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    booking = _step2.value;

                    var found = false;
                    var _iteratorNormalCompletion3 = true;
                    var _didIteratorError3 = false;
                    var _iteratorError3 = undefined;

                    try {
                        for (var _iterator3 = Array.from($scope.bb.stacked_items)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                            item = _step3.value;

                            if (booking.getDateString() === item.date.string_date && booking.getTimeInMins() === item.time.time && booking.category_name === item.category_name) {
                                found = true;
                            }
                        }
                    } catch (err) {
                        _didIteratorError3 = true;
                        _iteratorError3 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion3 && _iterator3.return) {
                                _iterator3.return();
                            }
                        } finally {
                            if (_didIteratorError3) {
                                throw _iteratorError3;
                            }
                        }
                    }

                    if (!found) {
                        different = true;
                        break;
                    }
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            if (!different) {
                AlertService.add("danger", { msg: "Your treatments are already booked for this time." });
                return false;
            }
        }

        // empty the current basket quickly
        $scope.bb.basket.clear();

        // add all the stacked items
        $scope.bb.pushStackToBasket();

        if ($scope.bb.moving_booking) {
            // if we're moving - confirm everything in the basket right now
            loader.notLoaded();

            var prom = PurchaseService.update({ purchase: $scope.bb.moving_booking, bookings: $scope.bb.basket.items });

            prom.then(function (purchase) {
                purchase.$getBookings().then(function (bookings) {
                    return function () {
                        var result = [];
                        var _iteratorNormalCompletion4 = true;
                        var _didIteratorError4 = false;
                        var _iteratorError4 = undefined;

                        try {
                            for (var _iterator4 = Array.from(bookings)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                                booking = _step4.value;

                                // update bookings
                                var item1 = void 0;
                                if ($scope.bookings) {
                                    item1 = function () {
                                        var result1 = [];
                                        for (var _i = 0; _i < $scope.bookings.length; _i++) {
                                            var oldb = $scope.bookings[_i];
                                            var item2 = void 0;
                                            if (oldb.id === booking.id) {
                                                item2 = $scope.bookings[_i] = booking;
                                            }
                                            result1.push(item2);
                                        }
                                        return result1;
                                    }();
                                }
                                result.push(item1);
                            }
                        } catch (err) {
                            _didIteratorError4 = true;
                            _iteratorError4 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion4 && _iterator4.return) {
                                    _iterator4.return();
                                }
                            } finally {
                                if (_didIteratorError4) {
                                    throw _iteratorError4;
                                }
                            }
                        }

                        return result;
                    }();
                });
                loader.setLoaded();
                $scope.bb.current_item.move_done = true;
                return $scope.decideNextPage();
            }, function (err) {
                loader.setLoaded();
                return AlertService.add("danger", { msg: "Failed to move booking" });
            });
            return;
        }

        loader.notLoaded();

        if (options.do_not_route) {
            return $scope.updateBasket();
        } else {
            return $scope.updateBasket().then(function () {
                loader.setLoaded();
                return $scope.decideNextPage(route);
            }, function (err) {
                return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
            });
        }
    };

    /***
     * @ngdoc method
     * @name setReady
     * @methodOf BB.Directives.bbTimeRangeStacked
     * @description
     * Set this page section as ready
     */
    $scope.setReady = function () {
        return $scope.confirm('', { do_not_route: true });
    };
}

angular.module('BB.Controllers').controller('bbTimeRangeStackedController', bbTimeRangeStackedController);
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives.bbTimeRangeStacked
 * @restrict E
 * @scope true
 *
 * @description
 *Loads a list of time range stacked for the currently in scope company
 *
 * Used for selecting multiple services for checkout
 *
 * NOTE: This directive does not replace bbTimeRanges and should be used in conjunction with bbTimeRanges.
 *
 * NOTE: adding this alone will not immediately enable multiple service selection
 * you will also need to use the bbMultiServiceSelect within the _service.html template
 * see bbMultiServiceSelect directive for more detail
 *
 * WARNING: this does not work well with booking multiple services which have pre and post times
 * pre and post times are not considered so bookings may overlap
 *
 * @param {hash}  bbTimeRangeStacked A hash of options
 * @property {date} start_date The start date of time range list
 * @property {date} end_date The end date of time range list
 * @property {integer} available_times The available times of range list
 * @property {object} day_of_week The day of week
 * @property {object} selected_day The selected day from the multi time range list
 * @property {object} original_start_date The original start date of range list
 * @property {object} start_at_week_start The start at week start of range list
 * @property {object} selected_slot The selected slot from multi time range list
 * @property {object} selected_date The selected date from multi time range list
 * @property {object} alert The alert service - see {@link BB.Services:Alert Alert Service}
 */
angular.module('BB.Directives').directive('bbTimeRangeStacked', function () {
    return {
        controller: 'bbTimeRangeStackedController',
        controllerAs: '$bbTimeRangeStackedCtrl'
    };
});
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function () {
    angular.module('BB.Directives').directive('bbAccessibleGrid', function () {
        return {
            restrict: 'A',
            link: function link(scope, element) {
                var navigator = void 0;
                /* Activate on element focus event */
                element.bind('focus', function () {
                    navigator = navigator ? navigator : new GridNavigator(scope, element);
                    navigator.cells = element.find('tr td div h4').parent();
                    navigator.columns = element.find('tr td');
                    navigator.focus();
                });
            }
        };
    });

    /** grid accessibility navigator  */

    var GridNavigator = function () {

        /**
         *
         * @param {*} scope
         * @param {*} elem <table element bound
         */
        function GridNavigator(scope, elem) {
            _classCallCheck(this, GridNavigator);

            this.scope = scope;
            this.elem = elem;
            this.cells;
            this.columns;
            this.activeCellIndex = 0;
            this.event;
            this.activeKeyCode;
            this.activeCell;
            this.accordion; //accordion in active cell
            this.accordionSlots;
            this.accordionSlotIndex = 0;
            this.inAccordion = false;
            this.prevCell;
            this.listen();
        }

        /**
         * Listen for nav keys to delegate to main grid or cell-accordion navgation
         *  */


        GridNavigator.prototype.listen = function listen() {
            var _this = this;

            this.elem.on('keydown', function (e) {
                _this.event = e;
                _this.activeKeyCode = e.keyCode;
                _this.prevCell = _this.cells.eq(_this.activeCellIndex); //set the prevCell to this one so we can swap tabindex with next one

                if (!_this.inAccordion) {
                    _this.gridNav();
                } else {
                    _this.accordionNav();
                }
                e.preventDefault();
                e.stopPropagation();
            });
        };

        //navigating main grid


        GridNavigator.prototype.gridNav = function gridNav() {
            var columns = this.columns.length; //the first and last are arrow <
            var endCellIndex = columns * 3 - 1; //getting the first last cell on the right
            switch (this.activeKeyCode) {

                case 39:
                    //move right
                    this.activeCellIndex += 3;
                    this.activeCellIndex = this.activeCellIndex > endCellIndex ? this.activeCellIndex - 3 : this.activeCellIndex;
                    this.focus();
                    break;
                case 37:
                    //move left
                    this.activeCellIndex -= 3;
                    this.activeCellIndex = this.activeCellIndex < 0 ? this.activeCellIndex + 3 : this.activeCellIndex;
                    this.focus();
                    break;
                case 40:
                    //down, focus accordions in cell
                    this.activeCellIndex += 1;
                    this.activeCellIndex = this.activeCellIndex > this.cells.length ? this.activeCellIndex - 1 : this.activeCellIndex;
                    this.focus();
                    break;
                case 38:
                    //up
                    this.activeCellIndex -= 1;
                    this.activeCellIndex = this.activeCellIndex < 0 ? this.activeCellIndex + 1 : this.activeCellIndex;
                    this.focus();
                    break;
                case 9: //tab,ecs
                case 27:
                    this.escape();
                    break;
                case 13:
                case 32:
                    this.accordionFocus();
                    break;
            }
        };

        /**
         * Naviagtion in accordion mode **/


        GridNavigator.prototype.accordionNav = function accordionNav() {

            switch (this.activeKeyCode) {

                case 38:
                    //up, focus accordions in cell
                    this.accordionSlotIndex -= 1;
                    this.accordionSlotIndex = this.accordionSlotIndex < 0 ? this.accordionSlots.length - 1 : this.accordionSlotIndex;
                    this.accordionFocus();
                    break;
                case 40:
                    //down
                    this.accordionSlotIndex += 1;
                    this.accordionSlotIndex = this.accordionSlotIndex >= this.accordionSlots.length ? 0 : this.accordionSlotIndex;
                    this.accordionFocus();
                    break;
                case 27:
                    //esc
                    this.accordionBlur();
                    break;
                case 9:
                    //tab
                    //shift+tab || shift+esc
                    if (this.event.shiftKey) {
                        this.accordionBlur();
                    }
                    break;
                case 13:
                case 32:
                    if (this.inAccordion) {
                        this.accordionSlots.eq(this.accordionSlotIndex).click();
                        this.accordion.click();
                        this.accordionBlur();
                    }
                    break;
            }
        };

        /** Focus on selected grid cells */


        GridNavigator.prototype.focus = function focus() {
            this.activeCell = this.cells.eq(this.activeCellIndex);
            if (this.prevCell) {
                this.prevCell.attr('tabindex', '-1');
            }
            this.activeCell.attr('tabindex', '0').focus();
        };

        /** Focus on cell-accordion selection */


        GridNavigator.prototype.accordionFocus = function accordionFocus() {
            this.accordion = this.activeCell.find('h4>div');
            if (!this.inAccordion && !this.event.shiftKey) {
                this.activeCell = this.cells.eq(this.activeCellIndex);
                this.activeCell.attr('tabindex', '-1');
                this.activeCell.blur();
                this.inAccordion = true;
                this.accordion.click();
            }
            this.accordionSlots = this.cells.eq(this.activeCellIndex).parent().parent().find('#time-slots li');
            this.accordionSlots.eq(this.accordionSlotIndex).attr('tabindex', '0').focus();
        };

        /** escape accordion navigation to grid */


        GridNavigator.prototype.accordionBlur = function accordionBlur() {
            var activeSlot = this.accordionSlots.eq(this.accordionSlotIndex);
            activeSlot.attr('tabindex', '-1').blur();
            this.activeCell.attr('tabindex', '0');
            this.accordion.click();
            this.inAccordion = false;
            this.accordionSlotIndex = 0;
            this.focus();
        };

        /** Lose the focus on grid*/


        GridNavigator.prototype.escape = function escape() {
            this.activeCell.attr('tabindex', '-1');
            this.activeCell.blur();
            //this.elem.attr('tabindex','1');
            if (this.event.shiftKey) {
                var prev = this.elem.parent().prev().find('button');
                if (prev.attr('disabled')) {
                    prev = $('.month-header h2');
                }
                prev.focus();
            } else this.elem.parent().next().find('button').focus();
        };

        return GridNavigator;
    }();
})();
'use strict';

(function () {
    angular.module('BB.Controllers').controller('TimeRangeList', TimeRangeListController);

    function TimeRangeListController($scope, $element, $attrs, $rootScope, AlertService, LoadingService, BBModel, FormDataStoreService, DateTimeUtilitiesService, SlotDates, viewportSize, ErrorService, bbAnalyticsPiwik, GeneralOptions) {
        'ngInject';

        // store the form data for the following scope properties

        var _this = this;

        var currentPostcode = $scope.bb.postcode;
        this.viewPortChangeListener = null;

        FormDataStoreService.init('TimeRangeList', $scope, ['selected_slot', 'postcode', 'original_start_date', 'start_at_week_start']);

        $scope.$on('BBTimeZoneOptions:timeZoneChanged', function () {
            $scope.initialise();
        }); // check to see if the user has changed the postcode and remove data if they have

        if (currentPostcode !== $scope.postcode) {
            $scope.selected_slot = null;
            $scope.selected_date = null;
        }

        // store the postocde
        $scope.postcode = $scope.bb.postcode;

        // show the loading icon
        var loader = LoadingService.$loader($scope);

        // if the data source isn't set, set it as the current item
        if (!$scope.data_source) {
            $scope.data_source = $scope.bb.current_item;
        }

        $rootScope.connection_started.then(function () {
            return $scope.initialise();
        });

        /***
         * @ngdoc method
         * @name initialise
         * @methodOf BB.Directives.bbTimeRanges
         * @description
         * Set time range in according of selected date and start date parameters
         *
         */
        $scope.initialise = function () {

            // read initialisation attributes
            var selected_day = void 0;
            if ($attrs.bbTimeRangeLength != null) {
                $scope.time_range_length = $scope.$eval($attrs.bbTimeRangeLength);
            } else if ($scope.options && $scope.options.time_range_length) {
                $scope.time_range_length = $scope.options.time_range_length;
            } else {
                var calculateDayNum = function calculateDayNum() {
                    var calendarDays = GeneralOptions.calendarDaysByScreenWidth;

                    // default to the large time range
                    var timeRange = 7;

                    for (var size in calendarDays) {
                        var days = calendarDays[size];
                        if (size === viewportSize.getViewportSize()) {
                            timeRange = days;
                        }
                    }

                    return timeRange;
                };

                $scope.time_range_length = calculateDayNum();

                registerViewportChangedListener();
            }

            if ($attrs.bbDayOfWeek != null || $scope.options && $scope.options.day_of_week) {
                $scope.day_of_week = $attrs.bbDayOfWeek != null ? $scope.$eval($attrs.bbDayOfWeek) : $scope.options.day_of_week;
            }

            if ($attrs.bbSelectedDay != null || $scope.options && $scope.options.selected_day) {
                selected_day = $attrs.bbSelectedDay != null ? moment($scope.$eval($attrs.bbSelectedDay)) : moment($scope.options.selected_day);
                if (moment.isMoment(selected_day)) {
                    $scope.selected_day = selected_day;
                }
            }

            $scope.options.ignore_min_advance_datetime = $scope.options.ignore_min_advance_datetime ? true : false;

            setMinMaxDate();

            // initialise the time range
            // last selected day is set (i.e, a user has already selected a date)
            if (!$scope.start_date && $scope.last_selected_date) {
                // if the time range list was initialised with a selected_day, restore the view so that
                // selected day remains relative to where the first day that was originally shown
                if ($scope.original_start_date) {
                    var diff = $scope.last_selected_date.diff($scope.original_start_date, 'days');
                    diff = diff % $scope.time_range_length;
                    if ($scope.last_selected_date.hour() <= moment().hour()) {
                        //if the selected time is less than time now, difference will be
                        diff += 1;
                    }
                    diff = diff === $scope.time_range_length ? 0 : diff; //compensate for $scope.time_range_length long differences
                    //diff = diff === 0 ? diff : diff + 1;
                    var start_date = $scope.last_selected_date.clone().subtract(diff, 'days');
                    setTimeRange($scope.last_selected_date, start_date);
                } else {
                    setTimeRange($scope.last_selected_date);
                }
                // the current item already has a date
            } else if ($scope.bb.current_item.date || $scope.bb.current_item.defaults.date) {
                var date = $scope.bb.current_item.date ? $scope.bb.current_item.date.date : $scope.bb.current_item.defaults.date;
                setTimeRange(date);
                // selected day has been provided, use this to set the time
            } else if ($scope.selected_day) {
                $scope.original_start_date = $scope.original_start_date || moment($scope.selected_day);
                setTimeRange($scope.selected_day);
                // set the time range to show the current week
            } else {
                $scope.start_at_week_start = true;
                setTimeRange(moment());
            }

            return $scope.loadData();
        };

        var markSelectedSlot = function markSelectedSlot(time_slots) {
            var selected_slot = _.find(time_slots, function (slot) {
                return $scope.bb.current_item.date && $scope.bb.current_item.date.date.isSame(slot.datetime, 'day') && $scope.bb.current_item.time && $scope.bb.current_item.time.time === slot.time;
            });
            if (selected_slot) {
                return selected_slot.selected = true;
            }
        };

        var registerViewportChangedListener = function registerViewportChangedListener() {
            if (_this.viewPortChangeListener !== null) return;
            _this.viewPortChangeListener = $scope.$on('viewportSize:changed', function () {
                $scope.time_range_length = null;
                $scope.initialise();
            });
        };

        /***
         * @ngdoc method
         * @name setTimeRange
         * @methodOf BB.Directives.bbTimeRanges
         * @description
         * Set time range in according of selected date and start date parameters
         *
         * @param {date} selected_date The selected date
         * @param {date} start_date The start date
         */
        var setTimeRange = function setTimeRange(selected_date, start_date) {
            if (start_date) {
                $scope.start_date = start_date;
            } else if ($scope.day_of_week) {
                $scope.start_date = selected_date.clone().day($scope.day_of_week);
            } else if ($scope.start_at_week_start) {
                $scope.start_date = selected_date.clone().startOf('week');
            } else {
                $scope.start_date = selected_date.clone();
            }

            $scope.selected_day = selected_date;
            // convert selected day to JS date object for date picker, it needs
            // to be saved as a variable as functions cannot be passed into the
            // AngluarUI date picker
            $scope.selected_date = $scope.selected_day.toDate();

            isSubtractValid();

            isAddValid();
        };

        /***
         * @ngdoc method
         * @name setMinMaxDate
         * @methodOf BB.Directives.bbTimeRanges
         * @description
         * Set min, max date and time range based on min/max advance datetime of the selected service
         *
         */
        var setMinMaxDate = function setMinMaxDate() {

            var current_item = $scope.bb.current_item;
            // has a service been selected?
            if (current_item.service && !$scope.options.ignore_min_advance_datetime) {

                $scope.min_date = current_item.service.min_advance_datetime;
                $scope.max_date = current_item.service.max_advance_datetime;

                if (GeneralOptions.maxAdvanceDatetimeDays) {
                    $scope.max_date = moment().add(GeneralOptions.maxAdvanceDatetimeDays, 'days');
                }

                // date helpers for use by datepicker-popup
                $scope.minDateJs = $scope.min_date.toDate();
                $scope.maxDateJs = $scope.max_date.toDate();

                //calculate duration of max date from today
                if (!$scope.maxDateDuration) {
                    var maxDate = $scope.max_date.clone();
                    var today = moment().clone();
                    var difference = maxDate.startOf('day').diff(today.startOf('day'), 'days', true);
                    var maxDateDuration = moment.duration(difference, 'days').humanize();
                    // store it on scope in a form to support translations
                    $scope.maxDateDurationObj = {
                        maxDateDuration: maxDateDuration
                    };
                }

                // if the selected day is before the services min_advance_datetime, adjust the time range
                if ($scope.selected_day && $scope.selected_day.isBefore(current_item.service.min_advance_datetime, 'day') && !$scope.isAdmin()) {
                    setTimeRange(current_item.service.min_advance_datetime);
                }
            }
        };

        /***
         * @ngdoc method
         * @name moment
         * @methodOf BB.Directives.bbTimeRanges
         * @description
         * Add to moment date in according of date parameter
         *
         * @param {date} date The date
         */
        $scope.moment = function (date) {
            return moment(date);
        };

        /***
         * @ngdoc method
         * @name setDataSource
         * @methodOf BB.Directives.bbTimeRanges
         * @description
         * Set data source in according of source parameter
         *
         * @param {array} source The source of data
         */
        $scope.setDataSource = function (source) {
            return $scope.data_source = source;
        };

        // when the current item is updated, reload the time data
        $scope.$on("currentItemUpdate", function (event) {
            return $scope.loadData();
        });

        function setPiwik(amount) {
            var category = "Calendar";
            var title = "Load Next Week";
            if (amount < 0) {
                title = "Load Previous Week";
            }
            bbAnalyticsPiwik.push(['trackEvent', [category], title]);
        }

        /***
         * @ngdoc method
         * @name add
         * @methodOf BB.Directives.bbTimeRanges
         * @description
         * Add new time range in according of type and amount parameters
         *
         * @param {object} type The type
         * @param {object} amount The amount of the days
         */
        $scope.add = function (type, amount) {
            if (bbAnalyticsPiwik.isEnabled()) setPiwik(amount);
            if (amount > 0) {
                $element.removeClass('subtract');
                $element.addClass('add');
            }
            switch (type) {
                case 'days':
                    setTimeRange($scope.start_date.add(amount, 'days'));
                    break;
                case 'weeks':
                    $scope.start_date.add(amount, type);
                    setTimeRange($scope.start_date);
                    break;
                case 'months':
                    // TODO make this advance to the next month
                    $scope.start_date.add(amount, type).startOf('month');
                    setTimeRange($scope.start_date);
                    break;
            }
            return $scope.loadData();
        };

        /***
         * @ngdoc method
         * @name subtract
         * @methodOf BB.Directives.bbTimeRanges
         * @description
         * Substract amount
         *
         * @param {object} type The type
         * @param {object} amount The amount of the days
         */
        $scope.subtract = function (type, amount) {
            $element.removeClass('add');
            $element.addClass('subtract');
            return $scope.add(type, -amount);
        };

        /***
         * @ngdoc method
         * @name isSubtractValid
         * @methodOf BB.Directives.bbTimeRanges
         * @description
         * Use to determine if subtraction of the time range is valid (i.e. it's not in the past)
         *
         */
        var isSubtractValid = function isSubtractValid() {
            $scope.is_subtract_valid = true;

            var diff = Math.ceil($scope.selected_day.diff($scope.min_date, 'days', true));

            $scope.subtract_length = diff < $scope.time_range_length ? diff : $scope.time_range_length;
            if (diff <= 0) {
                $scope.is_subtract_valid = false;
            }

            if ($scope.subtract_length > 1) {
                return $scope.subtract_string = 'Prev ' + $scope.subtract_length + ' days';
            } else if ($scope.subtract_length === 1) {
                return $scope.subtract_string = "Prev day";
            } else {
                return $scope.subtract_string = "Prev";
            }
        };

        /***
         * @ngdoc method
         * @name isAddValid
         * @methodOf BB.Directives.bbTimeRanges
         * @description
         * Use to determine if addition of the time range is valid (i.e. it's not more than the max days in advance)
         *
         */
        var isAddValid = function isAddValid() {
            $scope.is_add_valid = true;

            if (!$scope.isAdmin() && !$scope.options.ignore_max_advance_datetime && $scope.max_date) {
                var max_date = $scope.max_date.clone();
                var selected_day = $scope.selected_day.clone();
                var difference = max_date.startOf('day').diff(selected_day.startOf('day'), 'days', true);
                if (difference - $scope.time_range_length < 0) {
                    return $scope.is_add_valid = false;
                }
            }
        };

        /***
         * @ngdoc method
         * @name selectedDateChanged
         * @methodOf BB.Directives.bbTimeRanges
         * @description
         * Select date change
         *
         */
        // called on datepicker date change
        $scope.selectedDateChanged = function () {
            setTimeRange(moment($scope.selected_date));
            $scope.selected_slot = null;
            return $scope.loadData();
        };

        /***
         * @ngdoc method
         * @name isPast
         * @methodOf BB.Directives.bbTimeRanges
         * @description
         * Calculate if the current earliest date is in the past - in which case we might want to disable going backwards
         *
         */
        // calculate if the current earliest date is in the past - in which case we
        // might want to disable going backwards
        $scope.isPast = function () {
            if (!$scope.start_date) {
                return true;
            }
            return moment().isAfter($scope.start_date);
        };

        /***
         * @ngdoc method
         * @name status
         * @methodOf BB.Directives.bbTimeRanges
         * @description
         * Check the status of the slot to see if it has been selected
         *
         * @param {date} day The day
         * @param {array} slot The slot
         */
        // check the status of the slot to see if it has been selected
        // NOTE: This is very costly to call from a view, please consider using ng-class
        // to access the status
        $scope.status = function (day, slot) {
            if (!slot) {
                return;
            }
            var status = slot.status();
            return status;
        };
        // the view was originally calling the slot.status(). this logic below is for
        // storing the time but we're not doing this for now so we just return status
        // selected = $scope.selected_slot
        // if selected and selected.time is slot.time and selected.date is slot.date
        //   return status = 'selected'
        // return status

        /***
         * @ngdoc method
         * @name selectSlot
         * @methodOf BB.Directives.bbTimeRanges
         * @description
         * Called when user selects a time slot use this when you want to route to the next step as a slot is selected
         *
         * @param {date} day The day
         * @param {array} slot The slot
         * @param {string=} route A route of the selected slot
         */
        $scope.selectSlot = function (slot, day, route) {
            if (slot && slot.availability() > 0) {

                $scope.bb.current_item.setTime(slot);

                if (slot.datetime) {
                    $scope.setLastSelectedDate(slot.datetime);
                    $scope.bb.current_item.setDate({
                        date: slot.datetime
                    });
                } else if (day) {
                    $scope.setLastSelectedDate(day.date);
                    $scope.bb.current_item.setDate(day);
                }

                if ($scope.bb.current_item.reserve_ready) {
                    loader.notLoaded();
                    $scope.addItemToBasket().then(function () {
                        loader.setLoaded();
                        $scope.decideNextPage(route);
                    }, function (err) {
                        loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
                    });
                } else {
                    $scope.decideNextPage(route);
                }
            }
        };

        /***
         * @ngdoc method
         * @name highlightSlot
         * @methodOf BB.Directives.bbTimeRanges
         * @description
         * Called when user selects a time slot use this when you just want to hightlight the the slot and not progress to the next step
         *
         * @param {date} day The day
         * @param {array} slot The slot
         */
        $scope.highlightSlot = function (slot, day) {
            var current_item = $scope.bb.current_item;

            if (slot && slot.availability() > 0 && !slot.disabled) {

                if (slot.datetime) {
                    $scope.setLastSelectedDate(slot.datetime);
                    current_item.setDate({
                        date: slot.datetime.clone().tz($scope.bb.company.timezone)
                    });
                } else if (day) {
                    $scope.setLastSelectedDate(day.date);
                    current_item.setDate(day);
                }

                current_item.setTime(slot);
                $scope.selected_slot = slot;
                $scope.selected_day = day.date;
                $scope.selected_date = day.date.toDate();

                if ($scope.bb.current_item.earliest_time_slot && $scope.bb.current_item.earliest_time_slot.selected && (!$scope.bb.current_item.earliest_time_slot.date.isSame(day.date, 'day') || $scope.bb.current_item.earliest_time_slot.time !== slot.time)) {
                    $scope.bb.current_item.earliest_time_slot.selected = false;
                }

                $rootScope.$broadcast("time:selected");

                // broadcast message to the accordion range groups
                $scope.$broadcast('slotChanged', day, slot);
            }
        };

        /***
         * @ngdoc method
         * @name loadData
         * @methodOf BB.Directives.bbTimeRanges
         * @description
         * Load the time data
         *
         */
        $scope.loadData = function () {

            setMinMaxDate();

            var date = $scope.start_date;
            var edate = moment(date).add($scope.time_range_length, 'days');
            $scope.end_date = moment(edate).add(-1, 'days');

            AlertService.clear();
            // We may not want the current item duration to be the duration we query by
            // If min_duration is set, pass that into the api, else pass in the duration
            var duration = $scope.bb.current_item.duration;

            if ($scope.bb.current_item.min_duration) {
                duration = $scope.bb.current_item.min_duration;
            }

            if ($scope.data_source && $scope.data_source.days_link) {
                loader.notLoaded();
                var loc = null;
                if ($scope.bb.postcode) {
                    loc = ',,,,' + $scope.bb.postcode + ',';
                }

                var promise = BBModel.TimeSlot.$query({
                    company: $scope.bb.company,
                    resource_ids: $scope.bb.item_defaults.resources,
                    people_ids: $scope.bb.item_defaults.people_ids,
                    cItem: $scope.data_source,
                    date: date,
                    client: $scope.client,
                    end_date: $scope.end_date,
                    duration: duration,
                    location: loc,
                    num_resources: $scope.bb.current_item.num_resources,
                    available: 1
                });

                promise.then(function (datetime_arr) {

                    var time_slots = void 0;
                    $scope.days = [];

                    if (_.every(_.values(datetime_arr), _.isEmpty)) {
                        $scope.no_slots_in_week = true;
                    } else {
                        $scope.no_slots_in_week = false;
                    }

                    var utc = moment().utc();
                    var utcHours = utc.format('H');
                    var utcMinutes = utc.format('m');
                    var utcSeconds = utc.format('s');

                    // sort time slots to be in chronological order
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = Array.from(_.sortBy(_.pairs(datetime_arr), function (pair) {
                            return pair[0];
                        }))[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var pair = _step.value;

                            var slot;
                            var d = pair[0];
                            time_slots = pair[1];

                            // make sure the selected slot is marked as selected
                            markSelectedSlot(time_slots);

                            var day = {
                                date: moment(d).add(utcHours, 'hours').add(utcMinutes, 'minutes').add(utcSeconds, 'seconds'),
                                slots: time_slots
                            };
                            $scope.days.push(day);

                            if (time_slots.length > 0) {
                                if (!$scope.bb.current_item.earliest_time || $scope.bb.current_item.earliest_time.isAfter(d)) {
                                    $scope.bb.current_item.earliest_time = moment(d).add(time_slots[0].time, 'minutes');
                                }
                                if (!$scope.bb.current_item.earliest_time_slot || $scope.bb.current_item.earliest_time_slot.date.isAfter(d)) {
                                    $scope.bb.current_item.earliest_time_slot = {
                                        date: moment(d).add(time_slots[0].time, 'minutes'),
                                        time: time_slots[0].time
                                    };
                                }
                            }

                            // padding is used to ensure that a list of time slots is always padded
                            // out with a certain of values if it's a partial set of results
                            if ($scope.add_padding && time_slots.length > 0) {
                                var dtimes = {};
                                var _iteratorNormalCompletion2 = true;
                                var _didIteratorError2 = false;
                                var _iteratorError2 = undefined;

                                try {
                                    for (var _iterator2 = Array.from(time_slots)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                        slot = _step2.value;

                                        dtimes[slot.time] = 1;
                                        // add date to slot as well
                                        slot.date = day.date.format('DD-MM-YY');
                                    }
                                } catch (err) {
                                    _didIteratorError2 = true;
                                    _iteratorError2 = err;
                                } finally {
                                    try {
                                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                            _iterator2.return();
                                        }
                                    } finally {
                                        if (_didIteratorError2) {
                                            throw _iteratorError2;
                                        }
                                    }
                                }

                                for (var v = 0; v < $scope.add_padding.length; v++) {
                                    var pad = $scope.add_padding[v];
                                    if (!dtimes[pad]) {
                                        time_slots.splice(v, 0, new BBModel.TimeSlot({
                                            time: pad,
                                            avail: 0
                                        }, time_slots[0].service));
                                    }
                                }
                            }

                            var requested_slot = DateTimeUtilitiesService.checkDefaultTime(day.date, day.slots, $scope.bb.current_item, $scope.bb.item_defaults);

                            if (requested_slot.slot && requested_slot.match === "full") {
                                $scope.skipThisStep();
                                $scope.selectSlot(requested_slot.slot, day);
                            } else if (requested_slot.slot) {
                                $scope.highlightSlot(requested_slot.slot, day);
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }

                    loader.setLoaded();

                    $scope.$broadcast("time_slots:loaded", time_slots);
                }, function (err) {
                    if (err.status === 404 && err.data && err.data.error && err.data.error === "No bookable events found") {
                        if ($scope.data_source && $scope.data_source.person) {
                            AlertService.warning(ErrorService.getError('NOT_BOOKABLE_PERSON'));
                            loader.setLoaded();
                        } else if ($scope.data_source && $scope.data_source.resource) {
                            AlertService.warning(ErrorService.getError('NOT_BOOKABLE_RESOURCE'));
                            loader.setLoaded();
                        }

                        loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
                    } else {
                        loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
                    }
                });
            }
        };

        $scope.showFirstAvailableDay = function () {
            return SlotDates.getFirstDayWithSlots($scope.data_source, $scope.selected_day).then(function (day) {
                $scope.no_slots_in_week = false;
                setTimeRange(day);
                return $scope.loadData();
            }, function (err) {
                return loader.setLoadedAndShowError($scope, err, 'Sorry, something went wrong');
            });
        };
        /***
         * @ngdoc method
         * @name padTimes
         * @methodOf BB.Directives.bbTimeRanges
         * @description
         * The pad time
         *
         * @param {date} times The times
         */
        $scope.padTimes = function (times) {
            return $scope.add_padding = times;
        };

        /***
         * @ngdoc method
         * @name setReady
         * @methodOf BB.Directives.bbTimeRanges
         * @description
         * Set this page section as ready
         */
        $scope.setReady = function () {
            if (!$scope.bb.current_item.time) {
                AlertService.raise('TIME_SLOT_NOT_SELECTED');
                return false;
            } else if ($scope.bb.moving_booking && $scope.bb.current_item.start_datetime().isSame($scope.bb.current_item.original_datetime) && $scope.bb.current_item.person_name === $scope.bb.current_item.person.name) {
                AlertService.raise('APPT_AT_SAME_TIME');
                return false;
            } else if ($scope.bb.moving_booking) {
                // set a 'default' person and resource if we need them, but haven't picked any in moving
                if ($scope.bb.company.$has('resources') && !$scope.bb.current_item.resource) {
                    $scope.bb.current_item.resource = true;
                }
                if ($scope.bb.company.$has('people') && !$scope.bb.current_item.person) {
                    $scope.bb.current_item.person = true;
                }
                return true;
            } else {
                if ($scope.bb.current_item.reserve_ready) {
                    return $scope.addItemToBasket();
                } else {
                    return true;
                }
            }
        };

        /***
         * @ngdoc method
         * @name pretty_month_title
         * @methodOf BB.Directives.bbTimeRanges
         * @description
         * Format the month title in according of month formant, year format and separator parameters
         *
         * @param {date} month_format The month format
         * @param {date} year_format The year format
         * @param {object} separator The separator of month and year format
         */
        $scope.pretty_month_title = function (month_format, year_format, seperator) {
            var start_date = void 0;
            if (seperator == null) {
                seperator = '-';
            }
            if (!$scope.start_date || !$scope.end_date) {
                return;
            }
            var month_year_format = month_format + ' ' + year_format;
            if ($scope.start_date && $scope.end_date && $scope.end_date.isAfter($scope.start_date, 'month')) {
                start_date = $scope.start_date.format(month_format);
                if ($scope.start_date.month() === 11) {
                    start_date = $scope.start_date.format(month_year_format);
                }
                return start_date + ' ' + seperator + ' ' + $scope.end_date.format(month_year_format);
            } else {
                return $scope.start_date.format(month_year_format);
            }
        };

        /***
         * @ngdoc method
         * @name selectEarliestTimeSlot
         * @methodOf BB.Directives.bbTimeRanges
         * @description
         * Select earliest time slot
         */
        $scope.selectEarliestTimeSlot = function () {
            var day = _.find($scope.days, function (day) {
                return day.date.isSame($scope.bb.current_item.earliest_time_slot.date, 'day');
            });
            var slot = _.find(day.slots, function (slot) {
                return slot.time === $scope.bb.current_item.earliest_time_slot.time;
            });

            if (day && slot) {
                $scope.bb.current_item.earliest_time_slot.selected = true;
                return $scope.highlightSlot(day, slot);
            }
        };
    }
})();
'use strict';

(function () {
    /***
     * @ngdoc directive
     * @name BB.Directives.bbTimeRanges
     * @restrict AE
     * @scope true
     *
     * @description
     * Loads a list of time rangers for the currently in scope company
     *
     * @param {hash}  bbTimeRanges A hash of options
     * @property {string} selected_slot The selected slot
     * @property {date} selected_date The selected date
     * @property {string} postcode The postcode
     * @property {date} original_start_date The original start date
     * @property {date} start_at_week_start The start at week start
     * @property {object} alert The alert service - see {@link BB.Services:Alert Alert Service}
     */
    angular.module('BB.Directives').directive('bbTimeRanges', bbTimeRangesDirective);

    function bbTimeRangesDirective($q, $templateCache, $compile, $timeout, scrollIntercepter) {
        return {
            restrict: 'AE',
            replace: true,
            scope: true,
            priority: 1,
            transclude: true,
            controller: 'TimeRangeList',
            link: function link(scope, element, attrs, controller, transclude) {
                // focus on continue button after slot selected - for screen readers
                scope.$on('time:selected', function () {
                    var btn = angular.element('#btn-continue');
                    if (btn[0]) {
                        btn[0].disabled = false;
                        $timeout(function () {
                            return scrollIntercepter.scrollToElement(btn, 500, 'time:selected');
                        }, 1000);
                        return $timeout(function () {
                            return btn[0].focus();
                        }, 1500);
                    }
                });

                // date helpers
                scope.today = moment().toDate();
                scope.tomorrow = moment().add(1, 'days').toDate();

                scope.options = scope.$eval(attrs.bbTimeRanges) || {};

                return transclude(scope, function (clone) {

                    // if there's content compile that or grab the week_calendar template
                    var has_content = clone.length > 1 || clone.length === 1 && (!clone[0].wholeText || /\S/.test(clone[0].wholeText));

                    if (has_content) {
                        return element.html(clone).show();
                    } else {
                        return $q.when($templateCache.get('_week_calendar.html')).then(function (template) {
                            element.html(template).show();
                            return $compile(element.contents())(scope);
                        });
                    }
                });
            }
        };
    }
})();
'use strict';

angular.module('BB.Controllers').controller('TimeSlots', function ($scope, $rootScope, $q, $attrs, FormDataStoreService, ValidatorService, LoadingService, halClient, BBModel) {

    var loader = LoadingService.$loader($scope).notLoaded();
    $rootScope.connection_started.then(function () {
        if ($scope.bb.company) {
            return $scope.init($scope.bb.company);
        }
    }, function (err) {
        return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
    });

    $scope.init = function (company) {
        if (!$scope.booking_item) {
            $scope.booking_item = $scope.bb.current_item;
        }
        $scope.start_date = moment();
        $scope.end_date = moment().add(1, 'month');

        var params = {
            item: $scope.booking_item,
            start_date: $scope.start_date.toISODate(),
            end_date: $scope.end_date.toISODate()
        };
        return BBModel.Slot.$query($scope.bb.company, params).then(function (slots) {
            $scope.slots = slots;
            return loader.setLoaded();
        }, function (err) {
            return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
        });
    };

    var setItem = function setItem(slot) {
        return $scope.booking_item.setSlot(slot);
    };

    /***
     * @ngdoc method
     * @name selectItem
     * @methodOf BB.Directives.bbTimeSlots
     * @description
     * Select an item into the current booking journey and route on to the next page dpending on the current page control
     *
     * @param {object} slot The slot from list
     * @param {string=} route A specific route to load
     */
    return $scope.selectItem = function (slot, route) {
        if ($scope.$parent.$has_page_control) {
            setItem(slot);
            return false;
        } else {
            setItem(slot);
            $scope.decideNextPage(route);
            return true;
        }
    };
});
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives.bbTimeSlots
 * @restrict AE
 * @scope true
 *
 * @description Loads a list of time slots for the currently in scope company
 *
 * @property {array} booking_item The booking item
 * @property {date} start_date The start date
 * @property {date} end_date The end date
 * @property {array} slots The slots
 * @property {object} validator The validator service - see {@link BB.Services:Validator validator Service}
 *
 */
angular.module('BB.Directives').directive('bbTimeSlots', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'TimeSlots',
        link: function link(scope, element, attrs) {
            if (attrs.bbItem) {
                scope.booking_item = scope.$eval(attrs.bbItem);
            }
            if (attrs.bbShowAll) {
                scope.show_all = true;
            }
        }
    };
});
'use strict';

angular.module('BB.Controllers').controller('TimeList', TimeListCtrl);

function TimeListCtrl($attrs, $scope, $rootScope, TimeService, AlertService, BBModel, DateTimeUtilitiesService, LoadingService, ErrorService, $translate, bbWidgetPage) {
    'ngInject';

    var loader = LoadingService.$loader($scope);

    if (!$scope.data_source) {
        $scope.data_source = $scope.bb.current_item;
    }

    $scope.options = $scope.$eval($attrs.bbTimes) || {};

    var currentSlot = null;

    $rootScope.connection_started.then(function () {

        if ($scope.bb.current_item.defaults.date && !$scope.bb.current_item.date) {
            $scope.setDate($scope.bb.current_item.defaults.date);
        } else if ($scope.bb.current_item.date) {
            $scope.setDate($scope.bb.current_item.date.date);
        } else {
            $scope.setDate(moment());
        }

        return $scope.loadDay();
    }, function (err) {
        return loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
    });

    /***
     * @ngdoc method
     * @name setDate
     * @methodOf BB.Directives.bbTimes
     * @description
     * Set the date the time list reprents
     *
     * @param {moment} date the date to set the time list to use
     */
    $scope.setDate = function (date) {
        var day = new BBModel.Day({ date: date, spaces: 1 });
        $scope.selected_day = day;
        return $scope.selected_date = day.date;
    };

    /***
     * @ngdoc method
     * @name setDataSource
     * @methodOf BB.Directives.bbTimes
     * @description
     * Set data source model of time list
     *
     * @param {object} source The source
     */
    $scope.setDataSource = function (source) {
        return $scope.data_source = source;
    };

    /***
     * @ngdoc method
     * @name setItemLinkSource
     * @methodOf BB.Directives.bbTimes
     * @description
     * Set item link source model
     *
     * @param {object} source The source
     */
    $scope.setItemLinkSource = function (source) {
        return $scope.item_link_source = source;
    };

    $scope.$on('dateChanged', function (event, newdate) {
        $scope.setDate(newdate);
        $scope.loadDay();
    });

    // when the current item is updated, reload the time data
    $scope.$on("currentItemUpdate", function (event) {
        return $scope.loadDay({ check_requested_slot: false });
    });

    /***
     * @ngdoc method
     * @name selectSlot
     * @methodOf BB.Directives.bbTimes
     * @description
     * Select the slot from time list in according of slot and route parameters
     *
     * @param {TimeSlot} slot The slot
     * @param {string} A specific route to load
     */
    $scope.selectSlot = function (slot, day, route) {

        if (slot && slot.availability() > 0) {

            currentSlot = slot;

            // if this time cal was also for a specific item source (i.e.a person or resoure- make sure we've selected it)
            if ($scope.item_link_source) {
                $scope.data_source.setItem($scope.item_link_source);
            }

            if (slot.datetime) {
                $scope.setLastSelectedDate(slot.datetime);
                $scope.data_source.setDate({ date: slot.datetime });
            } else if (day) {
                $scope.setLastSelectedDate(day.date);
                $scope.data_source.setDate(day);
            }

            $scope.data_source.setTime(slot);
            if ($scope.data_source.reserve_ready) {
                loader.notLoaded();
                $scope.addItemToBasket().then(function () {

                    if (bbWidgetPage.canAutoDecideNextPage('bb-times')) {

                        $scope.decideNextPage(route);
                    }
                }).finally(function () {
                    return loader.setLoaded();
                });
            } else {
                if (bbWidgetPage.canAutoDecideNextPage('bb-times')) {
                    $scope.decideNextPage(route);
                }
            }
        }
    };

    /***
     * @ngdoc method
     * @name highlightSlot
     * @methodOf BB.Directives.bbTimes
     * @description
     * The highlight slot from time list
     *
     * @param {TimeSlot} slot The slot
     */
    $scope.highlightSlot = function (slot, day) {
        if (day && slot && slot.availability() > 0) {
            if (slot.datetime) {
                $scope.setLastSelectedDate(slot.datetime);
                $scope.data_source.setDate({ date: slot.datetime });
            } else if (day) {
                $scope.setLastSelectedDate(day.date);
                $scope.data_source.setDate(day);
            }

            $scope.data_source.setTime(slot);

            // tell any accordion groups to update
            $scope.$broadcast('slotChanged', slot);
        }
    };

    /***
     * @ngdoc method
     * @name status
     * @methodOf BB.Directives.bbTimes
     * @description
     * Check the status of the slot to see if it has been selected
     *
     * @param {date} slot The slot
     */
    // check the status of the slot to see if it has been selected
    $scope.status = function (slot) {
        if (!slot) {
            return;
        }
        var status = slot.status();
        return status;
    };

    /***
     * @ngdoc method
     * @name add
     * @methodOf BB.Directives.bbTimes
     * @description
     * Add unit of time to the selected day
     *
     * @param {date} type The type
     * @param {date} amount The amount
     */
    // add unit of time to the selected day
    $scope.add = function (type, amount) {

        // clear existing time
        delete $scope.bb.current_item.time;

        var new_date = moment($scope.selected_day.date).add(amount, type);
        $scope.setDate(new_date);
        $scope.loadDay();
    };

    /***
     * @ngdoc method
     * @name subtract
     * @methodOf BB.Directives.bbTimes
     * @description
     * Subtract unit of time to the selected day
     *
     * @param {date} type The type
     * @param {date} amount The amount
     */
    // subtract unit of time to the selected day
    $scope.subtract = function (type, amount) {
        return $scope.add(type, -amount);
    };

    /***
     * @ngdoc method
     * @name loadDay
     * @methodOf BB.Directives.bbTimes
     * @description
     * Load day
     */
    $scope.loadDay = function (options) {

        if (!options) {
            options = { check_requested_slot: true };
        }
        if ($scope.data_source && ($scope.data_source.days_link || $scope.item_link_source) && $scope.selected_day) {

            loader.notLoaded();

            var pslots = TimeService.query({
                company: $scope.bb.company,
                cItem: $scope.data_source,
                item_link: $scope.item_link_source,
                date: $scope.selected_day.date,
                client: $scope.client,
                available: 1,
                people_ids: $scope.bb.item_defaults.people_ids
            });

            pslots.then(function (time_slots) {
                $scope.slots = time_slots;
                $scope.$broadcast('slotsUpdated', $scope.data_source, time_slots); // data_source is the BasketItem
                // padding is used to ensure that a list of time slots is always padded out with a certain of values, if it's a partial set of results
                if ($scope.add_padding && time_slots.length > 0) {
                    var dtimes = {};
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                        for (var _iterator = Array.from(time_slots)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                            var s = _step.value;

                            dtimes[s.time] = 1;
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return();
                            }
                        } finally {
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }

                    for (var v = 0; v < $scope.add_padding.length; v++) {
                        var pad = $scope.add_padding[v];
                        if (!dtimes[pad]) {
                            time_slots.splice(v, 0, new BBModel.TimeSlot({ time: pad, avail: 0 }, time_slots[0].service));
                        }
                    }
                }

                if (options.check_requested_slot === true) {
                    checkRequestedSlots(time_slots);
                }

                loader.setLoaded();
            }, function (err) {
                if (err.status === 404 && err.data && err.data.error && err.data.error === "No bookable events found") {
                    if ($scope.data_source && $scope.data_source.person) {
                        AlertService.warning(ErrorService.getError('NOT_BOOKABLE_PERSON'));
                        loader.setLoaded();
                    } else if ($scope.data_source && $scope.data_source.resource) {
                        AlertService.warning(ErrorService.getError('NOT_BOOKABLE_RESOURCE'));
                        loader.setLoaded();
                    } else {
                        loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
                    }
                } else {
                    loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
                }
            });
        }
    };

    var checkRequestedSlots = function checkRequestedSlots(time_slots) {
        if (!$scope.bb.item_defaults || !$scope.bb.item_defaults.time) {
            return;
        }

        var requested_slot = DateTimeUtilitiesService.checkDefaultTime($scope.selected_date, time_slots, $scope.data_source, $scope.bb.item_defaults);

        if (requested_slot.slot === null || requested_slot.match === null) {
            return $scope.availability_conflict = true;
        } else if (requested_slot.slot && requested_slot.match === "full") {
            $scope.skipThisStep();
            return $scope.selectSlot(requested_slot.slot, $scope.selected_day);
        } else if (requested_slot.slot && requested_slot.match === "partial") {
            return $scope.highlightSlot(requested_slot.slot, $scope.selected_day);
        }
    };

    /***
     * @ngdoc method
     * @name isCurrentTimeSlot
     * @methodOf BB.Directives.isCurrentTimeSlot
     * @description
     * Is the slot the currently selected slot
     *
     * @param {TimeSlot} slot
     */
    $scope.isCurrentTimeSlot = function (slot) {
        return currentSlot && slot.time == currentSlot.time;
    };

    /***
     * @ngdoc method
     * @name padTimes
     * @methodOf BB.Directives.bbTimes
     * @description
     * Pad Times in according of times parameter
     *
     * @param {date} times The times
     */
    $scope.padTimes = function (times) {
        return $scope.add_padding = times;
    };

    /***
     * @ngdoc method
     * @name setReady
     * @methodOf BB.Directives.bbTimes
     * @description
     * Set this page section as ready
     */
    $scope.setReady = function () {
        if (!$scope.data_source.time) {
            AlertService.clear();
            AlertService.add("danger", { msg: $translate.instant('PUBLIC_BOOKING.TIME.TIME_NOT_SELECTED_ALERT') });
            return false;
        } else {
            if ($scope.data_source.reserve_ready) {
                return $scope.addItemToBasket();
            } else {
                return true;
            }
        }
    };
}
'use strict';

/***
 * @ngdoc directive
 * @name BB.Directives.bbTimes
 * @restrict AE
 * @scope true
 *
 * @description
 *
 * Loads a list of times for the currently in scope company
 *
 * <pre>
 * restrict: 'AE'
 * replace: true
 * scope: true
 * </pre>
 *
 * @param {hash} bbTimes A hash of options
 * @property {array} selected_day The selected day
 * @property {date} selected_date The selected date
 * @property {array} data_source The data source
 * @property {array} item_link_source The item link source
 * @property {object} alert The alert service - see {@link BB.Services:Alert Alert Service}
 *
 */ //


angular.module('BB.Directives').directive('bbTimes', function () {
    return {
        restrict: 'AE',
        replace: true,
        scope: true,
        controller: 'TimeList'
    };
});
'use strict';

(function () {

    angular.module('BB.Controllers').controller('Total', TotalController);

    function TotalController($scope, $rootScope, $q, $location, $window, $log, QueryStringService, LoadingService, BBModel) {
        var loader = LoadingService.$loader($scope).notLoaded();

        $rootScope.$on('booking:moved', function (event, purchase) {
            $scope.total = purchase;
        });

        var init = function init() {
            $scope.bb.payment_status = null;
            var id = QueryStringService('purchase_id');
            if (id && !$scope.bb.total) {
                getPurchaseTotal(id);
            } else if ($scope.bb.total) {
                getTotalFromBB();
            } else {
                loader.setLoaded();
            }

            // Reset ready for another booking
            return $scope.reset();
        };

        var getPurchaseTotal = function getPurchaseTotal(purchaseTotalId) {
            BBModel.PurchaseTotal.$query({ url_root: $scope.bb.api_url, purchase_id: purchaseTotalId }).then(function (total) {
                $scope.total = total;
                loader.setLoaded();
                // emit checkout:success event if the amount paid matches the total price
                if (total.paid === total.total_price) {
                    return $scope.$emit("checkout:success", total);
                }
            });
        };

        var getTotalFromBB = function getTotalFromBB() {
            $scope.total = $scope.bb.total;
            loader.setLoaded();

            // emit checkout:success event if the amount paid matches the total price
            if ($scope.total.paid === $scope.total.total_price) {
                $scope.$emit("checkout:success", $scope.total);
            }
        };

        /**
         * @ngdoc method
         * @name print
         * @methodOf BB.Directives.bbTotal
         * @description Open new window from partial url
         */
        $scope.print = function () {
            $window.open($scope.bb.partial_url + 'print_purchase.html?id=' + $scope.total.long_id, '_blank', 'width=700,height=500,toolbar=0,menubar=0,location=0,status=1,scrollbars=1,resizable=1,left=0,top=0');
            return true;
        };

        $rootScope.connection_started.then(function () {
            init();
        }, function (err) {
            loader.setLoadedAndShowError(err, 'Sorry, something went wrong');
        });
    }
})();
'use strict';

(function () {

	/**
  * @ngdoc directive
  * @name BB.Directives.bbTotal
  * @restrict AE
  * @scope true
  *
  * @description Loads a list of totals for the currently in scope company
  *
  * @param {hash} bbTotal A hash of options
  * @property {array} payment_status The payment status
  * @property {array} total The total
  */
	angular.module('BB.Directives').directive('bbTotal', function () {
		return {
			restrict: 'AE',
			replace: true,
			scope: true,
			controller: 'Total'
		};
	});
})();
'use strict';

/**
 * @ngdoc service
 * @name BB.uib.runtimeUibModal
 *
 * @description
 * Returns an instance of $uibModalProvider that allows to set modal default options (on runtime)
 */
angular.module('BB.uib').provider('runtimeUibModal', function ($uibModalProvider) {
  'ngInject';

  var uibModalProvider = $uibModalProvider;
  this.setProvider = function (provider) {
    return uibModalProvider = provider;
  };
  this.$get = function () {
    return uibModalProvider;
  };
});